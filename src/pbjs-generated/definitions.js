/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.particle = (function() {
    
        /**
         * Namespace particle.
         * @exports particle
         * @namespace
         */
        var particle = {};
    
        particle.ctrl = (function() {
    
            /**
             * Namespace ctrl.
             * @memberof particle
             * @namespace
             */
            var ctrl = {};
    
            ctrl.cellular = (function() {
    
                /**
                 * Namespace cellular.
                 * @memberof particle.ctrl
                 * @namespace
                 */
                var cellular = {};
    
                /**
                 * SIM card types.
                 * 
                 * The Boron 2G/3G and Boron LTE can use either the built-in MFF2 embedded Particle SIM card or an external nano SIM card in the SIM card connector.
                 * 
                 * Note: The values of this enum should match the values defined by the `SimType` enum in the firmware.
                 * @name particle.ctrl.cellular.SimType
                 * @enum {number}
                 * @property {number} INVALID_SIM_TYPE=0 INVALID_SIM_TYPE value
                 * @property {number} INTERNAL=1 INTERNAL value
                 * @property {number} EXTERNAL=2 EXTERNAL value
                 */
                cellular.SimType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INVALID_SIM_TYPE"] = 0;
                    values[valuesById[1] = "INTERNAL"] = 1;
                    values[valuesById[2] = "EXTERNAL"] = 2;
                    return values;
                })();
    
                cellular.AccessPoint = (function() {
    
                    /**
                     * Properties of an AccessPoint.
                     * @memberof particle.ctrl.cellular
                     * @interface IAccessPoint
                     * @property {string|null} [apn] AccessPoint apn
                     * @property {string|null} [user] AccessPoint user
                     * @property {string|null} [password] AccessPoint password
                     * @property {boolean|null} [useDefaults] AccessPoint useDefaults
                     */
    
                    /**
                     * Constructs a new AccessPoint.
                     * @memberof particle.ctrl.cellular
                     * @classdesc Access point settings for 3rd party SIM credentials for the Cellular network.
                     * @implements IAccessPoint
                     * @constructor
                     * @param {particle.ctrl.cellular.IAccessPoint=} [properties] Properties to set
                     */
                    function AccessPoint(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * AccessPoint apn.
                     * @member {string} apn
                     * @memberof particle.ctrl.cellular.AccessPoint
                     * @instance
                     */
                    AccessPoint.prototype.apn = "";
    
                    /**
                     * AccessPoint user.
                     * @member {string} user
                     * @memberof particle.ctrl.cellular.AccessPoint
                     * @instance
                     */
                    AccessPoint.prototype.user = "";
    
                    /**
                     * AccessPoint password.
                     * @member {string} password
                     * @memberof particle.ctrl.cellular.AccessPoint
                     * @instance
                     */
                    AccessPoint.prototype.password = "";
    
                    /**
                     * AccessPoint useDefaults.
                     * @member {boolean} useDefaults
                     * @memberof particle.ctrl.cellular.AccessPoint
                     * @instance
                     */
                    AccessPoint.prototype.useDefaults = false;
    
                    /**
                     * Creates a new AccessPoint instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cellular.AccessPoint
                     * @static
                     * @param {particle.ctrl.cellular.IAccessPoint=} [properties] Properties to set
                     * @returns {particle.ctrl.cellular.AccessPoint} AccessPoint instance
                     */
                    AccessPoint.create = function create(properties) {
                        return new AccessPoint(properties);
                    };
    
                    /**
                     * Encodes the specified AccessPoint message. Does not implicitly {@link particle.ctrl.cellular.AccessPoint.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cellular.AccessPoint
                     * @static
                     * @param {particle.ctrl.cellular.IAccessPoint} message AccessPoint message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AccessPoint.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.apn != null && Object.hasOwnProperty.call(message, "apn"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.apn);
                        if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.user);
                        if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
                        if (message.useDefaults != null && Object.hasOwnProperty.call(message, "useDefaults"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.useDefaults);
                        return writer;
                    };
    
                    /**
                     * Decodes an AccessPoint message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cellular.AccessPoint
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cellular.AccessPoint} AccessPoint
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AccessPoint.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.AccessPoint();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.apn = reader.string();
                                break;
                            case 2:
                                message.user = reader.string();
                                break;
                            case 3:
                                message.password = reader.string();
                                break;
                            case 4:
                                message.useDefaults = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return AccessPoint;
                })();
    
                cellular.SetAccessPointRequest = (function() {
    
                    /**
                     * Properties of a SetAccessPointRequest.
                     * @memberof particle.ctrl.cellular
                     * @interface ISetAccessPointRequest
                     * @property {particle.ctrl.cellular.SimType|null} [simType] SetAccessPointRequest simType
                     * @property {particle.ctrl.cellular.IAccessPoint|null} [accessPoint] SetAccessPointRequest accessPoint
                     */
    
                    /**
                     * Constructs a new SetAccessPointRequest.
                     * @memberof particle.ctrl.cellular
                     * @classdesc Set access point settings.
                     * @implements ISetAccessPointRequest
                     * @constructor
                     * @param {particle.ctrl.cellular.ISetAccessPointRequest=} [properties] Properties to set
                     */
                    function SetAccessPointRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SetAccessPointRequest simType.
                     * @member {particle.ctrl.cellular.SimType} simType
                     * @memberof particle.ctrl.cellular.SetAccessPointRequest
                     * @instance
                     */
                    SetAccessPointRequest.prototype.simType = 0;
    
                    /**
                     * SetAccessPointRequest accessPoint.
                     * @member {particle.ctrl.cellular.IAccessPoint|null|undefined} accessPoint
                     * @memberof particle.ctrl.cellular.SetAccessPointRequest
                     * @instance
                     */
                    SetAccessPointRequest.prototype.accessPoint = null;
    
                    /**
                     * Creates a new SetAccessPointRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cellular.SetAccessPointRequest
                     * @static
                     * @param {particle.ctrl.cellular.ISetAccessPointRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.cellular.SetAccessPointRequest} SetAccessPointRequest instance
                     */
                    SetAccessPointRequest.create = function create(properties) {
                        return new SetAccessPointRequest(properties);
                    };
    
                    /**
                     * Encodes the specified SetAccessPointRequest message. Does not implicitly {@link particle.ctrl.cellular.SetAccessPointRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cellular.SetAccessPointRequest
                     * @static
                     * @param {particle.ctrl.cellular.ISetAccessPointRequest} message SetAccessPointRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SetAccessPointRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.simType != null && Object.hasOwnProperty.call(message, "simType"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simType);
                        if (message.accessPoint != null && Object.hasOwnProperty.call(message, "accessPoint"))
                            $root.particle.ctrl.cellular.AccessPoint.encode(message.accessPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a SetAccessPointRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cellular.SetAccessPointRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cellular.SetAccessPointRequest} SetAccessPointRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SetAccessPointRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.SetAccessPointRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.simType = reader.int32();
                                break;
                            case 2:
                                message.accessPoint = $root.particle.ctrl.cellular.AccessPoint.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return SetAccessPointRequest;
                })();
    
                cellular.SetAccessPointReply = (function() {
    
                    /**
                     * Properties of a SetAccessPointReply.
                     * @memberof particle.ctrl.cellular
                     * @interface ISetAccessPointReply
                     */
    
                    /**
                     * Constructs a new SetAccessPointReply.
                     * @memberof particle.ctrl.cellular
                     * @classdesc Represents a SetAccessPointReply.
                     * @implements ISetAccessPointReply
                     * @constructor
                     * @param {particle.ctrl.cellular.ISetAccessPointReply=} [properties] Properties to set
                     */
                    function SetAccessPointReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new SetAccessPointReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cellular.SetAccessPointReply
                     * @static
                     * @param {particle.ctrl.cellular.ISetAccessPointReply=} [properties] Properties to set
                     * @returns {particle.ctrl.cellular.SetAccessPointReply} SetAccessPointReply instance
                     */
                    SetAccessPointReply.create = function create(properties) {
                        return new SetAccessPointReply(properties);
                    };
    
                    /**
                     * Encodes the specified SetAccessPointReply message. Does not implicitly {@link particle.ctrl.cellular.SetAccessPointReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cellular.SetAccessPointReply
                     * @static
                     * @param {particle.ctrl.cellular.ISetAccessPointReply} message SetAccessPointReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SetAccessPointReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a SetAccessPointReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cellular.SetAccessPointReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cellular.SetAccessPointReply} SetAccessPointReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SetAccessPointReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.SetAccessPointReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return SetAccessPointReply;
                })();
    
                cellular.GetAccessPointRequest = (function() {
    
                    /**
                     * Properties of a GetAccessPointRequest.
                     * @memberof particle.ctrl.cellular
                     * @interface IGetAccessPointRequest
                     * @property {particle.ctrl.cellular.SimType|null} [simType] GetAccessPointRequest simType
                     */
    
                    /**
                     * Constructs a new GetAccessPointRequest.
                     * @memberof particle.ctrl.cellular
                     * @classdesc Get access point settings.
                     * @implements IGetAccessPointRequest
                     * @constructor
                     * @param {particle.ctrl.cellular.IGetAccessPointRequest=} [properties] Properties to set
                     */
                    function GetAccessPointRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * GetAccessPointRequest simType.
                     * @member {particle.ctrl.cellular.SimType} simType
                     * @memberof particle.ctrl.cellular.GetAccessPointRequest
                     * @instance
                     */
                    GetAccessPointRequest.prototype.simType = 0;
    
                    /**
                     * Creates a new GetAccessPointRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cellular.GetAccessPointRequest
                     * @static
                     * @param {particle.ctrl.cellular.IGetAccessPointRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.cellular.GetAccessPointRequest} GetAccessPointRequest instance
                     */
                    GetAccessPointRequest.create = function create(properties) {
                        return new GetAccessPointRequest(properties);
                    };
    
                    /**
                     * Encodes the specified GetAccessPointRequest message. Does not implicitly {@link particle.ctrl.cellular.GetAccessPointRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cellular.GetAccessPointRequest
                     * @static
                     * @param {particle.ctrl.cellular.IGetAccessPointRequest} message GetAccessPointRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetAccessPointRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.simType != null && Object.hasOwnProperty.call(message, "simType"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simType);
                        return writer;
                    };
    
                    /**
                     * Decodes a GetAccessPointRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cellular.GetAccessPointRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cellular.GetAccessPointRequest} GetAccessPointRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetAccessPointRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetAccessPointRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.simType = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetAccessPointRequest;
                })();
    
                cellular.GetAccessPointReply = (function() {
    
                    /**
                     * Properties of a GetAccessPointReply.
                     * @memberof particle.ctrl.cellular
                     * @interface IGetAccessPointReply
                     * @property {particle.ctrl.cellular.IAccessPoint|null} [accessPoint] GetAccessPointReply accessPoint
                     */
    
                    /**
                     * Constructs a new GetAccessPointReply.
                     * @memberof particle.ctrl.cellular
                     * @classdesc Represents a GetAccessPointReply.
                     * @implements IGetAccessPointReply
                     * @constructor
                     * @param {particle.ctrl.cellular.IGetAccessPointReply=} [properties] Properties to set
                     */
                    function GetAccessPointReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * GetAccessPointReply accessPoint.
                     * @member {particle.ctrl.cellular.IAccessPoint|null|undefined} accessPoint
                     * @memberof particle.ctrl.cellular.GetAccessPointReply
                     * @instance
                     */
                    GetAccessPointReply.prototype.accessPoint = null;
    
                    /**
                     * Creates a new GetAccessPointReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cellular.GetAccessPointReply
                     * @static
                     * @param {particle.ctrl.cellular.IGetAccessPointReply=} [properties] Properties to set
                     * @returns {particle.ctrl.cellular.GetAccessPointReply} GetAccessPointReply instance
                     */
                    GetAccessPointReply.create = function create(properties) {
                        return new GetAccessPointReply(properties);
                    };
    
                    /**
                     * Encodes the specified GetAccessPointReply message. Does not implicitly {@link particle.ctrl.cellular.GetAccessPointReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cellular.GetAccessPointReply
                     * @static
                     * @param {particle.ctrl.cellular.IGetAccessPointReply} message GetAccessPointReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetAccessPointReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.accessPoint != null && Object.hasOwnProperty.call(message, "accessPoint"))
                            $root.particle.ctrl.cellular.AccessPoint.encode(message.accessPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a GetAccessPointReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cellular.GetAccessPointReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cellular.GetAccessPointReply} GetAccessPointReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetAccessPointReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetAccessPointReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.accessPoint = $root.particle.ctrl.cellular.AccessPoint.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetAccessPointReply;
                })();
    
                cellular.SetActiveSimRequest = (function() {
    
                    /**
                     * Properties of a SetActiveSimRequest.
                     * @memberof particle.ctrl.cellular
                     * @interface ISetActiveSimRequest
                     * @property {particle.ctrl.cellular.SimType|null} [simType] SetActiveSimRequest simType
                     */
    
                    /**
                     * Constructs a new SetActiveSimRequest.
                     * @memberof particle.ctrl.cellular
                     * @classdesc Set active SIM card.
                     * 
                     * Note: The device needs to be reset in order for the settings to take effect.
                     * @implements ISetActiveSimRequest
                     * @constructor
                     * @param {particle.ctrl.cellular.ISetActiveSimRequest=} [properties] Properties to set
                     */
                    function SetActiveSimRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SetActiveSimRequest simType.
                     * @member {particle.ctrl.cellular.SimType} simType
                     * @memberof particle.ctrl.cellular.SetActiveSimRequest
                     * @instance
                     */
                    SetActiveSimRequest.prototype.simType = 0;
    
                    /**
                     * Creates a new SetActiveSimRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cellular.SetActiveSimRequest
                     * @static
                     * @param {particle.ctrl.cellular.ISetActiveSimRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.cellular.SetActiveSimRequest} SetActiveSimRequest instance
                     */
                    SetActiveSimRequest.create = function create(properties) {
                        return new SetActiveSimRequest(properties);
                    };
    
                    /**
                     * Encodes the specified SetActiveSimRequest message. Does not implicitly {@link particle.ctrl.cellular.SetActiveSimRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cellular.SetActiveSimRequest
                     * @static
                     * @param {particle.ctrl.cellular.ISetActiveSimRequest} message SetActiveSimRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SetActiveSimRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.simType != null && Object.hasOwnProperty.call(message, "simType"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simType);
                        return writer;
                    };
    
                    /**
                     * Decodes a SetActiveSimRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cellular.SetActiveSimRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cellular.SetActiveSimRequest} SetActiveSimRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SetActiveSimRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.SetActiveSimRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.simType = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return SetActiveSimRequest;
                })();
    
                cellular.SetActiveSimReply = (function() {
    
                    /**
                     * Properties of a SetActiveSimReply.
                     * @memberof particle.ctrl.cellular
                     * @interface ISetActiveSimReply
                     */
    
                    /**
                     * Constructs a new SetActiveSimReply.
                     * @memberof particle.ctrl.cellular
                     * @classdesc Represents a SetActiveSimReply.
                     * @implements ISetActiveSimReply
                     * @constructor
                     * @param {particle.ctrl.cellular.ISetActiveSimReply=} [properties] Properties to set
                     */
                    function SetActiveSimReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new SetActiveSimReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cellular.SetActiveSimReply
                     * @static
                     * @param {particle.ctrl.cellular.ISetActiveSimReply=} [properties] Properties to set
                     * @returns {particle.ctrl.cellular.SetActiveSimReply} SetActiveSimReply instance
                     */
                    SetActiveSimReply.create = function create(properties) {
                        return new SetActiveSimReply(properties);
                    };
    
                    /**
                     * Encodes the specified SetActiveSimReply message. Does not implicitly {@link particle.ctrl.cellular.SetActiveSimReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cellular.SetActiveSimReply
                     * @static
                     * @param {particle.ctrl.cellular.ISetActiveSimReply} message SetActiveSimReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SetActiveSimReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a SetActiveSimReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cellular.SetActiveSimReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cellular.SetActiveSimReply} SetActiveSimReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SetActiveSimReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.SetActiveSimReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return SetActiveSimReply;
                })();
    
                cellular.GetActiveSimRequest = (function() {
    
                    /**
                     * Properties of a GetActiveSimRequest.
                     * @memberof particle.ctrl.cellular
                     * @interface IGetActiveSimRequest
                     */
    
                    /**
                     * Constructs a new GetActiveSimRequest.
                     * @memberof particle.ctrl.cellular
                     * @classdesc Get active SIM card.
                     * @implements IGetActiveSimRequest
                     * @constructor
                     * @param {particle.ctrl.cellular.IGetActiveSimRequest=} [properties] Properties to set
                     */
                    function GetActiveSimRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new GetActiveSimRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cellular.GetActiveSimRequest
                     * @static
                     * @param {particle.ctrl.cellular.IGetActiveSimRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.cellular.GetActiveSimRequest} GetActiveSimRequest instance
                     */
                    GetActiveSimRequest.create = function create(properties) {
                        return new GetActiveSimRequest(properties);
                    };
    
                    /**
                     * Encodes the specified GetActiveSimRequest message. Does not implicitly {@link particle.ctrl.cellular.GetActiveSimRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cellular.GetActiveSimRequest
                     * @static
                     * @param {particle.ctrl.cellular.IGetActiveSimRequest} message GetActiveSimRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetActiveSimRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a GetActiveSimRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cellular.GetActiveSimRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cellular.GetActiveSimRequest} GetActiveSimRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetActiveSimRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetActiveSimRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetActiveSimRequest;
                })();
    
                cellular.GetActiveSimReply = (function() {
    
                    /**
                     * Properties of a GetActiveSimReply.
                     * @memberof particle.ctrl.cellular
                     * @interface IGetActiveSimReply
                     * @property {particle.ctrl.cellular.SimType|null} [simType] GetActiveSimReply simType
                     */
    
                    /**
                     * Constructs a new GetActiveSimReply.
                     * @memberof particle.ctrl.cellular
                     * @classdesc Represents a GetActiveSimReply.
                     * @implements IGetActiveSimReply
                     * @constructor
                     * @param {particle.ctrl.cellular.IGetActiveSimReply=} [properties] Properties to set
                     */
                    function GetActiveSimReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * GetActiveSimReply simType.
                     * @member {particle.ctrl.cellular.SimType} simType
                     * @memberof particle.ctrl.cellular.GetActiveSimReply
                     * @instance
                     */
                    GetActiveSimReply.prototype.simType = 0;
    
                    /**
                     * Creates a new GetActiveSimReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cellular.GetActiveSimReply
                     * @static
                     * @param {particle.ctrl.cellular.IGetActiveSimReply=} [properties] Properties to set
                     * @returns {particle.ctrl.cellular.GetActiveSimReply} GetActiveSimReply instance
                     */
                    GetActiveSimReply.create = function create(properties) {
                        return new GetActiveSimReply(properties);
                    };
    
                    /**
                     * Encodes the specified GetActiveSimReply message. Does not implicitly {@link particle.ctrl.cellular.GetActiveSimReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cellular.GetActiveSimReply
                     * @static
                     * @param {particle.ctrl.cellular.IGetActiveSimReply} message GetActiveSimReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetActiveSimReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.simType != null && Object.hasOwnProperty.call(message, "simType"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simType);
                        return writer;
                    };
    
                    /**
                     * Decodes a GetActiveSimReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cellular.GetActiveSimReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cellular.GetActiveSimReply} GetActiveSimReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetActiveSimReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetActiveSimReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.simType = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetActiveSimReply;
                })();
    
                cellular.GetIccidRequest = (function() {
    
                    /**
                     * Properties of a GetIccidRequest.
                     * @memberof particle.ctrl.cellular
                     * @interface IGetIccidRequest
                     */
    
                    /**
                     * Constructs a new GetIccidRequest.
                     * @memberof particle.ctrl.cellular
                     * @classdesc Get ICCID.
                     * @implements IGetIccidRequest
                     * @constructor
                     * @param {particle.ctrl.cellular.IGetIccidRequest=} [properties] Properties to set
                     */
                    function GetIccidRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new GetIccidRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cellular.GetIccidRequest
                     * @static
                     * @param {particle.ctrl.cellular.IGetIccidRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.cellular.GetIccidRequest} GetIccidRequest instance
                     */
                    GetIccidRequest.create = function create(properties) {
                        return new GetIccidRequest(properties);
                    };
    
                    /**
                     * Encodes the specified GetIccidRequest message. Does not implicitly {@link particle.ctrl.cellular.GetIccidRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cellular.GetIccidRequest
                     * @static
                     * @param {particle.ctrl.cellular.IGetIccidRequest} message GetIccidRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetIccidRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a GetIccidRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cellular.GetIccidRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cellular.GetIccidRequest} GetIccidRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetIccidRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetIccidRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetIccidRequest;
                })();
    
                cellular.GetIccidReply = (function() {
    
                    /**
                     * Properties of a GetIccidReply.
                     * @memberof particle.ctrl.cellular
                     * @interface IGetIccidReply
                     * @property {string|null} [iccid] GetIccidReply iccid
                     */
    
                    /**
                     * Constructs a new GetIccidReply.
                     * @memberof particle.ctrl.cellular
                     * @classdesc Represents a GetIccidReply.
                     * @implements IGetIccidReply
                     * @constructor
                     * @param {particle.ctrl.cellular.IGetIccidReply=} [properties] Properties to set
                     */
                    function GetIccidReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * GetIccidReply iccid.
                     * @member {string} iccid
                     * @memberof particle.ctrl.cellular.GetIccidReply
                     * @instance
                     */
                    GetIccidReply.prototype.iccid = "";
    
                    /**
                     * Creates a new GetIccidReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cellular.GetIccidReply
                     * @static
                     * @param {particle.ctrl.cellular.IGetIccidReply=} [properties] Properties to set
                     * @returns {particle.ctrl.cellular.GetIccidReply} GetIccidReply instance
                     */
                    GetIccidReply.create = function create(properties) {
                        return new GetIccidReply(properties);
                    };
    
                    /**
                     * Encodes the specified GetIccidReply message. Does not implicitly {@link particle.ctrl.cellular.GetIccidReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cellular.GetIccidReply
                     * @static
                     * @param {particle.ctrl.cellular.IGetIccidReply} message GetIccidReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetIccidReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.iccid != null && Object.hasOwnProperty.call(message, "iccid"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.iccid);
                        return writer;
                    };
    
                    /**
                     * Decodes a GetIccidReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cellular.GetIccidReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cellular.GetIccidReply} GetIccidReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetIccidReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetIccidReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.iccid = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetIccidReply;
                })();
    
                return cellular;
            })();
    
            ctrl.cloud = (function() {
    
                /**
                 * Namespace cloud.
                 * @memberof particle.ctrl
                 * @namespace
                 */
                var cloud = {};
    
                /**
                 * ConnectionStatus enum.
                 * @name particle.ctrl.cloud.ConnectionStatus
                 * @enum {number}
                 * @property {number} DISCONNECTED=0 DISCONNECTED value
                 * @property {number} CONNECTING=1 CONNECTING value
                 * @property {number} CONNECTED=2 CONNECTED value
                 * @property {number} DISCONNECTING=3 DISCONNECTING value
                 */
                cloud.ConnectionStatus = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "DISCONNECTED"] = 0;
                    values[valuesById[1] = "CONNECTING"] = 1;
                    values[valuesById[2] = "CONNECTED"] = 2;
                    values[valuesById[3] = "DISCONNECTING"] = 3;
                    return values;
                })();
    
                cloud.GetConnectionStatusRequest = (function() {
    
                    /**
                     * Properties of a GetConnectionStatusRequest.
                     * @memberof particle.ctrl.cloud
                     * @interface IGetConnectionStatusRequest
                     */
    
                    /**
                     * Constructs a new GetConnectionStatusRequest.
                     * @memberof particle.ctrl.cloud
                     * @classdesc Represents a GetConnectionStatusRequest.
                     * @implements IGetConnectionStatusRequest
                     * @constructor
                     * @param {particle.ctrl.cloud.IGetConnectionStatusRequest=} [properties] Properties to set
                     */
                    function GetConnectionStatusRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new GetConnectionStatusRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cloud.GetConnectionStatusRequest
                     * @static
                     * @param {particle.ctrl.cloud.IGetConnectionStatusRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.cloud.GetConnectionStatusRequest} GetConnectionStatusRequest instance
                     */
                    GetConnectionStatusRequest.create = function create(properties) {
                        return new GetConnectionStatusRequest(properties);
                    };
    
                    /**
                     * Encodes the specified GetConnectionStatusRequest message. Does not implicitly {@link particle.ctrl.cloud.GetConnectionStatusRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cloud.GetConnectionStatusRequest
                     * @static
                     * @param {particle.ctrl.cloud.IGetConnectionStatusRequest} message GetConnectionStatusRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetConnectionStatusRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a GetConnectionStatusRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cloud.GetConnectionStatusRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cloud.GetConnectionStatusRequest} GetConnectionStatusRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetConnectionStatusRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.GetConnectionStatusRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetConnectionStatusRequest;
                })();
    
                cloud.GetConnectionStatusReply = (function() {
    
                    /**
                     * Properties of a GetConnectionStatusReply.
                     * @memberof particle.ctrl.cloud
                     * @interface IGetConnectionStatusReply
                     * @property {particle.ctrl.cloud.ConnectionStatus|null} [status] GetConnectionStatusReply status
                     */
    
                    /**
                     * Constructs a new GetConnectionStatusReply.
                     * @memberof particle.ctrl.cloud
                     * @classdesc Represents a GetConnectionStatusReply.
                     * @implements IGetConnectionStatusReply
                     * @constructor
                     * @param {particle.ctrl.cloud.IGetConnectionStatusReply=} [properties] Properties to set
                     */
                    function GetConnectionStatusReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * GetConnectionStatusReply status.
                     * @member {particle.ctrl.cloud.ConnectionStatus} status
                     * @memberof particle.ctrl.cloud.GetConnectionStatusReply
                     * @instance
                     */
                    GetConnectionStatusReply.prototype.status = 0;
    
                    /**
                     * Creates a new GetConnectionStatusReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cloud.GetConnectionStatusReply
                     * @static
                     * @param {particle.ctrl.cloud.IGetConnectionStatusReply=} [properties] Properties to set
                     * @returns {particle.ctrl.cloud.GetConnectionStatusReply} GetConnectionStatusReply instance
                     */
                    GetConnectionStatusReply.create = function create(properties) {
                        return new GetConnectionStatusReply(properties);
                    };
    
                    /**
                     * Encodes the specified GetConnectionStatusReply message. Does not implicitly {@link particle.ctrl.cloud.GetConnectionStatusReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cloud.GetConnectionStatusReply
                     * @static
                     * @param {particle.ctrl.cloud.IGetConnectionStatusReply} message GetConnectionStatusReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetConnectionStatusReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                        return writer;
                    };
    
                    /**
                     * Decodes a GetConnectionStatusReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cloud.GetConnectionStatusReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cloud.GetConnectionStatusReply} GetConnectionStatusReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetConnectionStatusReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.GetConnectionStatusReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.status = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetConnectionStatusReply;
                })();
    
                cloud.ConnectRequest = (function() {
    
                    /**
                     * Properties of a ConnectRequest.
                     * @memberof particle.ctrl.cloud
                     * @interface IConnectRequest
                     */
    
                    /**
                     * Constructs a new ConnectRequest.
                     * @memberof particle.ctrl.cloud
                     * @classdesc Represents a ConnectRequest.
                     * @implements IConnectRequest
                     * @constructor
                     * @param {particle.ctrl.cloud.IConnectRequest=} [properties] Properties to set
                     */
                    function ConnectRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new ConnectRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cloud.ConnectRequest
                     * @static
                     * @param {particle.ctrl.cloud.IConnectRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.cloud.ConnectRequest} ConnectRequest instance
                     */
                    ConnectRequest.create = function create(properties) {
                        return new ConnectRequest(properties);
                    };
    
                    /**
                     * Encodes the specified ConnectRequest message. Does not implicitly {@link particle.ctrl.cloud.ConnectRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cloud.ConnectRequest
                     * @static
                     * @param {particle.ctrl.cloud.IConnectRequest} message ConnectRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ConnectRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a ConnectRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cloud.ConnectRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cloud.ConnectRequest} ConnectRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ConnectRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.ConnectRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return ConnectRequest;
                })();
    
                cloud.ConnectReply = (function() {
    
                    /**
                     * Properties of a ConnectReply.
                     * @memberof particle.ctrl.cloud
                     * @interface IConnectReply
                     */
    
                    /**
                     * Constructs a new ConnectReply.
                     * @memberof particle.ctrl.cloud
                     * @classdesc Represents a ConnectReply.
                     * @implements IConnectReply
                     * @constructor
                     * @param {particle.ctrl.cloud.IConnectReply=} [properties] Properties to set
                     */
                    function ConnectReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new ConnectReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cloud.ConnectReply
                     * @static
                     * @param {particle.ctrl.cloud.IConnectReply=} [properties] Properties to set
                     * @returns {particle.ctrl.cloud.ConnectReply} ConnectReply instance
                     */
                    ConnectReply.create = function create(properties) {
                        return new ConnectReply(properties);
                    };
    
                    /**
                     * Encodes the specified ConnectReply message. Does not implicitly {@link particle.ctrl.cloud.ConnectReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cloud.ConnectReply
                     * @static
                     * @param {particle.ctrl.cloud.IConnectReply} message ConnectReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ConnectReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a ConnectReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cloud.ConnectReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cloud.ConnectReply} ConnectReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ConnectReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.ConnectReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return ConnectReply;
                })();
    
                cloud.DisconnectRequest = (function() {
    
                    /**
                     * Properties of a DisconnectRequest.
                     * @memberof particle.ctrl.cloud
                     * @interface IDisconnectRequest
                     */
    
                    /**
                     * Constructs a new DisconnectRequest.
                     * @memberof particle.ctrl.cloud
                     * @classdesc Represents a DisconnectRequest.
                     * @implements IDisconnectRequest
                     * @constructor
                     * @param {particle.ctrl.cloud.IDisconnectRequest=} [properties] Properties to set
                     */
                    function DisconnectRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new DisconnectRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cloud.DisconnectRequest
                     * @static
                     * @param {particle.ctrl.cloud.IDisconnectRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.cloud.DisconnectRequest} DisconnectRequest instance
                     */
                    DisconnectRequest.create = function create(properties) {
                        return new DisconnectRequest(properties);
                    };
    
                    /**
                     * Encodes the specified DisconnectRequest message. Does not implicitly {@link particle.ctrl.cloud.DisconnectRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cloud.DisconnectRequest
                     * @static
                     * @param {particle.ctrl.cloud.IDisconnectRequest} message DisconnectRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DisconnectRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a DisconnectRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cloud.DisconnectRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cloud.DisconnectRequest} DisconnectRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DisconnectRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.DisconnectRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return DisconnectRequest;
                })();
    
                cloud.DisconnectReply = (function() {
    
                    /**
                     * Properties of a DisconnectReply.
                     * @memberof particle.ctrl.cloud
                     * @interface IDisconnectReply
                     */
    
                    /**
                     * Constructs a new DisconnectReply.
                     * @memberof particle.ctrl.cloud
                     * @classdesc Represents a DisconnectReply.
                     * @implements IDisconnectReply
                     * @constructor
                     * @param {particle.ctrl.cloud.IDisconnectReply=} [properties] Properties to set
                     */
                    function DisconnectReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new DisconnectReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.cloud.DisconnectReply
                     * @static
                     * @param {particle.ctrl.cloud.IDisconnectReply=} [properties] Properties to set
                     * @returns {particle.ctrl.cloud.DisconnectReply} DisconnectReply instance
                     */
                    DisconnectReply.create = function create(properties) {
                        return new DisconnectReply(properties);
                    };
    
                    /**
                     * Encodes the specified DisconnectReply message. Does not implicitly {@link particle.ctrl.cloud.DisconnectReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.cloud.DisconnectReply
                     * @static
                     * @param {particle.ctrl.cloud.IDisconnectReply} message DisconnectReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DisconnectReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a DisconnectReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.cloud.DisconnectReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.cloud.DisconnectReply} DisconnectReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DisconnectReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.DisconnectReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return DisconnectReply;
                })();
    
                return cloud;
            })();
    
            /**
             * ResultCode enum.
             * @name particle.ctrl.ResultCode
             * @enum {number}
             * @property {number} OK=0 OK value
             * @property {number} NOT_ALLOWED=1 NOT_ALLOWED value
             * @property {number} TIMEOUT=2 TIMEOUT value
             * @property {number} NOT_FOUND=3 NOT_FOUND value
             * @property {number} ALREADY_EXIST=4 ALREADY_EXIST value
             * @property {number} INVALID_STATE=5 INVALID_STATE value
             * @property {number} NO_MEMORY=6 NO_MEMORY value
             * @property {number} INVALID_PARAM=7 INVALID_PARAM value
             */
            ctrl.ResultCode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OK"] = 0;
                values[valuesById[1] = "NOT_ALLOWED"] = 1;
                values[valuesById[2] = "TIMEOUT"] = 2;
                values[valuesById[3] = "NOT_FOUND"] = 3;
                values[valuesById[4] = "ALREADY_EXIST"] = 4;
                values[valuesById[5] = "INVALID_STATE"] = 5;
                values[valuesById[6] = "NO_MEMORY"] = 6;
                values[valuesById[7] = "INVALID_PARAM"] = 7;
                return values;
            })();
    
            ctrl.Ipv4Address = (function() {
    
                /**
                 * Properties of an Ipv4Address.
                 * @memberof particle.ctrl
                 * @interface IIpv4Address
                 * @property {number|null} [address] Ipv4Address address
                 */
    
                /**
                 * Constructs a new Ipv4Address.
                 * @memberof particle.ctrl
                 * @classdesc Represents an Ipv4Address.
                 * @implements IIpv4Address
                 * @constructor
                 * @param {particle.ctrl.IIpv4Address=} [properties] Properties to set
                 */
                function Ipv4Address(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Ipv4Address address.
                 * @member {number} address
                 * @memberof particle.ctrl.Ipv4Address
                 * @instance
                 */
                Ipv4Address.prototype.address = 0;
    
                /**
                 * Creates a new Ipv4Address instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.Ipv4Address
                 * @static
                 * @param {particle.ctrl.IIpv4Address=} [properties] Properties to set
                 * @returns {particle.ctrl.Ipv4Address} Ipv4Address instance
                 */
                Ipv4Address.create = function create(properties) {
                    return new Ipv4Address(properties);
                };
    
                /**
                 * Encodes the specified Ipv4Address message. Does not implicitly {@link particle.ctrl.Ipv4Address.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.Ipv4Address
                 * @static
                 * @param {particle.ctrl.IIpv4Address} message Ipv4Address message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ipv4Address.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.address);
                    return writer;
                };
    
                /**
                 * Decodes an Ipv4Address message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.Ipv4Address
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.Ipv4Address} Ipv4Address
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ipv4Address.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Ipv4Address();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.address = reader.fixed32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return Ipv4Address;
            })();
    
            ctrl.Ipv6Address = (function() {
    
                /**
                 * Properties of an Ipv6Address.
                 * @memberof particle.ctrl
                 * @interface IIpv6Address
                 * @property {Uint8Array|null} [address] Ipv6Address address
                 */
    
                /**
                 * Constructs a new Ipv6Address.
                 * @memberof particle.ctrl
                 * @classdesc Represents an Ipv6Address.
                 * @implements IIpv6Address
                 * @constructor
                 * @param {particle.ctrl.IIpv6Address=} [properties] Properties to set
                 */
                function Ipv6Address(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Ipv6Address address.
                 * @member {Uint8Array} address
                 * @memberof particle.ctrl.Ipv6Address
                 * @instance
                 */
                Ipv6Address.prototype.address = $util.newBuffer([]);
    
                /**
                 * Creates a new Ipv6Address instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.Ipv6Address
                 * @static
                 * @param {particle.ctrl.IIpv6Address=} [properties] Properties to set
                 * @returns {particle.ctrl.Ipv6Address} Ipv6Address instance
                 */
                Ipv6Address.create = function create(properties) {
                    return new Ipv6Address(properties);
                };
    
                /**
                 * Encodes the specified Ipv6Address message. Does not implicitly {@link particle.ctrl.Ipv6Address.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.Ipv6Address
                 * @static
                 * @param {particle.ctrl.IIpv6Address} message Ipv6Address message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ipv6Address.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
                    return writer;
                };
    
                /**
                 * Decodes an Ipv6Address message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.Ipv6Address
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.Ipv6Address} Ipv6Address
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ipv6Address.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Ipv6Address();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.address = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return Ipv6Address;
            })();
    
            ctrl.IpAddress = (function() {
    
                /**
                 * Properties of an IpAddress.
                 * @memberof particle.ctrl
                 * @interface IIpAddress
                 * @property {particle.ctrl.IIpv4Address|null} [v4] IpAddress v4
                 * @property {particle.ctrl.IIpv6Address|null} [v6] IpAddress v6
                 */
    
                /**
                 * Constructs a new IpAddress.
                 * @memberof particle.ctrl
                 * @classdesc Represents an IpAddress.
                 * @implements IIpAddress
                 * @constructor
                 * @param {particle.ctrl.IIpAddress=} [properties] Properties to set
                 */
                function IpAddress(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * IpAddress v4.
                 * @member {particle.ctrl.IIpv4Address|null|undefined} v4
                 * @memberof particle.ctrl.IpAddress
                 * @instance
                 */
                IpAddress.prototype.v4 = null;
    
                /**
                 * IpAddress v6.
                 * @member {particle.ctrl.IIpv6Address|null|undefined} v6
                 * @memberof particle.ctrl.IpAddress
                 * @instance
                 */
                IpAddress.prototype.v6 = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * IpAddress address.
                 * @member {"v4"|"v6"|undefined} address
                 * @memberof particle.ctrl.IpAddress
                 * @instance
                 */
                Object.defineProperty(IpAddress.prototype, "address", {
                    get: $util.oneOfGetter($oneOfFields = ["v4", "v6"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new IpAddress instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.IpAddress
                 * @static
                 * @param {particle.ctrl.IIpAddress=} [properties] Properties to set
                 * @returns {particle.ctrl.IpAddress} IpAddress instance
                 */
                IpAddress.create = function create(properties) {
                    return new IpAddress(properties);
                };
    
                /**
                 * Encodes the specified IpAddress message. Does not implicitly {@link particle.ctrl.IpAddress.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.IpAddress
                 * @static
                 * @param {particle.ctrl.IIpAddress} message IpAddress message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IpAddress.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.v4 != null && Object.hasOwnProperty.call(message, "v4"))
                        $root.particle.ctrl.Ipv4Address.encode(message.v4, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.v6 != null && Object.hasOwnProperty.call(message, "v6"))
                        $root.particle.ctrl.Ipv6Address.encode(message.v6, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an IpAddress message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.IpAddress
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.IpAddress} IpAddress
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IpAddress.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IpAddress();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.v4 = $root.particle.ctrl.Ipv4Address.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.v6 = $root.particle.ctrl.Ipv6Address.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return IpAddress;
            })();
    
            ctrl.IPAddress = (function() {
    
                /**
                 * Properties of a IPAddress.
                 * @memberof particle.ctrl
                 * @interface IIPAddress
                 * @property {particle.ctrl.IPAddress.Protocol|null} [protocol] IPAddress protocol
                 * @property {Uint8Array|null} [address] IPAddress address
                 */
    
                /**
                 * Constructs a new IPAddress.
                 * @memberof particle.ctrl
                 * @classdesc Represents a IPAddress.
                 * @implements IIPAddress
                 * @constructor
                 * @param {particle.ctrl.IIPAddress=} [properties] Properties to set
                 */
                function IPAddress(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * IPAddress protocol.
                 * @member {particle.ctrl.IPAddress.Protocol} protocol
                 * @memberof particle.ctrl.IPAddress
                 * @instance
                 */
                IPAddress.prototype.protocol = 0;
    
                /**
                 * IPAddress address.
                 * @member {Uint8Array} address
                 * @memberof particle.ctrl.IPAddress
                 * @instance
                 */
                IPAddress.prototype.address = $util.newBuffer([]);
    
                /**
                 * Creates a new IPAddress instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.IPAddress
                 * @static
                 * @param {particle.ctrl.IIPAddress=} [properties] Properties to set
                 * @returns {particle.ctrl.IPAddress} IPAddress instance
                 */
                IPAddress.create = function create(properties) {
                    return new IPAddress(properties);
                };
    
                /**
                 * Encodes the specified IPAddress message. Does not implicitly {@link particle.ctrl.IPAddress.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.IPAddress
                 * @static
                 * @param {particle.ctrl.IIPAddress} message IPAddress message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IPAddress.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.address);
                    return writer;
                };
    
                /**
                 * Decodes a IPAddress message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.IPAddress
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.IPAddress} IPAddress
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IPAddress.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IPAddress();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.protocol = reader.int32();
                            break;
                        case 2:
                            message.address = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Protocol enum.
                 * @name particle.ctrl.IPAddress.Protocol
                 * @enum {number}
                 * @property {number} NONE=0 NONE value
                 * @property {number} IPv4=1 IPv4 value
                 * @property {number} IPv6=2 IPv6 value
                 */
                IPAddress.Protocol = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NONE"] = 0;
                    values[valuesById[1] = "IPv4"] = 1;
                    values[valuesById[2] = "IPv6"] = 2;
                    return values;
                })();
    
                return IPAddress;
            })();
    
            /**
             * SecurityKeyType enum.
             * @name particle.ctrl.SecurityKeyType
             * @enum {number}
             * @property {number} INVALID_SECURITY_KEY=0 INVALID_SECURITY_KEY value
             * @property {number} TCP_DEVICE_PRIVATE_KEY=1 TCP_DEVICE_PRIVATE_KEY value
             * @property {number} TCP_DEVICE_PUBLIC_KEY=2 TCP_DEVICE_PUBLIC_KEY value
             * @property {number} TCP_SERVER_PUBLIC_KEY=3 TCP_SERVER_PUBLIC_KEY value
             * @property {number} UDP_DEVICE_PRIVATE_KEY=4 UDP_DEVICE_PRIVATE_KEY value
             * @property {number} UDP_DEVICE_PUBLIC_KEY=5 UDP_DEVICE_PUBLIC_KEY value
             * @property {number} UDP_SERVER_PUBLIC_KEY=6 UDP_SERVER_PUBLIC_KEY value
             */
            ctrl.SecurityKeyType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INVALID_SECURITY_KEY"] = 0;
                values[valuesById[1] = "TCP_DEVICE_PRIVATE_KEY"] = 1;
                values[valuesById[2] = "TCP_DEVICE_PUBLIC_KEY"] = 2;
                values[valuesById[3] = "TCP_SERVER_PUBLIC_KEY"] = 3;
                values[valuesById[4] = "UDP_DEVICE_PRIVATE_KEY"] = 4;
                values[valuesById[5] = "UDP_DEVICE_PUBLIC_KEY"] = 5;
                values[valuesById[6] = "UDP_SERVER_PUBLIC_KEY"] = 6;
                return values;
            })();
    
            /**
             * ServerProtocolType enum.
             * @name particle.ctrl.ServerProtocolType
             * @enum {number}
             * @property {number} INVALID_PROTOCOL=0 INVALID_PROTOCOL value
             * @property {number} TCP_PROTOCOL=1 TCP_PROTOCOL value
             * @property {number} UDP_PROTOCOL=2 UDP_PROTOCOL value
             */
            ctrl.ServerProtocolType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INVALID_PROTOCOL"] = 0;
                values[valuesById[1] = "TCP_PROTOCOL"] = 1;
                values[valuesById[2] = "UDP_PROTOCOL"] = 2;
                return values;
            })();
    
            /**
             * DeviceMode enum.
             * @name particle.ctrl.DeviceMode
             * @enum {number}
             * @property {number} NORMAL_MODE=0 NORMAL_MODE value
             * @property {number} LISTENING_MODE=1 LISTENING_MODE value
             */
            ctrl.DeviceMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NORMAL_MODE"] = 0;
                values[valuesById[1] = "LISTENING_MODE"] = 1;
                return values;
            })();
    
            /**
             * SystemCapabilityFlag enum.
             * @name particle.ctrl.SystemCapabilityFlag
             * @enum {number}
             * @property {number} NO_SYSTEM_CAPABILITY_FLAGS=0 NO_SYSTEM_CAPABILITY_FLAGS value
             * @property {number} COMPRESSED_OTA=1 COMPRESSED_OTA value
             */
            ctrl.SystemCapabilityFlag = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NO_SYSTEM_CAPABILITY_FLAGS"] = 0;
                values[valuesById[1] = "COMPRESSED_OTA"] = 1;
                return values;
            })();
    
            /**
             * Feature enum.
             * @name particle.ctrl.Feature
             * @enum {number}
             * @property {number} INVALID_FEATURE=0 INVALID_FEATURE value
             * @property {number} ETHERNET_DETECTION=1 ETHERNET_DETECTION value
             */
            ctrl.Feature = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INVALID_FEATURE"] = 0;
                values[valuesById[1] = "ETHERNET_DETECTION"] = 1;
                return values;
            })();
    
            ctrl.GetDeviceIdRequest = (function() {
    
                /**
                 * Properties of a GetDeviceIdRequest.
                 * @memberof particle.ctrl
                 * @interface IGetDeviceIdRequest
                 */
    
                /**
                 * Constructs a new GetDeviceIdRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetDeviceIdRequest.
                 * @implements IGetDeviceIdRequest
                 * @constructor
                 * @param {particle.ctrl.IGetDeviceIdRequest=} [properties] Properties to set
                 */
                function GetDeviceIdRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new GetDeviceIdRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetDeviceIdRequest
                 * @static
                 * @param {particle.ctrl.IGetDeviceIdRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetDeviceIdRequest} GetDeviceIdRequest instance
                 */
                GetDeviceIdRequest.create = function create(properties) {
                    return new GetDeviceIdRequest(properties);
                };
    
                /**
                 * Encodes the specified GetDeviceIdRequest message. Does not implicitly {@link particle.ctrl.GetDeviceIdRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetDeviceIdRequest
                 * @static
                 * @param {particle.ctrl.IGetDeviceIdRequest} message GetDeviceIdRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetDeviceIdRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a GetDeviceIdRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetDeviceIdRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetDeviceIdRequest} GetDeviceIdRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetDeviceIdRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetDeviceIdRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetDeviceIdRequest;
            })();
    
            ctrl.GetDeviceIdReply = (function() {
    
                /**
                 * Properties of a GetDeviceIdReply.
                 * @memberof particle.ctrl
                 * @interface IGetDeviceIdReply
                 * @property {string|null} [id] GetDeviceIdReply id
                 */
    
                /**
                 * Constructs a new GetDeviceIdReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetDeviceIdReply.
                 * @implements IGetDeviceIdReply
                 * @constructor
                 * @param {particle.ctrl.IGetDeviceIdReply=} [properties] Properties to set
                 */
                function GetDeviceIdReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetDeviceIdReply id.
                 * @member {string} id
                 * @memberof particle.ctrl.GetDeviceIdReply
                 * @instance
                 */
                GetDeviceIdReply.prototype.id = "";
    
                /**
                 * Creates a new GetDeviceIdReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetDeviceIdReply
                 * @static
                 * @param {particle.ctrl.IGetDeviceIdReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetDeviceIdReply} GetDeviceIdReply instance
                 */
                GetDeviceIdReply.create = function create(properties) {
                    return new GetDeviceIdReply(properties);
                };
    
                /**
                 * Encodes the specified GetDeviceIdReply message. Does not implicitly {@link particle.ctrl.GetDeviceIdReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetDeviceIdReply
                 * @static
                 * @param {particle.ctrl.IGetDeviceIdReply} message GetDeviceIdReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetDeviceIdReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    return writer;
                };
    
                /**
                 * Decodes a GetDeviceIdReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetDeviceIdReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetDeviceIdReply} GetDeviceIdReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetDeviceIdReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetDeviceIdReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetDeviceIdReply;
            })();
    
            ctrl.GetSerialNumberRequest = (function() {
    
                /**
                 * Properties of a GetSerialNumberRequest.
                 * @memberof particle.ctrl
                 * @interface IGetSerialNumberRequest
                 */
    
                /**
                 * Constructs a new GetSerialNumberRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetSerialNumberRequest.
                 * @implements IGetSerialNumberRequest
                 * @constructor
                 * @param {particle.ctrl.IGetSerialNumberRequest=} [properties] Properties to set
                 */
                function GetSerialNumberRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new GetSerialNumberRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetSerialNumberRequest
                 * @static
                 * @param {particle.ctrl.IGetSerialNumberRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetSerialNumberRequest} GetSerialNumberRequest instance
                 */
                GetSerialNumberRequest.create = function create(properties) {
                    return new GetSerialNumberRequest(properties);
                };
    
                /**
                 * Encodes the specified GetSerialNumberRequest message. Does not implicitly {@link particle.ctrl.GetSerialNumberRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetSerialNumberRequest
                 * @static
                 * @param {particle.ctrl.IGetSerialNumberRequest} message GetSerialNumberRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetSerialNumberRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a GetSerialNumberRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetSerialNumberRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetSerialNumberRequest} GetSerialNumberRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetSerialNumberRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSerialNumberRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetSerialNumberRequest;
            })();
    
            ctrl.GetSerialNumberReply = (function() {
    
                /**
                 * Properties of a GetSerialNumberReply.
                 * @memberof particle.ctrl
                 * @interface IGetSerialNumberReply
                 * @property {string|null} [serial] GetSerialNumberReply serial
                 */
    
                /**
                 * Constructs a new GetSerialNumberReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetSerialNumberReply.
                 * @implements IGetSerialNumberReply
                 * @constructor
                 * @param {particle.ctrl.IGetSerialNumberReply=} [properties] Properties to set
                 */
                function GetSerialNumberReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetSerialNumberReply serial.
                 * @member {string} serial
                 * @memberof particle.ctrl.GetSerialNumberReply
                 * @instance
                 */
                GetSerialNumberReply.prototype.serial = "";
    
                /**
                 * Creates a new GetSerialNumberReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetSerialNumberReply
                 * @static
                 * @param {particle.ctrl.IGetSerialNumberReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetSerialNumberReply} GetSerialNumberReply instance
                 */
                GetSerialNumberReply.create = function create(properties) {
                    return new GetSerialNumberReply(properties);
                };
    
                /**
                 * Encodes the specified GetSerialNumberReply message. Does not implicitly {@link particle.ctrl.GetSerialNumberReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetSerialNumberReply
                 * @static
                 * @param {particle.ctrl.IGetSerialNumberReply} message GetSerialNumberReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetSerialNumberReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.serial != null && Object.hasOwnProperty.call(message, "serial"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.serial);
                    return writer;
                };
    
                /**
                 * Decodes a GetSerialNumberReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetSerialNumberReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetSerialNumberReply} GetSerialNumberReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetSerialNumberReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSerialNumberReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.serial = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetSerialNumberReply;
            })();
    
            ctrl.GetSystemVersionRequest = (function() {
    
                /**
                 * Properties of a GetSystemVersionRequest.
                 * @memberof particle.ctrl
                 * @interface IGetSystemVersionRequest
                 */
    
                /**
                 * Constructs a new GetSystemVersionRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetSystemVersionRequest.
                 * @implements IGetSystemVersionRequest
                 * @constructor
                 * @param {particle.ctrl.IGetSystemVersionRequest=} [properties] Properties to set
                 */
                function GetSystemVersionRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new GetSystemVersionRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetSystemVersionRequest
                 * @static
                 * @param {particle.ctrl.IGetSystemVersionRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetSystemVersionRequest} GetSystemVersionRequest instance
                 */
                GetSystemVersionRequest.create = function create(properties) {
                    return new GetSystemVersionRequest(properties);
                };
    
                /**
                 * Encodes the specified GetSystemVersionRequest message. Does not implicitly {@link particle.ctrl.GetSystemVersionRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetSystemVersionRequest
                 * @static
                 * @param {particle.ctrl.IGetSystemVersionRequest} message GetSystemVersionRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetSystemVersionRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a GetSystemVersionRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetSystemVersionRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetSystemVersionRequest} GetSystemVersionRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetSystemVersionRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSystemVersionRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetSystemVersionRequest;
            })();
    
            ctrl.GetSystemVersionReply = (function() {
    
                /**
                 * Properties of a GetSystemVersionReply.
                 * @memberof particle.ctrl
                 * @interface IGetSystemVersionReply
                 * @property {string|null} [version] GetSystemVersionReply version
                 */
    
                /**
                 * Constructs a new GetSystemVersionReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetSystemVersionReply.
                 * @implements IGetSystemVersionReply
                 * @constructor
                 * @param {particle.ctrl.IGetSystemVersionReply=} [properties] Properties to set
                 */
                function GetSystemVersionReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetSystemVersionReply version.
                 * @member {string} version
                 * @memberof particle.ctrl.GetSystemVersionReply
                 * @instance
                 */
                GetSystemVersionReply.prototype.version = "";
    
                /**
                 * Creates a new GetSystemVersionReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetSystemVersionReply
                 * @static
                 * @param {particle.ctrl.IGetSystemVersionReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetSystemVersionReply} GetSystemVersionReply instance
                 */
                GetSystemVersionReply.create = function create(properties) {
                    return new GetSystemVersionReply(properties);
                };
    
                /**
                 * Encodes the specified GetSystemVersionReply message. Does not implicitly {@link particle.ctrl.GetSystemVersionReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetSystemVersionReply
                 * @static
                 * @param {particle.ctrl.IGetSystemVersionReply} message GetSystemVersionReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetSystemVersionReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
                    return writer;
                };
    
                /**
                 * Decodes a GetSystemVersionReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetSystemVersionReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetSystemVersionReply} GetSystemVersionReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetSystemVersionReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSystemVersionReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.version = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetSystemVersionReply;
            })();
    
            ctrl.GetNcpFirmwareVersionRequest = (function() {
    
                /**
                 * Properties of a GetNcpFirmwareVersionRequest.
                 * @memberof particle.ctrl
                 * @interface IGetNcpFirmwareVersionRequest
                 */
    
                /**
                 * Constructs a new GetNcpFirmwareVersionRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetNcpFirmwareVersionRequest.
                 * @implements IGetNcpFirmwareVersionRequest
                 * @constructor
                 * @param {particle.ctrl.IGetNcpFirmwareVersionRequest=} [properties] Properties to set
                 */
                function GetNcpFirmwareVersionRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new GetNcpFirmwareVersionRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetNcpFirmwareVersionRequest
                 * @static
                 * @param {particle.ctrl.IGetNcpFirmwareVersionRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetNcpFirmwareVersionRequest} GetNcpFirmwareVersionRequest instance
                 */
                GetNcpFirmwareVersionRequest.create = function create(properties) {
                    return new GetNcpFirmwareVersionRequest(properties);
                };
    
                /**
                 * Encodes the specified GetNcpFirmwareVersionRequest message. Does not implicitly {@link particle.ctrl.GetNcpFirmwareVersionRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetNcpFirmwareVersionRequest
                 * @static
                 * @param {particle.ctrl.IGetNcpFirmwareVersionRequest} message GetNcpFirmwareVersionRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetNcpFirmwareVersionRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a GetNcpFirmwareVersionRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetNcpFirmwareVersionRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetNcpFirmwareVersionRequest} GetNcpFirmwareVersionRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetNcpFirmwareVersionRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetNcpFirmwareVersionRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetNcpFirmwareVersionRequest;
            })();
    
            ctrl.GetNcpFirmwareVersionReply = (function() {
    
                /**
                 * Properties of a GetNcpFirmwareVersionReply.
                 * @memberof particle.ctrl
                 * @interface IGetNcpFirmwareVersionReply
                 * @property {string|null} [version] GetNcpFirmwareVersionReply version
                 * @property {number|null} [moduleVersion] GetNcpFirmwareVersionReply moduleVersion
                 */
    
                /**
                 * Constructs a new GetNcpFirmwareVersionReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetNcpFirmwareVersionReply.
                 * @implements IGetNcpFirmwareVersionReply
                 * @constructor
                 * @param {particle.ctrl.IGetNcpFirmwareVersionReply=} [properties] Properties to set
                 */
                function GetNcpFirmwareVersionReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetNcpFirmwareVersionReply version.
                 * @member {string} version
                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply
                 * @instance
                 */
                GetNcpFirmwareVersionReply.prototype.version = "";
    
                /**
                 * GetNcpFirmwareVersionReply moduleVersion.
                 * @member {number} moduleVersion
                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply
                 * @instance
                 */
                GetNcpFirmwareVersionReply.prototype.moduleVersion = 0;
    
                /**
                 * Creates a new GetNcpFirmwareVersionReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply
                 * @static
                 * @param {particle.ctrl.IGetNcpFirmwareVersionReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetNcpFirmwareVersionReply} GetNcpFirmwareVersionReply instance
                 */
                GetNcpFirmwareVersionReply.create = function create(properties) {
                    return new GetNcpFirmwareVersionReply(properties);
                };
    
                /**
                 * Encodes the specified GetNcpFirmwareVersionReply message. Does not implicitly {@link particle.ctrl.GetNcpFirmwareVersionReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply
                 * @static
                 * @param {particle.ctrl.IGetNcpFirmwareVersionReply} message GetNcpFirmwareVersionReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetNcpFirmwareVersionReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
                    if (message.moduleVersion != null && Object.hasOwnProperty.call(message, "moduleVersion"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.moduleVersion);
                    return writer;
                };
    
                /**
                 * Decodes a GetNcpFirmwareVersionReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetNcpFirmwareVersionReply} GetNcpFirmwareVersionReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetNcpFirmwareVersionReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetNcpFirmwareVersionReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.version = reader.string();
                            break;
                        case 2:
                            message.moduleVersion = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetNcpFirmwareVersionReply;
            })();
    
            ctrl.GetSystemCapabilitiesRequest = (function() {
    
                /**
                 * Properties of a GetSystemCapabilitiesRequest.
                 * @memberof particle.ctrl
                 * @interface IGetSystemCapabilitiesRequest
                 */
    
                /**
                 * Constructs a new GetSystemCapabilitiesRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetSystemCapabilitiesRequest.
                 * @implements IGetSystemCapabilitiesRequest
                 * @constructor
                 * @param {particle.ctrl.IGetSystemCapabilitiesRequest=} [properties] Properties to set
                 */
                function GetSystemCapabilitiesRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new GetSystemCapabilitiesRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetSystemCapabilitiesRequest
                 * @static
                 * @param {particle.ctrl.IGetSystemCapabilitiesRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetSystemCapabilitiesRequest} GetSystemCapabilitiesRequest instance
                 */
                GetSystemCapabilitiesRequest.create = function create(properties) {
                    return new GetSystemCapabilitiesRequest(properties);
                };
    
                /**
                 * Encodes the specified GetSystemCapabilitiesRequest message. Does not implicitly {@link particle.ctrl.GetSystemCapabilitiesRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetSystemCapabilitiesRequest
                 * @static
                 * @param {particle.ctrl.IGetSystemCapabilitiesRequest} message GetSystemCapabilitiesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetSystemCapabilitiesRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a GetSystemCapabilitiesRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetSystemCapabilitiesRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetSystemCapabilitiesRequest} GetSystemCapabilitiesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetSystemCapabilitiesRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSystemCapabilitiesRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetSystemCapabilitiesRequest;
            })();
    
            ctrl.GetSystemCapabilitiesReply = (function() {
    
                /**
                 * Properties of a GetSystemCapabilitiesReply.
                 * @memberof particle.ctrl
                 * @interface IGetSystemCapabilitiesReply
                 * @property {number|null} [flags] GetSystemCapabilitiesReply flags
                 */
    
                /**
                 * Constructs a new GetSystemCapabilitiesReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetSystemCapabilitiesReply.
                 * @implements IGetSystemCapabilitiesReply
                 * @constructor
                 * @param {particle.ctrl.IGetSystemCapabilitiesReply=} [properties] Properties to set
                 */
                function GetSystemCapabilitiesReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetSystemCapabilitiesReply flags.
                 * @member {number} flags
                 * @memberof particle.ctrl.GetSystemCapabilitiesReply
                 * @instance
                 */
                GetSystemCapabilitiesReply.prototype.flags = 0;
    
                /**
                 * Creates a new GetSystemCapabilitiesReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetSystemCapabilitiesReply
                 * @static
                 * @param {particle.ctrl.IGetSystemCapabilitiesReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetSystemCapabilitiesReply} GetSystemCapabilitiesReply instance
                 */
                GetSystemCapabilitiesReply.create = function create(properties) {
                    return new GetSystemCapabilitiesReply(properties);
                };
    
                /**
                 * Encodes the specified GetSystemCapabilitiesReply message. Does not implicitly {@link particle.ctrl.GetSystemCapabilitiesReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetSystemCapabilitiesReply
                 * @static
                 * @param {particle.ctrl.IGetSystemCapabilitiesReply} message GetSystemCapabilitiesReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetSystemCapabilitiesReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                        writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.flags);
                    return writer;
                };
    
                /**
                 * Decodes a GetSystemCapabilitiesReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetSystemCapabilitiesReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetSystemCapabilitiesReply} GetSystemCapabilitiesReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetSystemCapabilitiesReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSystemCapabilitiesReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.flags = reader.fixed32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetSystemCapabilitiesReply;
            })();
    
            ctrl.SetClaimCodeRequest = (function() {
    
                /**
                 * Properties of a SetClaimCodeRequest.
                 * @memberof particle.ctrl
                 * @interface ISetClaimCodeRequest
                 * @property {string|null} [code] SetClaimCodeRequest code
                 */
    
                /**
                 * Constructs a new SetClaimCodeRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetClaimCodeRequest.
                 * @implements ISetClaimCodeRequest
                 * @constructor
                 * @param {particle.ctrl.ISetClaimCodeRequest=} [properties] Properties to set
                 */
                function SetClaimCodeRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SetClaimCodeRequest code.
                 * @member {string} code
                 * @memberof particle.ctrl.SetClaimCodeRequest
                 * @instance
                 */
                SetClaimCodeRequest.prototype.code = "";
    
                /**
                 * Creates a new SetClaimCodeRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetClaimCodeRequest
                 * @static
                 * @param {particle.ctrl.ISetClaimCodeRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.SetClaimCodeRequest} SetClaimCodeRequest instance
                 */
                SetClaimCodeRequest.create = function create(properties) {
                    return new SetClaimCodeRequest(properties);
                };
    
                /**
                 * Encodes the specified SetClaimCodeRequest message. Does not implicitly {@link particle.ctrl.SetClaimCodeRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetClaimCodeRequest
                 * @static
                 * @param {particle.ctrl.ISetClaimCodeRequest} message SetClaimCodeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetClaimCodeRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
                    return writer;
                };
    
                /**
                 * Decodes a SetClaimCodeRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetClaimCodeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetClaimCodeRequest} SetClaimCodeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetClaimCodeRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetClaimCodeRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.code = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetClaimCodeRequest;
            })();
    
            ctrl.SetClaimCodeReply = (function() {
    
                /**
                 * Properties of a SetClaimCodeReply.
                 * @memberof particle.ctrl
                 * @interface ISetClaimCodeReply
                 */
    
                /**
                 * Constructs a new SetClaimCodeReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetClaimCodeReply.
                 * @implements ISetClaimCodeReply
                 * @constructor
                 * @param {particle.ctrl.ISetClaimCodeReply=} [properties] Properties to set
                 */
                function SetClaimCodeReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SetClaimCodeReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetClaimCodeReply
                 * @static
                 * @param {particle.ctrl.ISetClaimCodeReply=} [properties] Properties to set
                 * @returns {particle.ctrl.SetClaimCodeReply} SetClaimCodeReply instance
                 */
                SetClaimCodeReply.create = function create(properties) {
                    return new SetClaimCodeReply(properties);
                };
    
                /**
                 * Encodes the specified SetClaimCodeReply message. Does not implicitly {@link particle.ctrl.SetClaimCodeReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetClaimCodeReply
                 * @static
                 * @param {particle.ctrl.ISetClaimCodeReply} message SetClaimCodeReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetClaimCodeReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a SetClaimCodeReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetClaimCodeReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetClaimCodeReply} SetClaimCodeReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetClaimCodeReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetClaimCodeReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetClaimCodeReply;
            })();
    
            ctrl.IsClaimedRequest = (function() {
    
                /**
                 * Properties of an IsClaimedRequest.
                 * @memberof particle.ctrl
                 * @interface IIsClaimedRequest
                 */
    
                /**
                 * Constructs a new IsClaimedRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents an IsClaimedRequest.
                 * @implements IIsClaimedRequest
                 * @constructor
                 * @param {particle.ctrl.IIsClaimedRequest=} [properties] Properties to set
                 */
                function IsClaimedRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new IsClaimedRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.IsClaimedRequest
                 * @static
                 * @param {particle.ctrl.IIsClaimedRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.IsClaimedRequest} IsClaimedRequest instance
                 */
                IsClaimedRequest.create = function create(properties) {
                    return new IsClaimedRequest(properties);
                };
    
                /**
                 * Encodes the specified IsClaimedRequest message. Does not implicitly {@link particle.ctrl.IsClaimedRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.IsClaimedRequest
                 * @static
                 * @param {particle.ctrl.IIsClaimedRequest} message IsClaimedRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IsClaimedRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes an IsClaimedRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.IsClaimedRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.IsClaimedRequest} IsClaimedRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IsClaimedRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IsClaimedRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return IsClaimedRequest;
            })();
    
            ctrl.IsClaimedReply = (function() {
    
                /**
                 * Properties of an IsClaimedReply.
                 * @memberof particle.ctrl
                 * @interface IIsClaimedReply
                 * @property {boolean|null} [claimed] IsClaimedReply claimed
                 */
    
                /**
                 * Constructs a new IsClaimedReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents an IsClaimedReply.
                 * @implements IIsClaimedReply
                 * @constructor
                 * @param {particle.ctrl.IIsClaimedReply=} [properties] Properties to set
                 */
                function IsClaimedReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * IsClaimedReply claimed.
                 * @member {boolean} claimed
                 * @memberof particle.ctrl.IsClaimedReply
                 * @instance
                 */
                IsClaimedReply.prototype.claimed = false;
    
                /**
                 * Creates a new IsClaimedReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.IsClaimedReply
                 * @static
                 * @param {particle.ctrl.IIsClaimedReply=} [properties] Properties to set
                 * @returns {particle.ctrl.IsClaimedReply} IsClaimedReply instance
                 */
                IsClaimedReply.create = function create(properties) {
                    return new IsClaimedReply(properties);
                };
    
                /**
                 * Encodes the specified IsClaimedReply message. Does not implicitly {@link particle.ctrl.IsClaimedReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.IsClaimedReply
                 * @static
                 * @param {particle.ctrl.IIsClaimedReply} message IsClaimedReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IsClaimedReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.claimed != null && Object.hasOwnProperty.call(message, "claimed"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.claimed);
                    return writer;
                };
    
                /**
                 * Decodes an IsClaimedReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.IsClaimedReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.IsClaimedReply} IsClaimedReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IsClaimedReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IsClaimedReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.claimed = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return IsClaimedReply;
            })();
    
            ctrl.SetSecurityKeyRequest = (function() {
    
                /**
                 * Properties of a SetSecurityKeyRequest.
                 * @memberof particle.ctrl
                 * @interface ISetSecurityKeyRequest
                 * @property {particle.ctrl.SecurityKeyType|null} [type] SetSecurityKeyRequest type
                 * @property {Uint8Array|null} [data] SetSecurityKeyRequest data
                 */
    
                /**
                 * Constructs a new SetSecurityKeyRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetSecurityKeyRequest.
                 * @implements ISetSecurityKeyRequest
                 * @constructor
                 * @param {particle.ctrl.ISetSecurityKeyRequest=} [properties] Properties to set
                 */
                function SetSecurityKeyRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SetSecurityKeyRequest type.
                 * @member {particle.ctrl.SecurityKeyType} type
                 * @memberof particle.ctrl.SetSecurityKeyRequest
                 * @instance
                 */
                SetSecurityKeyRequest.prototype.type = 0;
    
                /**
                 * SetSecurityKeyRequest data.
                 * @member {Uint8Array} data
                 * @memberof particle.ctrl.SetSecurityKeyRequest
                 * @instance
                 */
                SetSecurityKeyRequest.prototype.data = $util.newBuffer([]);
    
                /**
                 * Creates a new SetSecurityKeyRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetSecurityKeyRequest
                 * @static
                 * @param {particle.ctrl.ISetSecurityKeyRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.SetSecurityKeyRequest} SetSecurityKeyRequest instance
                 */
                SetSecurityKeyRequest.create = function create(properties) {
                    return new SetSecurityKeyRequest(properties);
                };
    
                /**
                 * Encodes the specified SetSecurityKeyRequest message. Does not implicitly {@link particle.ctrl.SetSecurityKeyRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetSecurityKeyRequest
                 * @static
                 * @param {particle.ctrl.ISetSecurityKeyRequest} message SetSecurityKeyRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetSecurityKeyRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                    return writer;
                };
    
                /**
                 * Decodes a SetSecurityKeyRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetSecurityKeyRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetSecurityKeyRequest} SetSecurityKeyRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetSecurityKeyRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetSecurityKeyRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetSecurityKeyRequest;
            })();
    
            ctrl.SetSecurityKeyReply = (function() {
    
                /**
                 * Properties of a SetSecurityKeyReply.
                 * @memberof particle.ctrl
                 * @interface ISetSecurityKeyReply
                 */
    
                /**
                 * Constructs a new SetSecurityKeyReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetSecurityKeyReply.
                 * @implements ISetSecurityKeyReply
                 * @constructor
                 * @param {particle.ctrl.ISetSecurityKeyReply=} [properties] Properties to set
                 */
                function SetSecurityKeyReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SetSecurityKeyReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetSecurityKeyReply
                 * @static
                 * @param {particle.ctrl.ISetSecurityKeyReply=} [properties] Properties to set
                 * @returns {particle.ctrl.SetSecurityKeyReply} SetSecurityKeyReply instance
                 */
                SetSecurityKeyReply.create = function create(properties) {
                    return new SetSecurityKeyReply(properties);
                };
    
                /**
                 * Encodes the specified SetSecurityKeyReply message. Does not implicitly {@link particle.ctrl.SetSecurityKeyReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetSecurityKeyReply
                 * @static
                 * @param {particle.ctrl.ISetSecurityKeyReply} message SetSecurityKeyReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetSecurityKeyReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a SetSecurityKeyReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetSecurityKeyReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetSecurityKeyReply} SetSecurityKeyReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetSecurityKeyReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetSecurityKeyReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetSecurityKeyReply;
            })();
    
            ctrl.GetSecurityKeyRequest = (function() {
    
                /**
                 * Properties of a GetSecurityKeyRequest.
                 * @memberof particle.ctrl
                 * @interface IGetSecurityKeyRequest
                 * @property {particle.ctrl.SecurityKeyType|null} [type] GetSecurityKeyRequest type
                 */
    
                /**
                 * Constructs a new GetSecurityKeyRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetSecurityKeyRequest.
                 * @implements IGetSecurityKeyRequest
                 * @constructor
                 * @param {particle.ctrl.IGetSecurityKeyRequest=} [properties] Properties to set
                 */
                function GetSecurityKeyRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetSecurityKeyRequest type.
                 * @member {particle.ctrl.SecurityKeyType} type
                 * @memberof particle.ctrl.GetSecurityKeyRequest
                 * @instance
                 */
                GetSecurityKeyRequest.prototype.type = 0;
    
                /**
                 * Creates a new GetSecurityKeyRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetSecurityKeyRequest
                 * @static
                 * @param {particle.ctrl.IGetSecurityKeyRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetSecurityKeyRequest} GetSecurityKeyRequest instance
                 */
                GetSecurityKeyRequest.create = function create(properties) {
                    return new GetSecurityKeyRequest(properties);
                };
    
                /**
                 * Encodes the specified GetSecurityKeyRequest message. Does not implicitly {@link particle.ctrl.GetSecurityKeyRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetSecurityKeyRequest
                 * @static
                 * @param {particle.ctrl.IGetSecurityKeyRequest} message GetSecurityKeyRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetSecurityKeyRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    return writer;
                };
    
                /**
                 * Decodes a GetSecurityKeyRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetSecurityKeyRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetSecurityKeyRequest} GetSecurityKeyRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetSecurityKeyRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSecurityKeyRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetSecurityKeyRequest;
            })();
    
            ctrl.GetSecurityKeyReply = (function() {
    
                /**
                 * Properties of a GetSecurityKeyReply.
                 * @memberof particle.ctrl
                 * @interface IGetSecurityKeyReply
                 * @property {Uint8Array|null} [data] GetSecurityKeyReply data
                 */
    
                /**
                 * Constructs a new GetSecurityKeyReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetSecurityKeyReply.
                 * @implements IGetSecurityKeyReply
                 * @constructor
                 * @param {particle.ctrl.IGetSecurityKeyReply=} [properties] Properties to set
                 */
                function GetSecurityKeyReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetSecurityKeyReply data.
                 * @member {Uint8Array} data
                 * @memberof particle.ctrl.GetSecurityKeyReply
                 * @instance
                 */
                GetSecurityKeyReply.prototype.data = $util.newBuffer([]);
    
                /**
                 * Creates a new GetSecurityKeyReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetSecurityKeyReply
                 * @static
                 * @param {particle.ctrl.IGetSecurityKeyReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetSecurityKeyReply} GetSecurityKeyReply instance
                 */
                GetSecurityKeyReply.create = function create(properties) {
                    return new GetSecurityKeyReply(properties);
                };
    
                /**
                 * Encodes the specified GetSecurityKeyReply message. Does not implicitly {@link particle.ctrl.GetSecurityKeyReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetSecurityKeyReply
                 * @static
                 * @param {particle.ctrl.IGetSecurityKeyReply} message GetSecurityKeyReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetSecurityKeyReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
                    return writer;
                };
    
                /**
                 * Decodes a GetSecurityKeyReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetSecurityKeyReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetSecurityKeyReply} GetSecurityKeyReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetSecurityKeyReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSecurityKeyReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetSecurityKeyReply;
            })();
    
            ctrl.SetServerAddressRequest = (function() {
    
                /**
                 * Properties of a SetServerAddressRequest.
                 * @memberof particle.ctrl
                 * @interface ISetServerAddressRequest
                 * @property {particle.ctrl.ServerProtocolType|null} [protocol] SetServerAddressRequest protocol
                 * @property {string|null} [address] SetServerAddressRequest address
                 * @property {number|null} [port] SetServerAddressRequest port
                 */
    
                /**
                 * Constructs a new SetServerAddressRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetServerAddressRequest.
                 * @implements ISetServerAddressRequest
                 * @constructor
                 * @param {particle.ctrl.ISetServerAddressRequest=} [properties] Properties to set
                 */
                function SetServerAddressRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SetServerAddressRequest protocol.
                 * @member {particle.ctrl.ServerProtocolType} protocol
                 * @memberof particle.ctrl.SetServerAddressRequest
                 * @instance
                 */
                SetServerAddressRequest.prototype.protocol = 0;
    
                /**
                 * SetServerAddressRequest address.
                 * @member {string} address
                 * @memberof particle.ctrl.SetServerAddressRequest
                 * @instance
                 */
                SetServerAddressRequest.prototype.address = "";
    
                /**
                 * SetServerAddressRequest port.
                 * @member {number} port
                 * @memberof particle.ctrl.SetServerAddressRequest
                 * @instance
                 */
                SetServerAddressRequest.prototype.port = 0;
    
                /**
                 * Creates a new SetServerAddressRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetServerAddressRequest
                 * @static
                 * @param {particle.ctrl.ISetServerAddressRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.SetServerAddressRequest} SetServerAddressRequest instance
                 */
                SetServerAddressRequest.create = function create(properties) {
                    return new SetServerAddressRequest(properties);
                };
    
                /**
                 * Encodes the specified SetServerAddressRequest message. Does not implicitly {@link particle.ctrl.SetServerAddressRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetServerAddressRequest
                 * @static
                 * @param {particle.ctrl.ISetServerAddressRequest} message SetServerAddressRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetServerAddressRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
                    if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.port);
                    return writer;
                };
    
                /**
                 * Decodes a SetServerAddressRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetServerAddressRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetServerAddressRequest} SetServerAddressRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetServerAddressRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetServerAddressRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.protocol = reader.int32();
                            break;
                        case 2:
                            message.address = reader.string();
                            break;
                        case 3:
                            message.port = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetServerAddressRequest;
            })();
    
            ctrl.SetServerAddressReply = (function() {
    
                /**
                 * Properties of a SetServerAddressReply.
                 * @memberof particle.ctrl
                 * @interface ISetServerAddressReply
                 */
    
                /**
                 * Constructs a new SetServerAddressReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetServerAddressReply.
                 * @implements ISetServerAddressReply
                 * @constructor
                 * @param {particle.ctrl.ISetServerAddressReply=} [properties] Properties to set
                 */
                function SetServerAddressReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SetServerAddressReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetServerAddressReply
                 * @static
                 * @param {particle.ctrl.ISetServerAddressReply=} [properties] Properties to set
                 * @returns {particle.ctrl.SetServerAddressReply} SetServerAddressReply instance
                 */
                SetServerAddressReply.create = function create(properties) {
                    return new SetServerAddressReply(properties);
                };
    
                /**
                 * Encodes the specified SetServerAddressReply message. Does not implicitly {@link particle.ctrl.SetServerAddressReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetServerAddressReply
                 * @static
                 * @param {particle.ctrl.ISetServerAddressReply} message SetServerAddressReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetServerAddressReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a SetServerAddressReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetServerAddressReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetServerAddressReply} SetServerAddressReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetServerAddressReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetServerAddressReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetServerAddressReply;
            })();
    
            ctrl.GetServerAddressRequest = (function() {
    
                /**
                 * Properties of a GetServerAddressRequest.
                 * @memberof particle.ctrl
                 * @interface IGetServerAddressRequest
                 * @property {particle.ctrl.ServerProtocolType|null} [protocol] GetServerAddressRequest protocol
                 */
    
                /**
                 * Constructs a new GetServerAddressRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetServerAddressRequest.
                 * @implements IGetServerAddressRequest
                 * @constructor
                 * @param {particle.ctrl.IGetServerAddressRequest=} [properties] Properties to set
                 */
                function GetServerAddressRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetServerAddressRequest protocol.
                 * @member {particle.ctrl.ServerProtocolType} protocol
                 * @memberof particle.ctrl.GetServerAddressRequest
                 * @instance
                 */
                GetServerAddressRequest.prototype.protocol = 0;
    
                /**
                 * Creates a new GetServerAddressRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetServerAddressRequest
                 * @static
                 * @param {particle.ctrl.IGetServerAddressRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetServerAddressRequest} GetServerAddressRequest instance
                 */
                GetServerAddressRequest.create = function create(properties) {
                    return new GetServerAddressRequest(properties);
                };
    
                /**
                 * Encodes the specified GetServerAddressRequest message. Does not implicitly {@link particle.ctrl.GetServerAddressRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetServerAddressRequest
                 * @static
                 * @param {particle.ctrl.IGetServerAddressRequest} message GetServerAddressRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetServerAddressRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);
                    return writer;
                };
    
                /**
                 * Decodes a GetServerAddressRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetServerAddressRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetServerAddressRequest} GetServerAddressRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetServerAddressRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetServerAddressRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.protocol = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetServerAddressRequest;
            })();
    
            ctrl.GetServerAddressReply = (function() {
    
                /**
                 * Properties of a GetServerAddressReply.
                 * @memberof particle.ctrl
                 * @interface IGetServerAddressReply
                 * @property {string|null} [address] GetServerAddressReply address
                 * @property {number|null} [port] GetServerAddressReply port
                 */
    
                /**
                 * Constructs a new GetServerAddressReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetServerAddressReply.
                 * @implements IGetServerAddressReply
                 * @constructor
                 * @param {particle.ctrl.IGetServerAddressReply=} [properties] Properties to set
                 */
                function GetServerAddressReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetServerAddressReply address.
                 * @member {string} address
                 * @memberof particle.ctrl.GetServerAddressReply
                 * @instance
                 */
                GetServerAddressReply.prototype.address = "";
    
                /**
                 * GetServerAddressReply port.
                 * @member {number} port
                 * @memberof particle.ctrl.GetServerAddressReply
                 * @instance
                 */
                GetServerAddressReply.prototype.port = 0;
    
                /**
                 * Creates a new GetServerAddressReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetServerAddressReply
                 * @static
                 * @param {particle.ctrl.IGetServerAddressReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetServerAddressReply} GetServerAddressReply instance
                 */
                GetServerAddressReply.create = function create(properties) {
                    return new GetServerAddressReply(properties);
                };
    
                /**
                 * Encodes the specified GetServerAddressReply message. Does not implicitly {@link particle.ctrl.GetServerAddressReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetServerAddressReply
                 * @static
                 * @param {particle.ctrl.IGetServerAddressReply} message GetServerAddressReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetServerAddressReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                    if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
                    return writer;
                };
    
                /**
                 * Decodes a GetServerAddressReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetServerAddressReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetServerAddressReply} GetServerAddressReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetServerAddressReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetServerAddressReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.address = reader.string();
                            break;
                        case 2:
                            message.port = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetServerAddressReply;
            })();
    
            ctrl.SetServerProtocolRequest = (function() {
    
                /**
                 * Properties of a SetServerProtocolRequest.
                 * @memberof particle.ctrl
                 * @interface ISetServerProtocolRequest
                 * @property {particle.ctrl.ServerProtocolType|null} [protocol] SetServerProtocolRequest protocol
                 */
    
                /**
                 * Constructs a new SetServerProtocolRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetServerProtocolRequest.
                 * @implements ISetServerProtocolRequest
                 * @constructor
                 * @param {particle.ctrl.ISetServerProtocolRequest=} [properties] Properties to set
                 */
                function SetServerProtocolRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SetServerProtocolRequest protocol.
                 * @member {particle.ctrl.ServerProtocolType} protocol
                 * @memberof particle.ctrl.SetServerProtocolRequest
                 * @instance
                 */
                SetServerProtocolRequest.prototype.protocol = 0;
    
                /**
                 * Creates a new SetServerProtocolRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetServerProtocolRequest
                 * @static
                 * @param {particle.ctrl.ISetServerProtocolRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.SetServerProtocolRequest} SetServerProtocolRequest instance
                 */
                SetServerProtocolRequest.create = function create(properties) {
                    return new SetServerProtocolRequest(properties);
                };
    
                /**
                 * Encodes the specified SetServerProtocolRequest message. Does not implicitly {@link particle.ctrl.SetServerProtocolRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetServerProtocolRequest
                 * @static
                 * @param {particle.ctrl.ISetServerProtocolRequest} message SetServerProtocolRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetServerProtocolRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);
                    return writer;
                };
    
                /**
                 * Decodes a SetServerProtocolRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetServerProtocolRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetServerProtocolRequest} SetServerProtocolRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetServerProtocolRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetServerProtocolRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.protocol = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetServerProtocolRequest;
            })();
    
            ctrl.SetServerProtocolReply = (function() {
    
                /**
                 * Properties of a SetServerProtocolReply.
                 * @memberof particle.ctrl
                 * @interface ISetServerProtocolReply
                 */
    
                /**
                 * Constructs a new SetServerProtocolReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetServerProtocolReply.
                 * @implements ISetServerProtocolReply
                 * @constructor
                 * @param {particle.ctrl.ISetServerProtocolReply=} [properties] Properties to set
                 */
                function SetServerProtocolReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SetServerProtocolReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetServerProtocolReply
                 * @static
                 * @param {particle.ctrl.ISetServerProtocolReply=} [properties] Properties to set
                 * @returns {particle.ctrl.SetServerProtocolReply} SetServerProtocolReply instance
                 */
                SetServerProtocolReply.create = function create(properties) {
                    return new SetServerProtocolReply(properties);
                };
    
                /**
                 * Encodes the specified SetServerProtocolReply message. Does not implicitly {@link particle.ctrl.SetServerProtocolReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetServerProtocolReply
                 * @static
                 * @param {particle.ctrl.ISetServerProtocolReply} message SetServerProtocolReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetServerProtocolReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a SetServerProtocolReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetServerProtocolReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetServerProtocolReply} SetServerProtocolReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetServerProtocolReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetServerProtocolReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetServerProtocolReply;
            })();
    
            ctrl.GetServerProtocolRequest = (function() {
    
                /**
                 * Properties of a GetServerProtocolRequest.
                 * @memberof particle.ctrl
                 * @interface IGetServerProtocolRequest
                 */
    
                /**
                 * Constructs a new GetServerProtocolRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetServerProtocolRequest.
                 * @implements IGetServerProtocolRequest
                 * @constructor
                 * @param {particle.ctrl.IGetServerProtocolRequest=} [properties] Properties to set
                 */
                function GetServerProtocolRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new GetServerProtocolRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetServerProtocolRequest
                 * @static
                 * @param {particle.ctrl.IGetServerProtocolRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetServerProtocolRequest} GetServerProtocolRequest instance
                 */
                GetServerProtocolRequest.create = function create(properties) {
                    return new GetServerProtocolRequest(properties);
                };
    
                /**
                 * Encodes the specified GetServerProtocolRequest message. Does not implicitly {@link particle.ctrl.GetServerProtocolRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetServerProtocolRequest
                 * @static
                 * @param {particle.ctrl.IGetServerProtocolRequest} message GetServerProtocolRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetServerProtocolRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a GetServerProtocolRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetServerProtocolRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetServerProtocolRequest} GetServerProtocolRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetServerProtocolRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetServerProtocolRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetServerProtocolRequest;
            })();
    
            ctrl.GetServerProtocolReply = (function() {
    
                /**
                 * Properties of a GetServerProtocolReply.
                 * @memberof particle.ctrl
                 * @interface IGetServerProtocolReply
                 * @property {particle.ctrl.ServerProtocolType|null} [protocol] GetServerProtocolReply protocol
                 */
    
                /**
                 * Constructs a new GetServerProtocolReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetServerProtocolReply.
                 * @implements IGetServerProtocolReply
                 * @constructor
                 * @param {particle.ctrl.IGetServerProtocolReply=} [properties] Properties to set
                 */
                function GetServerProtocolReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetServerProtocolReply protocol.
                 * @member {particle.ctrl.ServerProtocolType} protocol
                 * @memberof particle.ctrl.GetServerProtocolReply
                 * @instance
                 */
                GetServerProtocolReply.prototype.protocol = 0;
    
                /**
                 * Creates a new GetServerProtocolReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetServerProtocolReply
                 * @static
                 * @param {particle.ctrl.IGetServerProtocolReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetServerProtocolReply} GetServerProtocolReply instance
                 */
                GetServerProtocolReply.create = function create(properties) {
                    return new GetServerProtocolReply(properties);
                };
    
                /**
                 * Encodes the specified GetServerProtocolReply message. Does not implicitly {@link particle.ctrl.GetServerProtocolReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetServerProtocolReply
                 * @static
                 * @param {particle.ctrl.IGetServerProtocolReply} message GetServerProtocolReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetServerProtocolReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);
                    return writer;
                };
    
                /**
                 * Decodes a GetServerProtocolReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetServerProtocolReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetServerProtocolReply} GetServerProtocolReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetServerProtocolReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetServerProtocolReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.protocol = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetServerProtocolReply;
            })();
    
            ctrl.SetSoftApSsidRequest = (function() {
    
                /**
                 * Properties of a SetSoftApSsidRequest.
                 * @memberof particle.ctrl
                 * @interface ISetSoftApSsidRequest
                 * @property {string|null} [prefix] SetSoftApSsidRequest prefix
                 * @property {string|null} [suffix] SetSoftApSsidRequest suffix
                 */
    
                /**
                 * Constructs a new SetSoftApSsidRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetSoftApSsidRequest.
                 * @implements ISetSoftApSsidRequest
                 * @constructor
                 * @param {particle.ctrl.ISetSoftApSsidRequest=} [properties] Properties to set
                 */
                function SetSoftApSsidRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SetSoftApSsidRequest prefix.
                 * @member {string} prefix
                 * @memberof particle.ctrl.SetSoftApSsidRequest
                 * @instance
                 */
                SetSoftApSsidRequest.prototype.prefix = "";
    
                /**
                 * SetSoftApSsidRequest suffix.
                 * @member {string} suffix
                 * @memberof particle.ctrl.SetSoftApSsidRequest
                 * @instance
                 */
                SetSoftApSsidRequest.prototype.suffix = "";
    
                /**
                 * Creates a new SetSoftApSsidRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetSoftApSsidRequest
                 * @static
                 * @param {particle.ctrl.ISetSoftApSsidRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.SetSoftApSsidRequest} SetSoftApSsidRequest instance
                 */
                SetSoftApSsidRequest.create = function create(properties) {
                    return new SetSoftApSsidRequest(properties);
                };
    
                /**
                 * Encodes the specified SetSoftApSsidRequest message. Does not implicitly {@link particle.ctrl.SetSoftApSsidRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetSoftApSsidRequest
                 * @static
                 * @param {particle.ctrl.ISetSoftApSsidRequest} message SetSoftApSsidRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetSoftApSsidRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.prefix);
                    if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.suffix);
                    return writer;
                };
    
                /**
                 * Decodes a SetSoftApSsidRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetSoftApSsidRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetSoftApSsidRequest} SetSoftApSsidRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetSoftApSsidRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetSoftApSsidRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.prefix = reader.string();
                            break;
                        case 2:
                            message.suffix = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetSoftApSsidRequest;
            })();
    
            ctrl.SetSoftApSsidReply = (function() {
    
                /**
                 * Properties of a SetSoftApSsidReply.
                 * @memberof particle.ctrl
                 * @interface ISetSoftApSsidReply
                 */
    
                /**
                 * Constructs a new SetSoftApSsidReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetSoftApSsidReply.
                 * @implements ISetSoftApSsidReply
                 * @constructor
                 * @param {particle.ctrl.ISetSoftApSsidReply=} [properties] Properties to set
                 */
                function SetSoftApSsidReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SetSoftApSsidReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetSoftApSsidReply
                 * @static
                 * @param {particle.ctrl.ISetSoftApSsidReply=} [properties] Properties to set
                 * @returns {particle.ctrl.SetSoftApSsidReply} SetSoftApSsidReply instance
                 */
                SetSoftApSsidReply.create = function create(properties) {
                    return new SetSoftApSsidReply(properties);
                };
    
                /**
                 * Encodes the specified SetSoftApSsidReply message. Does not implicitly {@link particle.ctrl.SetSoftApSsidReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetSoftApSsidReply
                 * @static
                 * @param {particle.ctrl.ISetSoftApSsidReply} message SetSoftApSsidReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetSoftApSsidReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a SetSoftApSsidReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetSoftApSsidReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetSoftApSsidReply} SetSoftApSsidReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetSoftApSsidReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetSoftApSsidReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetSoftApSsidReply;
            })();
    
            ctrl.StartListeningModeRequest = (function() {
    
                /**
                 * Properties of a StartListeningModeRequest.
                 * @memberof particle.ctrl
                 * @interface IStartListeningModeRequest
                 */
    
                /**
                 * Constructs a new StartListeningModeRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a StartListeningModeRequest.
                 * @implements IStartListeningModeRequest
                 * @constructor
                 * @param {particle.ctrl.IStartListeningModeRequest=} [properties] Properties to set
                 */
                function StartListeningModeRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new StartListeningModeRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.StartListeningModeRequest
                 * @static
                 * @param {particle.ctrl.IStartListeningModeRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.StartListeningModeRequest} StartListeningModeRequest instance
                 */
                StartListeningModeRequest.create = function create(properties) {
                    return new StartListeningModeRequest(properties);
                };
    
                /**
                 * Encodes the specified StartListeningModeRequest message. Does not implicitly {@link particle.ctrl.StartListeningModeRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.StartListeningModeRequest
                 * @static
                 * @param {particle.ctrl.IStartListeningModeRequest} message StartListeningModeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StartListeningModeRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a StartListeningModeRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.StartListeningModeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.StartListeningModeRequest} StartListeningModeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StartListeningModeRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartListeningModeRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return StartListeningModeRequest;
            })();
    
            ctrl.StartListeningModeReply = (function() {
    
                /**
                 * Properties of a StartListeningModeReply.
                 * @memberof particle.ctrl
                 * @interface IStartListeningModeReply
                 */
    
                /**
                 * Constructs a new StartListeningModeReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a StartListeningModeReply.
                 * @implements IStartListeningModeReply
                 * @constructor
                 * @param {particle.ctrl.IStartListeningModeReply=} [properties] Properties to set
                 */
                function StartListeningModeReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new StartListeningModeReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.StartListeningModeReply
                 * @static
                 * @param {particle.ctrl.IStartListeningModeReply=} [properties] Properties to set
                 * @returns {particle.ctrl.StartListeningModeReply} StartListeningModeReply instance
                 */
                StartListeningModeReply.create = function create(properties) {
                    return new StartListeningModeReply(properties);
                };
    
                /**
                 * Encodes the specified StartListeningModeReply message. Does not implicitly {@link particle.ctrl.StartListeningModeReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.StartListeningModeReply
                 * @static
                 * @param {particle.ctrl.IStartListeningModeReply} message StartListeningModeReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StartListeningModeReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a StartListeningModeReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.StartListeningModeReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.StartListeningModeReply} StartListeningModeReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StartListeningModeReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartListeningModeReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return StartListeningModeReply;
            })();
    
            ctrl.StopListeningModeRequest = (function() {
    
                /**
                 * Properties of a StopListeningModeRequest.
                 * @memberof particle.ctrl
                 * @interface IStopListeningModeRequest
                 */
    
                /**
                 * Constructs a new StopListeningModeRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a StopListeningModeRequest.
                 * @implements IStopListeningModeRequest
                 * @constructor
                 * @param {particle.ctrl.IStopListeningModeRequest=} [properties] Properties to set
                 */
                function StopListeningModeRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new StopListeningModeRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.StopListeningModeRequest
                 * @static
                 * @param {particle.ctrl.IStopListeningModeRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.StopListeningModeRequest} StopListeningModeRequest instance
                 */
                StopListeningModeRequest.create = function create(properties) {
                    return new StopListeningModeRequest(properties);
                };
    
                /**
                 * Encodes the specified StopListeningModeRequest message. Does not implicitly {@link particle.ctrl.StopListeningModeRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.StopListeningModeRequest
                 * @static
                 * @param {particle.ctrl.IStopListeningModeRequest} message StopListeningModeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StopListeningModeRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a StopListeningModeRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.StopListeningModeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.StopListeningModeRequest} StopListeningModeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StopListeningModeRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StopListeningModeRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return StopListeningModeRequest;
            })();
    
            ctrl.StopListeningModeReply = (function() {
    
                /**
                 * Properties of a StopListeningModeReply.
                 * @memberof particle.ctrl
                 * @interface IStopListeningModeReply
                 */
    
                /**
                 * Constructs a new StopListeningModeReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a StopListeningModeReply.
                 * @implements IStopListeningModeReply
                 * @constructor
                 * @param {particle.ctrl.IStopListeningModeReply=} [properties] Properties to set
                 */
                function StopListeningModeReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new StopListeningModeReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.StopListeningModeReply
                 * @static
                 * @param {particle.ctrl.IStopListeningModeReply=} [properties] Properties to set
                 * @returns {particle.ctrl.StopListeningModeReply} StopListeningModeReply instance
                 */
                StopListeningModeReply.create = function create(properties) {
                    return new StopListeningModeReply(properties);
                };
    
                /**
                 * Encodes the specified StopListeningModeReply message. Does not implicitly {@link particle.ctrl.StopListeningModeReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.StopListeningModeReply
                 * @static
                 * @param {particle.ctrl.IStopListeningModeReply} message StopListeningModeReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StopListeningModeReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a StopListeningModeReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.StopListeningModeReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.StopListeningModeReply} StopListeningModeReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StopListeningModeReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StopListeningModeReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return StopListeningModeReply;
            })();
    
            ctrl.GetDeviceModeRequest = (function() {
    
                /**
                 * Properties of a GetDeviceModeRequest.
                 * @memberof particle.ctrl
                 * @interface IGetDeviceModeRequest
                 */
    
                /**
                 * Constructs a new GetDeviceModeRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetDeviceModeRequest.
                 * @implements IGetDeviceModeRequest
                 * @constructor
                 * @param {particle.ctrl.IGetDeviceModeRequest=} [properties] Properties to set
                 */
                function GetDeviceModeRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new GetDeviceModeRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetDeviceModeRequest
                 * @static
                 * @param {particle.ctrl.IGetDeviceModeRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetDeviceModeRequest} GetDeviceModeRequest instance
                 */
                GetDeviceModeRequest.create = function create(properties) {
                    return new GetDeviceModeRequest(properties);
                };
    
                /**
                 * Encodes the specified GetDeviceModeRequest message. Does not implicitly {@link particle.ctrl.GetDeviceModeRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetDeviceModeRequest
                 * @static
                 * @param {particle.ctrl.IGetDeviceModeRequest} message GetDeviceModeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetDeviceModeRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a GetDeviceModeRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetDeviceModeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetDeviceModeRequest} GetDeviceModeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetDeviceModeRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetDeviceModeRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetDeviceModeRequest;
            })();
    
            ctrl.GetDeviceModeReply = (function() {
    
                /**
                 * Properties of a GetDeviceModeReply.
                 * @memberof particle.ctrl
                 * @interface IGetDeviceModeReply
                 * @property {particle.ctrl.DeviceMode|null} [mode] GetDeviceModeReply mode
                 */
    
                /**
                 * Constructs a new GetDeviceModeReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetDeviceModeReply.
                 * @implements IGetDeviceModeReply
                 * @constructor
                 * @param {particle.ctrl.IGetDeviceModeReply=} [properties] Properties to set
                 */
                function GetDeviceModeReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetDeviceModeReply mode.
                 * @member {particle.ctrl.DeviceMode} mode
                 * @memberof particle.ctrl.GetDeviceModeReply
                 * @instance
                 */
                GetDeviceModeReply.prototype.mode = 0;
    
                /**
                 * Creates a new GetDeviceModeReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetDeviceModeReply
                 * @static
                 * @param {particle.ctrl.IGetDeviceModeReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetDeviceModeReply} GetDeviceModeReply instance
                 */
                GetDeviceModeReply.create = function create(properties) {
                    return new GetDeviceModeReply(properties);
                };
    
                /**
                 * Encodes the specified GetDeviceModeReply message. Does not implicitly {@link particle.ctrl.GetDeviceModeReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetDeviceModeReply
                 * @static
                 * @param {particle.ctrl.IGetDeviceModeReply} message GetDeviceModeReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetDeviceModeReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                    return writer;
                };
    
                /**
                 * Decodes a GetDeviceModeReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetDeviceModeReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetDeviceModeReply} GetDeviceModeReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetDeviceModeReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetDeviceModeReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetDeviceModeReply;
            })();
    
            ctrl.SetDeviceSetupDoneRequest = (function() {
    
                /**
                 * Properties of a SetDeviceSetupDoneRequest.
                 * @memberof particle.ctrl
                 * @interface ISetDeviceSetupDoneRequest
                 * @property {boolean|null} [done] SetDeviceSetupDoneRequest done
                 */
    
                /**
                 * Constructs a new SetDeviceSetupDoneRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetDeviceSetupDoneRequest.
                 * @implements ISetDeviceSetupDoneRequest
                 * @constructor
                 * @param {particle.ctrl.ISetDeviceSetupDoneRequest=} [properties] Properties to set
                 */
                function SetDeviceSetupDoneRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SetDeviceSetupDoneRequest done.
                 * @member {boolean} done
                 * @memberof particle.ctrl.SetDeviceSetupDoneRequest
                 * @instance
                 */
                SetDeviceSetupDoneRequest.prototype.done = false;
    
                /**
                 * Creates a new SetDeviceSetupDoneRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetDeviceSetupDoneRequest
                 * @static
                 * @param {particle.ctrl.ISetDeviceSetupDoneRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.SetDeviceSetupDoneRequest} SetDeviceSetupDoneRequest instance
                 */
                SetDeviceSetupDoneRequest.create = function create(properties) {
                    return new SetDeviceSetupDoneRequest(properties);
                };
    
                /**
                 * Encodes the specified SetDeviceSetupDoneRequest message. Does not implicitly {@link particle.ctrl.SetDeviceSetupDoneRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetDeviceSetupDoneRequest
                 * @static
                 * @param {particle.ctrl.ISetDeviceSetupDoneRequest} message SetDeviceSetupDoneRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetDeviceSetupDoneRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.done != null && Object.hasOwnProperty.call(message, "done"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.done);
                    return writer;
                };
    
                /**
                 * Decodes a SetDeviceSetupDoneRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetDeviceSetupDoneRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetDeviceSetupDoneRequest} SetDeviceSetupDoneRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetDeviceSetupDoneRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetDeviceSetupDoneRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.done = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetDeviceSetupDoneRequest;
            })();
    
            ctrl.SetDeviceSetupDoneReply = (function() {
    
                /**
                 * Properties of a SetDeviceSetupDoneReply.
                 * @memberof particle.ctrl
                 * @interface ISetDeviceSetupDoneReply
                 */
    
                /**
                 * Constructs a new SetDeviceSetupDoneReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetDeviceSetupDoneReply.
                 * @implements ISetDeviceSetupDoneReply
                 * @constructor
                 * @param {particle.ctrl.ISetDeviceSetupDoneReply=} [properties] Properties to set
                 */
                function SetDeviceSetupDoneReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SetDeviceSetupDoneReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetDeviceSetupDoneReply
                 * @static
                 * @param {particle.ctrl.ISetDeviceSetupDoneReply=} [properties] Properties to set
                 * @returns {particle.ctrl.SetDeviceSetupDoneReply} SetDeviceSetupDoneReply instance
                 */
                SetDeviceSetupDoneReply.create = function create(properties) {
                    return new SetDeviceSetupDoneReply(properties);
                };
    
                /**
                 * Encodes the specified SetDeviceSetupDoneReply message. Does not implicitly {@link particle.ctrl.SetDeviceSetupDoneReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetDeviceSetupDoneReply
                 * @static
                 * @param {particle.ctrl.ISetDeviceSetupDoneReply} message SetDeviceSetupDoneReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetDeviceSetupDoneReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a SetDeviceSetupDoneReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetDeviceSetupDoneReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetDeviceSetupDoneReply} SetDeviceSetupDoneReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetDeviceSetupDoneReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetDeviceSetupDoneReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetDeviceSetupDoneReply;
            })();
    
            ctrl.IsDeviceSetupDoneRequest = (function() {
    
                /**
                 * Properties of an IsDeviceSetupDoneRequest.
                 * @memberof particle.ctrl
                 * @interface IIsDeviceSetupDoneRequest
                 */
    
                /**
                 * Constructs a new IsDeviceSetupDoneRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents an IsDeviceSetupDoneRequest.
                 * @implements IIsDeviceSetupDoneRequest
                 * @constructor
                 * @param {particle.ctrl.IIsDeviceSetupDoneRequest=} [properties] Properties to set
                 */
                function IsDeviceSetupDoneRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new IsDeviceSetupDoneRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.IsDeviceSetupDoneRequest
                 * @static
                 * @param {particle.ctrl.IIsDeviceSetupDoneRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.IsDeviceSetupDoneRequest} IsDeviceSetupDoneRequest instance
                 */
                IsDeviceSetupDoneRequest.create = function create(properties) {
                    return new IsDeviceSetupDoneRequest(properties);
                };
    
                /**
                 * Encodes the specified IsDeviceSetupDoneRequest message. Does not implicitly {@link particle.ctrl.IsDeviceSetupDoneRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.IsDeviceSetupDoneRequest
                 * @static
                 * @param {particle.ctrl.IIsDeviceSetupDoneRequest} message IsDeviceSetupDoneRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IsDeviceSetupDoneRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes an IsDeviceSetupDoneRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.IsDeviceSetupDoneRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.IsDeviceSetupDoneRequest} IsDeviceSetupDoneRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IsDeviceSetupDoneRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IsDeviceSetupDoneRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return IsDeviceSetupDoneRequest;
            })();
    
            ctrl.IsDeviceSetupDoneReply = (function() {
    
                /**
                 * Properties of an IsDeviceSetupDoneReply.
                 * @memberof particle.ctrl
                 * @interface IIsDeviceSetupDoneReply
                 * @property {boolean|null} [done] IsDeviceSetupDoneReply done
                 */
    
                /**
                 * Constructs a new IsDeviceSetupDoneReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents an IsDeviceSetupDoneReply.
                 * @implements IIsDeviceSetupDoneReply
                 * @constructor
                 * @param {particle.ctrl.IIsDeviceSetupDoneReply=} [properties] Properties to set
                 */
                function IsDeviceSetupDoneReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * IsDeviceSetupDoneReply done.
                 * @member {boolean} done
                 * @memberof particle.ctrl.IsDeviceSetupDoneReply
                 * @instance
                 */
                IsDeviceSetupDoneReply.prototype.done = false;
    
                /**
                 * Creates a new IsDeviceSetupDoneReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.IsDeviceSetupDoneReply
                 * @static
                 * @param {particle.ctrl.IIsDeviceSetupDoneReply=} [properties] Properties to set
                 * @returns {particle.ctrl.IsDeviceSetupDoneReply} IsDeviceSetupDoneReply instance
                 */
                IsDeviceSetupDoneReply.create = function create(properties) {
                    return new IsDeviceSetupDoneReply(properties);
                };
    
                /**
                 * Encodes the specified IsDeviceSetupDoneReply message. Does not implicitly {@link particle.ctrl.IsDeviceSetupDoneReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.IsDeviceSetupDoneReply
                 * @static
                 * @param {particle.ctrl.IIsDeviceSetupDoneReply} message IsDeviceSetupDoneReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IsDeviceSetupDoneReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.done != null && Object.hasOwnProperty.call(message, "done"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.done);
                    return writer;
                };
    
                /**
                 * Decodes an IsDeviceSetupDoneReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.IsDeviceSetupDoneReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.IsDeviceSetupDoneReply} IsDeviceSetupDoneReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IsDeviceSetupDoneReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IsDeviceSetupDoneReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.done = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return IsDeviceSetupDoneReply;
            })();
    
            ctrl.SetStartupModeRequest = (function() {
    
                /**
                 * Properties of a SetStartupModeRequest.
                 * @memberof particle.ctrl
                 * @interface ISetStartupModeRequest
                 * @property {particle.ctrl.DeviceMode|null} [mode] SetStartupModeRequest mode
                 */
    
                /**
                 * Constructs a new SetStartupModeRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetStartupModeRequest.
                 * @implements ISetStartupModeRequest
                 * @constructor
                 * @param {particle.ctrl.ISetStartupModeRequest=} [properties] Properties to set
                 */
                function SetStartupModeRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SetStartupModeRequest mode.
                 * @member {particle.ctrl.DeviceMode} mode
                 * @memberof particle.ctrl.SetStartupModeRequest
                 * @instance
                 */
                SetStartupModeRequest.prototype.mode = 0;
    
                /**
                 * Creates a new SetStartupModeRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetStartupModeRequest
                 * @static
                 * @param {particle.ctrl.ISetStartupModeRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.SetStartupModeRequest} SetStartupModeRequest instance
                 */
                SetStartupModeRequest.create = function create(properties) {
                    return new SetStartupModeRequest(properties);
                };
    
                /**
                 * Encodes the specified SetStartupModeRequest message. Does not implicitly {@link particle.ctrl.SetStartupModeRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetStartupModeRequest
                 * @static
                 * @param {particle.ctrl.ISetStartupModeRequest} message SetStartupModeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetStartupModeRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                    return writer;
                };
    
                /**
                 * Decodes a SetStartupModeRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetStartupModeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetStartupModeRequest} SetStartupModeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetStartupModeRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetStartupModeRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetStartupModeRequest;
            })();
    
            ctrl.SetStartupModeReply = (function() {
    
                /**
                 * Properties of a SetStartupModeReply.
                 * @memberof particle.ctrl
                 * @interface ISetStartupModeReply
                 */
    
                /**
                 * Constructs a new SetStartupModeReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetStartupModeReply.
                 * @implements ISetStartupModeReply
                 * @constructor
                 * @param {particle.ctrl.ISetStartupModeReply=} [properties] Properties to set
                 */
                function SetStartupModeReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SetStartupModeReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetStartupModeReply
                 * @static
                 * @param {particle.ctrl.ISetStartupModeReply=} [properties] Properties to set
                 * @returns {particle.ctrl.SetStartupModeReply} SetStartupModeReply instance
                 */
                SetStartupModeReply.create = function create(properties) {
                    return new SetStartupModeReply(properties);
                };
    
                /**
                 * Encodes the specified SetStartupModeReply message. Does not implicitly {@link particle.ctrl.SetStartupModeReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetStartupModeReply
                 * @static
                 * @param {particle.ctrl.ISetStartupModeReply} message SetStartupModeReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetStartupModeReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a SetStartupModeReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetStartupModeReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetStartupModeReply} SetStartupModeReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetStartupModeReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetStartupModeReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetStartupModeReply;
            })();
    
            ctrl.SystemResetRequest = (function() {
    
                /**
                 * Properties of a SystemResetRequest.
                 * @memberof particle.ctrl
                 * @interface ISystemResetRequest
                 */
    
                /**
                 * Constructs a new SystemResetRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SystemResetRequest.
                 * @implements ISystemResetRequest
                 * @constructor
                 * @param {particle.ctrl.ISystemResetRequest=} [properties] Properties to set
                 */
                function SystemResetRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SystemResetRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SystemResetRequest
                 * @static
                 * @param {particle.ctrl.ISystemResetRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.SystemResetRequest} SystemResetRequest instance
                 */
                SystemResetRequest.create = function create(properties) {
                    return new SystemResetRequest(properties);
                };
    
                /**
                 * Encodes the specified SystemResetRequest message. Does not implicitly {@link particle.ctrl.SystemResetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SystemResetRequest
                 * @static
                 * @param {particle.ctrl.ISystemResetRequest} message SystemResetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SystemResetRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a SystemResetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SystemResetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SystemResetRequest} SystemResetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SystemResetRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SystemResetRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SystemResetRequest;
            })();
    
            ctrl.SystemResetReply = (function() {
    
                /**
                 * Properties of a SystemResetReply.
                 * @memberof particle.ctrl
                 * @interface ISystemResetReply
                 */
    
                /**
                 * Constructs a new SystemResetReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SystemResetReply.
                 * @implements ISystemResetReply
                 * @constructor
                 * @param {particle.ctrl.ISystemResetReply=} [properties] Properties to set
                 */
                function SystemResetReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SystemResetReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SystemResetReply
                 * @static
                 * @param {particle.ctrl.ISystemResetReply=} [properties] Properties to set
                 * @returns {particle.ctrl.SystemResetReply} SystemResetReply instance
                 */
                SystemResetReply.create = function create(properties) {
                    return new SystemResetReply(properties);
                };
    
                /**
                 * Encodes the specified SystemResetReply message. Does not implicitly {@link particle.ctrl.SystemResetReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SystemResetReply
                 * @static
                 * @param {particle.ctrl.ISystemResetReply} message SystemResetReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SystemResetReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a SystemResetReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SystemResetReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SystemResetReply} SystemResetReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SystemResetReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SystemResetReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SystemResetReply;
            })();
    
            ctrl.SetFeatureRequest = (function() {
    
                /**
                 * Properties of a SetFeatureRequest.
                 * @memberof particle.ctrl
                 * @interface ISetFeatureRequest
                 * @property {particle.ctrl.Feature|null} [feature] SetFeatureRequest feature
                 * @property {boolean|null} [enabled] SetFeatureRequest enabled
                 */
    
                /**
                 * Constructs a new SetFeatureRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetFeatureRequest.
                 * @implements ISetFeatureRequest
                 * @constructor
                 * @param {particle.ctrl.ISetFeatureRequest=} [properties] Properties to set
                 */
                function SetFeatureRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SetFeatureRequest feature.
                 * @member {particle.ctrl.Feature} feature
                 * @memberof particle.ctrl.SetFeatureRequest
                 * @instance
                 */
                SetFeatureRequest.prototype.feature = 0;
    
                /**
                 * SetFeatureRequest enabled.
                 * @member {boolean} enabled
                 * @memberof particle.ctrl.SetFeatureRequest
                 * @instance
                 */
                SetFeatureRequest.prototype.enabled = false;
    
                /**
                 * Creates a new SetFeatureRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetFeatureRequest
                 * @static
                 * @param {particle.ctrl.ISetFeatureRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.SetFeatureRequest} SetFeatureRequest instance
                 */
                SetFeatureRequest.create = function create(properties) {
                    return new SetFeatureRequest(properties);
                };
    
                /**
                 * Encodes the specified SetFeatureRequest message. Does not implicitly {@link particle.ctrl.SetFeatureRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetFeatureRequest
                 * @static
                 * @param {particle.ctrl.ISetFeatureRequest} message SetFeatureRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetFeatureRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.feature != null && Object.hasOwnProperty.call(message, "feature"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.feature);
                    if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
                    return writer;
                };
    
                /**
                 * Decodes a SetFeatureRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetFeatureRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetFeatureRequest} SetFeatureRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetFeatureRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetFeatureRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.feature = reader.int32();
                            break;
                        case 2:
                            message.enabled = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetFeatureRequest;
            })();
    
            ctrl.SetFeatureReply = (function() {
    
                /**
                 * Properties of a SetFeatureReply.
                 * @memberof particle.ctrl
                 * @interface ISetFeatureReply
                 */
    
                /**
                 * Constructs a new SetFeatureReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetFeatureReply.
                 * @implements ISetFeatureReply
                 * @constructor
                 * @param {particle.ctrl.ISetFeatureReply=} [properties] Properties to set
                 */
                function SetFeatureReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SetFeatureReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetFeatureReply
                 * @static
                 * @param {particle.ctrl.ISetFeatureReply=} [properties] Properties to set
                 * @returns {particle.ctrl.SetFeatureReply} SetFeatureReply instance
                 */
                SetFeatureReply.create = function create(properties) {
                    return new SetFeatureReply(properties);
                };
    
                /**
                 * Encodes the specified SetFeatureReply message. Does not implicitly {@link particle.ctrl.SetFeatureReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetFeatureReply
                 * @static
                 * @param {particle.ctrl.ISetFeatureReply} message SetFeatureReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetFeatureReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a SetFeatureReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetFeatureReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetFeatureReply} SetFeatureReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetFeatureReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetFeatureReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetFeatureReply;
            })();
    
            ctrl.GetFeatureRequest = (function() {
    
                /**
                 * Properties of a GetFeatureRequest.
                 * @memberof particle.ctrl
                 * @interface IGetFeatureRequest
                 * @property {particle.ctrl.Feature|null} [feature] GetFeatureRequest feature
                 */
    
                /**
                 * Constructs a new GetFeatureRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetFeatureRequest.
                 * @implements IGetFeatureRequest
                 * @constructor
                 * @param {particle.ctrl.IGetFeatureRequest=} [properties] Properties to set
                 */
                function GetFeatureRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetFeatureRequest feature.
                 * @member {particle.ctrl.Feature} feature
                 * @memberof particle.ctrl.GetFeatureRequest
                 * @instance
                 */
                GetFeatureRequest.prototype.feature = 0;
    
                /**
                 * Creates a new GetFeatureRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetFeatureRequest
                 * @static
                 * @param {particle.ctrl.IGetFeatureRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetFeatureRequest} GetFeatureRequest instance
                 */
                GetFeatureRequest.create = function create(properties) {
                    return new GetFeatureRequest(properties);
                };
    
                /**
                 * Encodes the specified GetFeatureRequest message. Does not implicitly {@link particle.ctrl.GetFeatureRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetFeatureRequest
                 * @static
                 * @param {particle.ctrl.IGetFeatureRequest} message GetFeatureRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetFeatureRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.feature != null && Object.hasOwnProperty.call(message, "feature"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.feature);
                    return writer;
                };
    
                /**
                 * Decodes a GetFeatureRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetFeatureRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetFeatureRequest} GetFeatureRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetFeatureRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetFeatureRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.feature = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetFeatureRequest;
            })();
    
            ctrl.GetFeatureReply = (function() {
    
                /**
                 * Properties of a GetFeatureReply.
                 * @memberof particle.ctrl
                 * @interface IGetFeatureReply
                 * @property {boolean|null} [enabled] GetFeatureReply enabled
                 */
    
                /**
                 * Constructs a new GetFeatureReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetFeatureReply.
                 * @implements IGetFeatureReply
                 * @constructor
                 * @param {particle.ctrl.IGetFeatureReply=} [properties] Properties to set
                 */
                function GetFeatureReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetFeatureReply enabled.
                 * @member {boolean} enabled
                 * @memberof particle.ctrl.GetFeatureReply
                 * @instance
                 */
                GetFeatureReply.prototype.enabled = false;
    
                /**
                 * Creates a new GetFeatureReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetFeatureReply
                 * @static
                 * @param {particle.ctrl.IGetFeatureReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetFeatureReply} GetFeatureReply instance
                 */
                GetFeatureReply.create = function create(properties) {
                    return new GetFeatureReply(properties);
                };
    
                /**
                 * Encodes the specified GetFeatureReply message. Does not implicitly {@link particle.ctrl.GetFeatureReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetFeatureReply
                 * @static
                 * @param {particle.ctrl.IGetFeatureReply} message GetFeatureReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetFeatureReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                    return writer;
                };
    
                /**
                 * Decodes a GetFeatureReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetFeatureReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetFeatureReply} GetFeatureReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetFeatureReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetFeatureReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.enabled = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetFeatureReply;
            })();
    
            ctrl.StartNyanSignalRequest = (function() {
    
                /**
                 * Properties of a StartNyanSignalRequest.
                 * @memberof particle.ctrl
                 * @interface IStartNyanSignalRequest
                 */
    
                /**
                 * Constructs a new StartNyanSignalRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a StartNyanSignalRequest.
                 * @implements IStartNyanSignalRequest
                 * @constructor
                 * @param {particle.ctrl.IStartNyanSignalRequest=} [properties] Properties to set
                 */
                function StartNyanSignalRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new StartNyanSignalRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.StartNyanSignalRequest
                 * @static
                 * @param {particle.ctrl.IStartNyanSignalRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.StartNyanSignalRequest} StartNyanSignalRequest instance
                 */
                StartNyanSignalRequest.create = function create(properties) {
                    return new StartNyanSignalRequest(properties);
                };
    
                /**
                 * Encodes the specified StartNyanSignalRequest message. Does not implicitly {@link particle.ctrl.StartNyanSignalRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.StartNyanSignalRequest
                 * @static
                 * @param {particle.ctrl.IStartNyanSignalRequest} message StartNyanSignalRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StartNyanSignalRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a StartNyanSignalRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.StartNyanSignalRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.StartNyanSignalRequest} StartNyanSignalRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StartNyanSignalRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartNyanSignalRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return StartNyanSignalRequest;
            })();
    
            ctrl.StartNyanSignalReply = (function() {
    
                /**
                 * Properties of a StartNyanSignalReply.
                 * @memberof particle.ctrl
                 * @interface IStartNyanSignalReply
                 */
    
                /**
                 * Constructs a new StartNyanSignalReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a StartNyanSignalReply.
                 * @implements IStartNyanSignalReply
                 * @constructor
                 * @param {particle.ctrl.IStartNyanSignalReply=} [properties] Properties to set
                 */
                function StartNyanSignalReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new StartNyanSignalReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.StartNyanSignalReply
                 * @static
                 * @param {particle.ctrl.IStartNyanSignalReply=} [properties] Properties to set
                 * @returns {particle.ctrl.StartNyanSignalReply} StartNyanSignalReply instance
                 */
                StartNyanSignalReply.create = function create(properties) {
                    return new StartNyanSignalReply(properties);
                };
    
                /**
                 * Encodes the specified StartNyanSignalReply message. Does not implicitly {@link particle.ctrl.StartNyanSignalReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.StartNyanSignalReply
                 * @static
                 * @param {particle.ctrl.IStartNyanSignalReply} message StartNyanSignalReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StartNyanSignalReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a StartNyanSignalReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.StartNyanSignalReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.StartNyanSignalReply} StartNyanSignalReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StartNyanSignalReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartNyanSignalReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return StartNyanSignalReply;
            })();
    
            ctrl.StopNyanSignalRequest = (function() {
    
                /**
                 * Properties of a StopNyanSignalRequest.
                 * @memberof particle.ctrl
                 * @interface IStopNyanSignalRequest
                 */
    
                /**
                 * Constructs a new StopNyanSignalRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a StopNyanSignalRequest.
                 * @implements IStopNyanSignalRequest
                 * @constructor
                 * @param {particle.ctrl.IStopNyanSignalRequest=} [properties] Properties to set
                 */
                function StopNyanSignalRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new StopNyanSignalRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.StopNyanSignalRequest
                 * @static
                 * @param {particle.ctrl.IStopNyanSignalRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.StopNyanSignalRequest} StopNyanSignalRequest instance
                 */
                StopNyanSignalRequest.create = function create(properties) {
                    return new StopNyanSignalRequest(properties);
                };
    
                /**
                 * Encodes the specified StopNyanSignalRequest message. Does not implicitly {@link particle.ctrl.StopNyanSignalRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.StopNyanSignalRequest
                 * @static
                 * @param {particle.ctrl.IStopNyanSignalRequest} message StopNyanSignalRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StopNyanSignalRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a StopNyanSignalRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.StopNyanSignalRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.StopNyanSignalRequest} StopNyanSignalRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StopNyanSignalRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StopNyanSignalRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return StopNyanSignalRequest;
            })();
    
            ctrl.StopNyanSignalReply = (function() {
    
                /**
                 * Properties of a StopNyanSignalReply.
                 * @memberof particle.ctrl
                 * @interface IStopNyanSignalReply
                 */
    
                /**
                 * Constructs a new StopNyanSignalReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a StopNyanSignalReply.
                 * @implements IStopNyanSignalReply
                 * @constructor
                 * @param {particle.ctrl.IStopNyanSignalReply=} [properties] Properties to set
                 */
                function StopNyanSignalReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new StopNyanSignalReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.StopNyanSignalReply
                 * @static
                 * @param {particle.ctrl.IStopNyanSignalReply=} [properties] Properties to set
                 * @returns {particle.ctrl.StopNyanSignalReply} StopNyanSignalReply instance
                 */
                StopNyanSignalReply.create = function create(properties) {
                    return new StopNyanSignalReply(properties);
                };
    
                /**
                 * Encodes the specified StopNyanSignalReply message. Does not implicitly {@link particle.ctrl.StopNyanSignalReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.StopNyanSignalReply
                 * @static
                 * @param {particle.ctrl.IStopNyanSignalReply} message StopNyanSignalReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StopNyanSignalReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a StopNyanSignalReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.StopNyanSignalReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.StopNyanSignalReply} StopNyanSignalReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StopNyanSignalReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StopNyanSignalReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return StopNyanSignalReply;
            })();
    
            ctrl.logging = (function() {
    
                /**
                 * Namespace logging.
                 * @memberof particle.ctrl
                 * @namespace
                 */
                var logging = {};
    
                /**
                 * Logging levels.
                 * @name particle.ctrl.logging.LogLevel
                 * @enum {number}
                 * @property {number} INVALID_LOG_LEVEL=0 INVALID_LOG_LEVEL value
                 * @property {number} ALL=1 ALL value
                 * @property {number} TRACE=1 TRACE value
                 * @property {number} INFO=30 INFO value
                 * @property {number} WARN=40 WARN value
                 * @property {number} ERROR=50 ERROR value
                 * @property {number} NONE=70 NONE value
                 */
                logging.LogLevel = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INVALID_LOG_LEVEL"] = 0;
                    values[valuesById[1] = "ALL"] = 1;
                    values["TRACE"] = 1;
                    values[valuesById[30] = "INFO"] = 30;
                    values[valuesById[40] = "WARN"] = 40;
                    values[valuesById[50] = "ERROR"] = 50;
                    values[valuesById[70] = "NONE"] = 70;
                    return values;
                })();
    
                /**
                 * Log handler types.
                 * @name particle.ctrl.logging.LogHandlerType
                 * @enum {number}
                 * @property {number} INVALID_LOG_HANDLER_TYPE=0 INVALID_LOG_HANDLER_TYPE value
                 * @property {number} DEFAULT_STREAM_HANDLER=1 DEFAULT_STREAM_HANDLER value
                 * @property {number} JSON_STREAM_HANDLER=2 JSON_STREAM_HANDLER value
                 */
                logging.LogHandlerType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INVALID_LOG_HANDLER_TYPE"] = 0;
                    values[valuesById[1] = "DEFAULT_STREAM_HANDLER"] = 1;
                    values[valuesById[2] = "JSON_STREAM_HANDLER"] = 2;
                    return values;
                })();
    
                /**
                 * Stream types.
                 * @name particle.ctrl.logging.StreamType
                 * @enum {number}
                 * @property {number} INVALID_STREAM_TYPE=0 INVALID_STREAM_TYPE value
                 * @property {number} USB_SERIAL_STREAM=1 USB_SERIAL_STREAM value
                 * @property {number} HW_SERIAL_STREAM=2 HW_SERIAL_STREAM value
                 */
                logging.StreamType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INVALID_STREAM_TYPE"] = 0;
                    values[valuesById[1] = "USB_SERIAL_STREAM"] = 1;
                    values[valuesById[2] = "HW_SERIAL_STREAM"] = 2;
                    return values;
                })();
    
                logging.LogFilter = (function() {
    
                    /**
                     * Properties of a LogFilter.
                     * @memberof particle.ctrl.logging
                     * @interface ILogFilter
                     * @property {string|null} [category] LogFilter category
                     * @property {particle.ctrl.logging.LogLevel|null} [level] LogFilter level
                     */
    
                    /**
                     * Constructs a new LogFilter.
                     * @memberof particle.ctrl.logging
                     * @classdesc Category filter.
                     * @implements ILogFilter
                     * @constructor
                     * @param {particle.ctrl.logging.ILogFilter=} [properties] Properties to set
                     */
                    function LogFilter(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * LogFilter category.
                     * @member {string} category
                     * @memberof particle.ctrl.logging.LogFilter
                     * @instance
                     */
                    LogFilter.prototype.category = "";
    
                    /**
                     * LogFilter level.
                     * @member {particle.ctrl.logging.LogLevel} level
                     * @memberof particle.ctrl.logging.LogFilter
                     * @instance
                     */
                    LogFilter.prototype.level = 0;
    
                    /**
                     * Creates a new LogFilter instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.logging.LogFilter
                     * @static
                     * @param {particle.ctrl.logging.ILogFilter=} [properties] Properties to set
                     * @returns {particle.ctrl.logging.LogFilter} LogFilter instance
                     */
                    LogFilter.create = function create(properties) {
                        return new LogFilter(properties);
                    };
    
                    /**
                     * Encodes the specified LogFilter message. Does not implicitly {@link particle.ctrl.logging.LogFilter.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.logging.LogFilter
                     * @static
                     * @param {particle.ctrl.logging.ILogFilter} message LogFilter message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LogFilter.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.category);
                        if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
                        return writer;
                    };
    
                    /**
                     * Decodes a LogFilter message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.logging.LogFilter
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.logging.LogFilter} LogFilter
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LogFilter.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.LogFilter();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.category = reader.string();
                                break;
                            case 2:
                                message.level = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return LogFilter;
                })();
    
                logging.SerialStreamParams = (function() {
    
                    /**
                     * Properties of a SerialStreamParams.
                     * @memberof particle.ctrl.logging
                     * @interface ISerialStreamParams
                     * @property {number|null} [index] SerialStreamParams index
                     * @property {number|null} [baudRate] SerialStreamParams baudRate
                     */
    
                    /**
                     * Constructs a new SerialStreamParams.
                     * @memberof particle.ctrl.logging
                     * @classdesc Serial stream parameters.
                     * @implements ISerialStreamParams
                     * @constructor
                     * @param {particle.ctrl.logging.ISerialStreamParams=} [properties] Properties to set
                     */
                    function SerialStreamParams(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SerialStreamParams index.
                     * @member {number} index
                     * @memberof particle.ctrl.logging.SerialStreamParams
                     * @instance
                     */
                    SerialStreamParams.prototype.index = 0;
    
                    /**
                     * SerialStreamParams baudRate.
                     * @member {number} baudRate
                     * @memberof particle.ctrl.logging.SerialStreamParams
                     * @instance
                     */
                    SerialStreamParams.prototype.baudRate = 0;
    
                    /**
                     * Creates a new SerialStreamParams instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.logging.SerialStreamParams
                     * @static
                     * @param {particle.ctrl.logging.ISerialStreamParams=} [properties] Properties to set
                     * @returns {particle.ctrl.logging.SerialStreamParams} SerialStreamParams instance
                     */
                    SerialStreamParams.create = function create(properties) {
                        return new SerialStreamParams(properties);
                    };
    
                    /**
                     * Encodes the specified SerialStreamParams message. Does not implicitly {@link particle.ctrl.logging.SerialStreamParams.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.logging.SerialStreamParams
                     * @static
                     * @param {particle.ctrl.logging.ISerialStreamParams} message SerialStreamParams message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SerialStreamParams.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                        if (message.baudRate != null && Object.hasOwnProperty.call(message, "baudRate"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.baudRate);
                        return writer;
                    };
    
                    /**
                     * Decodes a SerialStreamParams message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.logging.SerialStreamParams
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.logging.SerialStreamParams} SerialStreamParams
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SerialStreamParams.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.SerialStreamParams();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.index = reader.uint32();
                                break;
                            case 2:
                                message.baudRate = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return SerialStreamParams;
                })();
    
                logging.AddLogHandlerRequest = (function() {
    
                    /**
                     * Properties of an AddLogHandlerRequest.
                     * @memberof particle.ctrl.logging
                     * @interface IAddLogHandlerRequest
                     * @property {string|null} [id] AddLogHandlerRequest id
                     * @property {particle.ctrl.logging.LogHandlerType|null} [handlerType] AddLogHandlerRequest handlerType
                     * @property {particle.ctrl.logging.LogLevel|null} [level] AddLogHandlerRequest level
                     * @property {Array.<particle.ctrl.logging.ILogFilter>|null} [filters] AddLogHandlerRequest filters
                     * @property {particle.ctrl.logging.StreamType|null} [streamType] AddLogHandlerRequest streamType
                     * @property {particle.ctrl.logging.ISerialStreamParams|null} [serial] AddLogHandlerRequest serial
                     */
    
                    /**
                     * Constructs a new AddLogHandlerRequest.
                     * @memberof particle.ctrl.logging
                     * @classdesc Add a log handler.
                     * @implements IAddLogHandlerRequest
                     * @constructor
                     * @param {particle.ctrl.logging.IAddLogHandlerRequest=} [properties] Properties to set
                     */
                    function AddLogHandlerRequest(properties) {
                        this.filters = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * AddLogHandlerRequest id.
                     * @member {string} id
                     * @memberof particle.ctrl.logging.AddLogHandlerRequest
                     * @instance
                     */
                    AddLogHandlerRequest.prototype.id = "";
    
                    /**
                     * AddLogHandlerRequest handlerType.
                     * @member {particle.ctrl.logging.LogHandlerType} handlerType
                     * @memberof particle.ctrl.logging.AddLogHandlerRequest
                     * @instance
                     */
                    AddLogHandlerRequest.prototype.handlerType = 0;
    
                    /**
                     * AddLogHandlerRequest level.
                     * @member {particle.ctrl.logging.LogLevel} level
                     * @memberof particle.ctrl.logging.AddLogHandlerRequest
                     * @instance
                     */
                    AddLogHandlerRequest.prototype.level = 0;
    
                    /**
                     * AddLogHandlerRequest filters.
                     * @member {Array.<particle.ctrl.logging.ILogFilter>} filters
                     * @memberof particle.ctrl.logging.AddLogHandlerRequest
                     * @instance
                     */
                    AddLogHandlerRequest.prototype.filters = $util.emptyArray;
    
                    /**
                     * AddLogHandlerRequest streamType.
                     * @member {particle.ctrl.logging.StreamType} streamType
                     * @memberof particle.ctrl.logging.AddLogHandlerRequest
                     * @instance
                     */
                    AddLogHandlerRequest.prototype.streamType = 0;
    
                    /**
                     * AddLogHandlerRequest serial.
                     * @member {particle.ctrl.logging.ISerialStreamParams|null|undefined} serial
                     * @memberof particle.ctrl.logging.AddLogHandlerRequest
                     * @instance
                     */
                    AddLogHandlerRequest.prototype.serial = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * AddLogHandlerRequest streamParams.
                     * @member {"serial"|undefined} streamParams
                     * @memberof particle.ctrl.logging.AddLogHandlerRequest
                     * @instance
                     */
                    Object.defineProperty(AddLogHandlerRequest.prototype, "streamParams", {
                        get: $util.oneOfGetter($oneOfFields = ["serial"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new AddLogHandlerRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.logging.AddLogHandlerRequest
                     * @static
                     * @param {particle.ctrl.logging.IAddLogHandlerRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.logging.AddLogHandlerRequest} AddLogHandlerRequest instance
                     */
                    AddLogHandlerRequest.create = function create(properties) {
                        return new AddLogHandlerRequest(properties);
                    };
    
                    /**
                     * Encodes the specified AddLogHandlerRequest message. Does not implicitly {@link particle.ctrl.logging.AddLogHandlerRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.logging.AddLogHandlerRequest
                     * @static
                     * @param {particle.ctrl.logging.IAddLogHandlerRequest} message AddLogHandlerRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AddLogHandlerRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.handlerType != null && Object.hasOwnProperty.call(message, "handlerType"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.handlerType);
                        if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);
                        if (message.filters != null && message.filters.length)
                            for (var i = 0; i < message.filters.length; ++i)
                                $root.particle.ctrl.logging.LogFilter.encode(message.filters[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.streamType != null && Object.hasOwnProperty.call(message, "streamType"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.streamType);
                        if (message.serial != null && Object.hasOwnProperty.call(message, "serial"))
                            $root.particle.ctrl.logging.SerialStreamParams.encode(message.serial, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes an AddLogHandlerRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.logging.AddLogHandlerRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.logging.AddLogHandlerRequest} AddLogHandlerRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AddLogHandlerRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.AddLogHandlerRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                message.handlerType = reader.int32();
                                break;
                            case 3:
                                message.level = reader.int32();
                                break;
                            case 4:
                                if (!(message.filters && message.filters.length))
                                    message.filters = [];
                                message.filters.push($root.particle.ctrl.logging.LogFilter.decode(reader, reader.uint32()));
                                break;
                            case 5:
                                message.streamType = reader.int32();
                                break;
                            case 6:
                                message.serial = $root.particle.ctrl.logging.SerialStreamParams.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return AddLogHandlerRequest;
                })();
    
                logging.AddLogHandlerReply = (function() {
    
                    /**
                     * Properties of an AddLogHandlerReply.
                     * @memberof particle.ctrl.logging
                     * @interface IAddLogHandlerReply
                     */
    
                    /**
                     * Constructs a new AddLogHandlerReply.
                     * @memberof particle.ctrl.logging
                     * @classdesc Represents an AddLogHandlerReply.
                     * @implements IAddLogHandlerReply
                     * @constructor
                     * @param {particle.ctrl.logging.IAddLogHandlerReply=} [properties] Properties to set
                     */
                    function AddLogHandlerReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new AddLogHandlerReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.logging.AddLogHandlerReply
                     * @static
                     * @param {particle.ctrl.logging.IAddLogHandlerReply=} [properties] Properties to set
                     * @returns {particle.ctrl.logging.AddLogHandlerReply} AddLogHandlerReply instance
                     */
                    AddLogHandlerReply.create = function create(properties) {
                        return new AddLogHandlerReply(properties);
                    };
    
                    /**
                     * Encodes the specified AddLogHandlerReply message. Does not implicitly {@link particle.ctrl.logging.AddLogHandlerReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.logging.AddLogHandlerReply
                     * @static
                     * @param {particle.ctrl.logging.IAddLogHandlerReply} message AddLogHandlerReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AddLogHandlerReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes an AddLogHandlerReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.logging.AddLogHandlerReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.logging.AddLogHandlerReply} AddLogHandlerReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AddLogHandlerReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.AddLogHandlerReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return AddLogHandlerReply;
                })();
    
                logging.RemoveLogHandlerRequest = (function() {
    
                    /**
                     * Properties of a RemoveLogHandlerRequest.
                     * @memberof particle.ctrl.logging
                     * @interface IRemoveLogHandlerRequest
                     * @property {string|null} [id] RemoveLogHandlerRequest id
                     */
    
                    /**
                     * Constructs a new RemoveLogHandlerRequest.
                     * @memberof particle.ctrl.logging
                     * @classdesc Remove a log handler.
                     * @implements IRemoveLogHandlerRequest
                     * @constructor
                     * @param {particle.ctrl.logging.IRemoveLogHandlerRequest=} [properties] Properties to set
                     */
                    function RemoveLogHandlerRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * RemoveLogHandlerRequest id.
                     * @member {string} id
                     * @memberof particle.ctrl.logging.RemoveLogHandlerRequest
                     * @instance
                     */
                    RemoveLogHandlerRequest.prototype.id = "";
    
                    /**
                     * Creates a new RemoveLogHandlerRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.logging.RemoveLogHandlerRequest
                     * @static
                     * @param {particle.ctrl.logging.IRemoveLogHandlerRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.logging.RemoveLogHandlerRequest} RemoveLogHandlerRequest instance
                     */
                    RemoveLogHandlerRequest.create = function create(properties) {
                        return new RemoveLogHandlerRequest(properties);
                    };
    
                    /**
                     * Encodes the specified RemoveLogHandlerRequest message. Does not implicitly {@link particle.ctrl.logging.RemoveLogHandlerRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.logging.RemoveLogHandlerRequest
                     * @static
                     * @param {particle.ctrl.logging.IRemoveLogHandlerRequest} message RemoveLogHandlerRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RemoveLogHandlerRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        return writer;
                    };
    
                    /**
                     * Decodes a RemoveLogHandlerRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.logging.RemoveLogHandlerRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.logging.RemoveLogHandlerRequest} RemoveLogHandlerRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RemoveLogHandlerRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.RemoveLogHandlerRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return RemoveLogHandlerRequest;
                })();
    
                logging.RemoveLogHandlerReply = (function() {
    
                    /**
                     * Properties of a RemoveLogHandlerReply.
                     * @memberof particle.ctrl.logging
                     * @interface IRemoveLogHandlerReply
                     */
    
                    /**
                     * Constructs a new RemoveLogHandlerReply.
                     * @memberof particle.ctrl.logging
                     * @classdesc Represents a RemoveLogHandlerReply.
                     * @implements IRemoveLogHandlerReply
                     * @constructor
                     * @param {particle.ctrl.logging.IRemoveLogHandlerReply=} [properties] Properties to set
                     */
                    function RemoveLogHandlerReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new RemoveLogHandlerReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.logging.RemoveLogHandlerReply
                     * @static
                     * @param {particle.ctrl.logging.IRemoveLogHandlerReply=} [properties] Properties to set
                     * @returns {particle.ctrl.logging.RemoveLogHandlerReply} RemoveLogHandlerReply instance
                     */
                    RemoveLogHandlerReply.create = function create(properties) {
                        return new RemoveLogHandlerReply(properties);
                    };
    
                    /**
                     * Encodes the specified RemoveLogHandlerReply message. Does not implicitly {@link particle.ctrl.logging.RemoveLogHandlerReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.logging.RemoveLogHandlerReply
                     * @static
                     * @param {particle.ctrl.logging.IRemoveLogHandlerReply} message RemoveLogHandlerReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RemoveLogHandlerReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a RemoveLogHandlerReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.logging.RemoveLogHandlerReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.logging.RemoveLogHandlerReply} RemoveLogHandlerReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RemoveLogHandlerReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.RemoveLogHandlerReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return RemoveLogHandlerReply;
                })();
    
                logging.GetLogHandlersRequest = (function() {
    
                    /**
                     * Properties of a GetLogHandlersRequest.
                     * @memberof particle.ctrl.logging
                     * @interface IGetLogHandlersRequest
                     */
    
                    /**
                     * Constructs a new GetLogHandlersRequest.
                     * @memberof particle.ctrl.logging
                     * @classdesc Get the list of active log handlers.
                     * @implements IGetLogHandlersRequest
                     * @constructor
                     * @param {particle.ctrl.logging.IGetLogHandlersRequest=} [properties] Properties to set
                     */
                    function GetLogHandlersRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new GetLogHandlersRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.logging.GetLogHandlersRequest
                     * @static
                     * @param {particle.ctrl.logging.IGetLogHandlersRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.logging.GetLogHandlersRequest} GetLogHandlersRequest instance
                     */
                    GetLogHandlersRequest.create = function create(properties) {
                        return new GetLogHandlersRequest(properties);
                    };
    
                    /**
                     * Encodes the specified GetLogHandlersRequest message. Does not implicitly {@link particle.ctrl.logging.GetLogHandlersRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.logging.GetLogHandlersRequest
                     * @static
                     * @param {particle.ctrl.logging.IGetLogHandlersRequest} message GetLogHandlersRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetLogHandlersRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a GetLogHandlersRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.logging.GetLogHandlersRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.logging.GetLogHandlersRequest} GetLogHandlersRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetLogHandlersRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.GetLogHandlersRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetLogHandlersRequest;
                })();
    
                logging.GetLogHandlersReply = (function() {
    
                    /**
                     * Properties of a GetLogHandlersReply.
                     * @memberof particle.ctrl.logging
                     * @interface IGetLogHandlersReply
                     * @property {Array.<particle.ctrl.logging.GetLogHandlersReply.IHandler>|null} [handlers] GetLogHandlersReply handlers
                     */
    
                    /**
                     * Constructs a new GetLogHandlersReply.
                     * @memberof particle.ctrl.logging
                     * @classdesc Represents a GetLogHandlersReply.
                     * @implements IGetLogHandlersReply
                     * @constructor
                     * @param {particle.ctrl.logging.IGetLogHandlersReply=} [properties] Properties to set
                     */
                    function GetLogHandlersReply(properties) {
                        this.handlers = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * GetLogHandlersReply handlers.
                     * @member {Array.<particle.ctrl.logging.GetLogHandlersReply.IHandler>} handlers
                     * @memberof particle.ctrl.logging.GetLogHandlersReply
                     * @instance
                     */
                    GetLogHandlersReply.prototype.handlers = $util.emptyArray;
    
                    /**
                     * Creates a new GetLogHandlersReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.logging.GetLogHandlersReply
                     * @static
                     * @param {particle.ctrl.logging.IGetLogHandlersReply=} [properties] Properties to set
                     * @returns {particle.ctrl.logging.GetLogHandlersReply} GetLogHandlersReply instance
                     */
                    GetLogHandlersReply.create = function create(properties) {
                        return new GetLogHandlersReply(properties);
                    };
    
                    /**
                     * Encodes the specified GetLogHandlersReply message. Does not implicitly {@link particle.ctrl.logging.GetLogHandlersReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.logging.GetLogHandlersReply
                     * @static
                     * @param {particle.ctrl.logging.IGetLogHandlersReply} message GetLogHandlersReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetLogHandlersReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.handlers != null && message.handlers.length)
                            for (var i = 0; i < message.handlers.length; ++i)
                                $root.particle.ctrl.logging.GetLogHandlersReply.Handler.encode(message.handlers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a GetLogHandlersReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.logging.GetLogHandlersReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.logging.GetLogHandlersReply} GetLogHandlersReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetLogHandlersReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.GetLogHandlersReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.handlers && message.handlers.length))
                                    message.handlers = [];
                                message.handlers.push($root.particle.ctrl.logging.GetLogHandlersReply.Handler.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    GetLogHandlersReply.Handler = (function() {
    
                        /**
                         * Properties of a Handler.
                         * @memberof particle.ctrl.logging.GetLogHandlersReply
                         * @interface IHandler
                         * @property {string|null} [id] Handler id
                         */
    
                        /**
                         * Constructs a new Handler.
                         * @memberof particle.ctrl.logging.GetLogHandlersReply
                         * @classdesc Represents a Handler.
                         * @implements IHandler
                         * @constructor
                         * @param {particle.ctrl.logging.GetLogHandlersReply.IHandler=} [properties] Properties to set
                         */
                        function Handler(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Handler id.
                         * @member {string} id
                         * @memberof particle.ctrl.logging.GetLogHandlersReply.Handler
                         * @instance
                         */
                        Handler.prototype.id = "";
    
                        /**
                         * Creates a new Handler instance using the specified properties.
                         * @function create
                         * @memberof particle.ctrl.logging.GetLogHandlersReply.Handler
                         * @static
                         * @param {particle.ctrl.logging.GetLogHandlersReply.IHandler=} [properties] Properties to set
                         * @returns {particle.ctrl.logging.GetLogHandlersReply.Handler} Handler instance
                         */
                        Handler.create = function create(properties) {
                            return new Handler(properties);
                        };
    
                        /**
                         * Encodes the specified Handler message. Does not implicitly {@link particle.ctrl.logging.GetLogHandlersReply.Handler.verify|verify} messages.
                         * @function encode
                         * @memberof particle.ctrl.logging.GetLogHandlersReply.Handler
                         * @static
                         * @param {particle.ctrl.logging.GetLogHandlersReply.IHandler} message Handler message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Handler.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                            return writer;
                        };
    
                        /**
                         * Decodes a Handler message from the specified reader or buffer.
                         * @function decode
                         * @memberof particle.ctrl.logging.GetLogHandlersReply.Handler
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {particle.ctrl.logging.GetLogHandlersReply.Handler} Handler
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Handler.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.GetLogHandlersReply.Handler();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.id = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        return Handler;
                    })();
    
                    return GetLogHandlersReply;
                })();
    
                return logging;
            })();
    
            ctrl.mesh = (function() {
    
                /**
                 * Namespace mesh.
                 * @memberof particle.ctrl
                 * @namespace
                 */
                var mesh = {};
    
                mesh.NetworkInfo = (function() {
    
                    /**
                     * Properties of a NetworkInfo.
                     * @memberof particle.ctrl.mesh
                     * @interface INetworkInfo
                     * @property {string|null} [name] NetworkInfo name
                     * @property {string|null} [extPanId] NetworkInfo extPanId
                     * @property {number|null} [panId] NetworkInfo panId
                     * @property {number|null} [channel] NetworkInfo channel
                     * @property {string|null} [networkId] NetworkInfo networkId
                     */
    
                    /**
                     * Constructs a new NetworkInfo.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a NetworkInfo.
                     * @implements INetworkInfo
                     * @constructor
                     * @param {particle.ctrl.mesh.INetworkInfo=} [properties] Properties to set
                     */
                    function NetworkInfo(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NetworkInfo name.
                     * @member {string} name
                     * @memberof particle.ctrl.mesh.NetworkInfo
                     * @instance
                     */
                    NetworkInfo.prototype.name = "";
    
                    /**
                     * NetworkInfo extPanId.
                     * @member {string} extPanId
                     * @memberof particle.ctrl.mesh.NetworkInfo
                     * @instance
                     */
                    NetworkInfo.prototype.extPanId = "";
    
                    /**
                     * NetworkInfo panId.
                     * @member {number} panId
                     * @memberof particle.ctrl.mesh.NetworkInfo
                     * @instance
                     */
                    NetworkInfo.prototype.panId = 0;
    
                    /**
                     * NetworkInfo channel.
                     * @member {number} channel
                     * @memberof particle.ctrl.mesh.NetworkInfo
                     * @instance
                     */
                    NetworkInfo.prototype.channel = 0;
    
                    /**
                     * NetworkInfo networkId.
                     * @member {string} networkId
                     * @memberof particle.ctrl.mesh.NetworkInfo
                     * @instance
                     */
                    NetworkInfo.prototype.networkId = "";
    
                    /**
                     * Creates a new NetworkInfo instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.NetworkInfo
                     * @static
                     * @param {particle.ctrl.mesh.INetworkInfo=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.NetworkInfo} NetworkInfo instance
                     */
                    NetworkInfo.create = function create(properties) {
                        return new NetworkInfo(properties);
                    };
    
                    /**
                     * Encodes the specified NetworkInfo message. Does not implicitly {@link particle.ctrl.mesh.NetworkInfo.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.NetworkInfo
                     * @static
                     * @param {particle.ctrl.mesh.INetworkInfo} message NetworkInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NetworkInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.extPanId != null && Object.hasOwnProperty.call(message, "extPanId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.extPanId);
                        if (message.panId != null && Object.hasOwnProperty.call(message, "panId"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.panId);
                        if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.channel);
                        if (message.networkId != null && Object.hasOwnProperty.call(message, "networkId"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.networkId);
                        return writer;
                    };
    
                    /**
                     * Decodes a NetworkInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.NetworkInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.NetworkInfo} NetworkInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NetworkInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.NetworkInfo();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.extPanId = reader.string();
                                break;
                            case 3:
                                message.panId = reader.uint32();
                                break;
                            case 4:
                                message.channel = reader.uint32();
                                break;
                            case 5:
                                message.networkId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return NetworkInfo;
                })();
    
                mesh.AuthRequest = (function() {
    
                    /**
                     * Properties of an AuthRequest.
                     * @memberof particle.ctrl.mesh
                     * @interface IAuthRequest
                     * @property {string|null} [password] AuthRequest password
                     */
    
                    /**
                     * Constructs a new AuthRequest.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents an AuthRequest.
                     * @implements IAuthRequest
                     * @constructor
                     * @param {particle.ctrl.mesh.IAuthRequest=} [properties] Properties to set
                     */
                    function AuthRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * AuthRequest password.
                     * @member {string} password
                     * @memberof particle.ctrl.mesh.AuthRequest
                     * @instance
                     */
                    AuthRequest.prototype.password = "";
    
                    /**
                     * Creates a new AuthRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.AuthRequest
                     * @static
                     * @param {particle.ctrl.mesh.IAuthRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.AuthRequest} AuthRequest instance
                     */
                    AuthRequest.create = function create(properties) {
                        return new AuthRequest(properties);
                    };
    
                    /**
                     * Encodes the specified AuthRequest message. Does not implicitly {@link particle.ctrl.mesh.AuthRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.AuthRequest
                     * @static
                     * @param {particle.ctrl.mesh.IAuthRequest} message AuthRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AuthRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.password);
                        return writer;
                    };
    
                    /**
                     * Decodes an AuthRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.AuthRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.AuthRequest} AuthRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AuthRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.AuthRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.password = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return AuthRequest;
                })();
    
                mesh.AuthReply = (function() {
    
                    /**
                     * Properties of an AuthReply.
                     * @memberof particle.ctrl.mesh
                     * @interface IAuthReply
                     */
    
                    /**
                     * Constructs a new AuthReply.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents an AuthReply.
                     * @implements IAuthReply
                     * @constructor
                     * @param {particle.ctrl.mesh.IAuthReply=} [properties] Properties to set
                     */
                    function AuthReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new AuthReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.AuthReply
                     * @static
                     * @param {particle.ctrl.mesh.IAuthReply=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.AuthReply} AuthReply instance
                     */
                    AuthReply.create = function create(properties) {
                        return new AuthReply(properties);
                    };
    
                    /**
                     * Encodes the specified AuthReply message. Does not implicitly {@link particle.ctrl.mesh.AuthReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.AuthReply
                     * @static
                     * @param {particle.ctrl.mesh.IAuthReply} message AuthReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AuthReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes an AuthReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.AuthReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.AuthReply} AuthReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AuthReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.AuthReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return AuthReply;
                })();
    
                mesh.CreateNetworkRequest = (function() {
    
                    /**
                     * Properties of a CreateNetworkRequest.
                     * @memberof particle.ctrl.mesh
                     * @interface ICreateNetworkRequest
                     * @property {string|null} [name] CreateNetworkRequest name
                     * @property {string|null} [password] CreateNetworkRequest password
                     * @property {number|null} [channel] CreateNetworkRequest channel
                     * @property {string|null} [networkId] CreateNetworkRequest networkId
                     */
    
                    /**
                     * Constructs a new CreateNetworkRequest.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a CreateNetworkRequest.
                     * @implements ICreateNetworkRequest
                     * @constructor
                     * @param {particle.ctrl.mesh.ICreateNetworkRequest=} [properties] Properties to set
                     */
                    function CreateNetworkRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * CreateNetworkRequest name.
                     * @member {string} name
                     * @memberof particle.ctrl.mesh.CreateNetworkRequest
                     * @instance
                     */
                    CreateNetworkRequest.prototype.name = "";
    
                    /**
                     * CreateNetworkRequest password.
                     * @member {string} password
                     * @memberof particle.ctrl.mesh.CreateNetworkRequest
                     * @instance
                     */
                    CreateNetworkRequest.prototype.password = "";
    
                    /**
                     * CreateNetworkRequest channel.
                     * @member {number} channel
                     * @memberof particle.ctrl.mesh.CreateNetworkRequest
                     * @instance
                     */
                    CreateNetworkRequest.prototype.channel = 0;
    
                    /**
                     * CreateNetworkRequest networkId.
                     * @member {string} networkId
                     * @memberof particle.ctrl.mesh.CreateNetworkRequest
                     * @instance
                     */
                    CreateNetworkRequest.prototype.networkId = "";
    
                    /**
                     * Creates a new CreateNetworkRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.CreateNetworkRequest
                     * @static
                     * @param {particle.ctrl.mesh.ICreateNetworkRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.CreateNetworkRequest} CreateNetworkRequest instance
                     */
                    CreateNetworkRequest.create = function create(properties) {
                        return new CreateNetworkRequest(properties);
                    };
    
                    /**
                     * Encodes the specified CreateNetworkRequest message. Does not implicitly {@link particle.ctrl.mesh.CreateNetworkRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.CreateNetworkRequest
                     * @static
                     * @param {particle.ctrl.mesh.ICreateNetworkRequest} message CreateNetworkRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CreateNetworkRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
                        if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.channel);
                        if (message.networkId != null && Object.hasOwnProperty.call(message, "networkId"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.networkId);
                        return writer;
                    };
    
                    /**
                     * Decodes a CreateNetworkRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.CreateNetworkRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.CreateNetworkRequest} CreateNetworkRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CreateNetworkRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.CreateNetworkRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.password = reader.string();
                                break;
                            case 3:
                                message.channel = reader.uint32();
                                break;
                            case 4:
                                message.networkId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return CreateNetworkRequest;
                })();
    
                mesh.CreateNetworkReply = (function() {
    
                    /**
                     * Properties of a CreateNetworkReply.
                     * @memberof particle.ctrl.mesh
                     * @interface ICreateNetworkReply
                     * @property {particle.ctrl.mesh.INetworkInfo|null} [network] CreateNetworkReply network
                     */
    
                    /**
                     * Constructs a new CreateNetworkReply.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a CreateNetworkReply.
                     * @implements ICreateNetworkReply
                     * @constructor
                     * @param {particle.ctrl.mesh.ICreateNetworkReply=} [properties] Properties to set
                     */
                    function CreateNetworkReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * CreateNetworkReply network.
                     * @member {particle.ctrl.mesh.INetworkInfo|null|undefined} network
                     * @memberof particle.ctrl.mesh.CreateNetworkReply
                     * @instance
                     */
                    CreateNetworkReply.prototype.network = null;
    
                    /**
                     * Creates a new CreateNetworkReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.CreateNetworkReply
                     * @static
                     * @param {particle.ctrl.mesh.ICreateNetworkReply=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.CreateNetworkReply} CreateNetworkReply instance
                     */
                    CreateNetworkReply.create = function create(properties) {
                        return new CreateNetworkReply(properties);
                    };
    
                    /**
                     * Encodes the specified CreateNetworkReply message. Does not implicitly {@link particle.ctrl.mesh.CreateNetworkReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.CreateNetworkReply
                     * @static
                     * @param {particle.ctrl.mesh.ICreateNetworkReply} message CreateNetworkReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CreateNetworkReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
                            $root.particle.ctrl.mesh.NetworkInfo.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a CreateNetworkReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.CreateNetworkReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.CreateNetworkReply} CreateNetworkReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CreateNetworkReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.CreateNetworkReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.network = $root.particle.ctrl.mesh.NetworkInfo.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return CreateNetworkReply;
                })();
    
                mesh.StartCommissionerRequest = (function() {
    
                    /**
                     * Properties of a StartCommissionerRequest.
                     * @memberof particle.ctrl.mesh
                     * @interface IStartCommissionerRequest
                     * @property {number|null} [timeout] StartCommissionerRequest timeout
                     */
    
                    /**
                     * Constructs a new StartCommissionerRequest.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a StartCommissionerRequest.
                     * @implements IStartCommissionerRequest
                     * @constructor
                     * @param {particle.ctrl.mesh.IStartCommissionerRequest=} [properties] Properties to set
                     */
                    function StartCommissionerRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * StartCommissionerRequest timeout.
                     * @member {number} timeout
                     * @memberof particle.ctrl.mesh.StartCommissionerRequest
                     * @instance
                     */
                    StartCommissionerRequest.prototype.timeout = 0;
    
                    /**
                     * Creates a new StartCommissionerRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.StartCommissionerRequest
                     * @static
                     * @param {particle.ctrl.mesh.IStartCommissionerRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.StartCommissionerRequest} StartCommissionerRequest instance
                     */
                    StartCommissionerRequest.create = function create(properties) {
                        return new StartCommissionerRequest(properties);
                    };
    
                    /**
                     * Encodes the specified StartCommissionerRequest message. Does not implicitly {@link particle.ctrl.mesh.StartCommissionerRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.StartCommissionerRequest
                     * @static
                     * @param {particle.ctrl.mesh.IStartCommissionerRequest} message StartCommissionerRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StartCommissionerRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timeout);
                        return writer;
                    };
    
                    /**
                     * Decodes a StartCommissionerRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.StartCommissionerRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.StartCommissionerRequest} StartCommissionerRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StartCommissionerRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.StartCommissionerRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.timeout = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return StartCommissionerRequest;
                })();
    
                mesh.StartCommissionerReply = (function() {
    
                    /**
                     * Properties of a StartCommissionerReply.
                     * @memberof particle.ctrl.mesh
                     * @interface IStartCommissionerReply
                     */
    
                    /**
                     * Constructs a new StartCommissionerReply.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a StartCommissionerReply.
                     * @implements IStartCommissionerReply
                     * @constructor
                     * @param {particle.ctrl.mesh.IStartCommissionerReply=} [properties] Properties to set
                     */
                    function StartCommissionerReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new StartCommissionerReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.StartCommissionerReply
                     * @static
                     * @param {particle.ctrl.mesh.IStartCommissionerReply=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.StartCommissionerReply} StartCommissionerReply instance
                     */
                    StartCommissionerReply.create = function create(properties) {
                        return new StartCommissionerReply(properties);
                    };
    
                    /**
                     * Encodes the specified StartCommissionerReply message. Does not implicitly {@link particle.ctrl.mesh.StartCommissionerReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.StartCommissionerReply
                     * @static
                     * @param {particle.ctrl.mesh.IStartCommissionerReply} message StartCommissionerReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StartCommissionerReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a StartCommissionerReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.StartCommissionerReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.StartCommissionerReply} StartCommissionerReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StartCommissionerReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.StartCommissionerReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return StartCommissionerReply;
                })();
    
                mesh.StopCommissionerRequest = (function() {
    
                    /**
                     * Properties of a StopCommissionerRequest.
                     * @memberof particle.ctrl.mesh
                     * @interface IStopCommissionerRequest
                     */
    
                    /**
                     * Constructs a new StopCommissionerRequest.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a StopCommissionerRequest.
                     * @implements IStopCommissionerRequest
                     * @constructor
                     * @param {particle.ctrl.mesh.IStopCommissionerRequest=} [properties] Properties to set
                     */
                    function StopCommissionerRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new StopCommissionerRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.StopCommissionerRequest
                     * @static
                     * @param {particle.ctrl.mesh.IStopCommissionerRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.StopCommissionerRequest} StopCommissionerRequest instance
                     */
                    StopCommissionerRequest.create = function create(properties) {
                        return new StopCommissionerRequest(properties);
                    };
    
                    /**
                     * Encodes the specified StopCommissionerRequest message. Does not implicitly {@link particle.ctrl.mesh.StopCommissionerRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.StopCommissionerRequest
                     * @static
                     * @param {particle.ctrl.mesh.IStopCommissionerRequest} message StopCommissionerRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StopCommissionerRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a StopCommissionerRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.StopCommissionerRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.StopCommissionerRequest} StopCommissionerRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StopCommissionerRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.StopCommissionerRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return StopCommissionerRequest;
                })();
    
                mesh.StopCommissionerReply = (function() {
    
                    /**
                     * Properties of a StopCommissionerReply.
                     * @memberof particle.ctrl.mesh
                     * @interface IStopCommissionerReply
                     */
    
                    /**
                     * Constructs a new StopCommissionerReply.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a StopCommissionerReply.
                     * @implements IStopCommissionerReply
                     * @constructor
                     * @param {particle.ctrl.mesh.IStopCommissionerReply=} [properties] Properties to set
                     */
                    function StopCommissionerReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new StopCommissionerReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.StopCommissionerReply
                     * @static
                     * @param {particle.ctrl.mesh.IStopCommissionerReply=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.StopCommissionerReply} StopCommissionerReply instance
                     */
                    StopCommissionerReply.create = function create(properties) {
                        return new StopCommissionerReply(properties);
                    };
    
                    /**
                     * Encodes the specified StopCommissionerReply message. Does not implicitly {@link particle.ctrl.mesh.StopCommissionerReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.StopCommissionerReply
                     * @static
                     * @param {particle.ctrl.mesh.IStopCommissionerReply} message StopCommissionerReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StopCommissionerReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a StopCommissionerReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.StopCommissionerReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.StopCommissionerReply} StopCommissionerReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StopCommissionerReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.StopCommissionerReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return StopCommissionerReply;
                })();
    
                mesh.PrepareJoinerRequest = (function() {
    
                    /**
                     * Properties of a PrepareJoinerRequest.
                     * @memberof particle.ctrl.mesh
                     * @interface IPrepareJoinerRequest
                     * @property {particle.ctrl.mesh.INetworkInfo|null} [network] PrepareJoinerRequest network
                     */
    
                    /**
                     * Constructs a new PrepareJoinerRequest.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a PrepareJoinerRequest.
                     * @implements IPrepareJoinerRequest
                     * @constructor
                     * @param {particle.ctrl.mesh.IPrepareJoinerRequest=} [properties] Properties to set
                     */
                    function PrepareJoinerRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * PrepareJoinerRequest network.
                     * @member {particle.ctrl.mesh.INetworkInfo|null|undefined} network
                     * @memberof particle.ctrl.mesh.PrepareJoinerRequest
                     * @instance
                     */
                    PrepareJoinerRequest.prototype.network = null;
    
                    /**
                     * Creates a new PrepareJoinerRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.PrepareJoinerRequest
                     * @static
                     * @param {particle.ctrl.mesh.IPrepareJoinerRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.PrepareJoinerRequest} PrepareJoinerRequest instance
                     */
                    PrepareJoinerRequest.create = function create(properties) {
                        return new PrepareJoinerRequest(properties);
                    };
    
                    /**
                     * Encodes the specified PrepareJoinerRequest message. Does not implicitly {@link particle.ctrl.mesh.PrepareJoinerRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.PrepareJoinerRequest
                     * @static
                     * @param {particle.ctrl.mesh.IPrepareJoinerRequest} message PrepareJoinerRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PrepareJoinerRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
                            $root.particle.ctrl.mesh.NetworkInfo.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a PrepareJoinerRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.PrepareJoinerRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.PrepareJoinerRequest} PrepareJoinerRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PrepareJoinerRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.PrepareJoinerRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.network = $root.particle.ctrl.mesh.NetworkInfo.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return PrepareJoinerRequest;
                })();
    
                mesh.PrepareJoinerReply = (function() {
    
                    /**
                     * Properties of a PrepareJoinerReply.
                     * @memberof particle.ctrl.mesh
                     * @interface IPrepareJoinerReply
                     * @property {string|null} [eui64] PrepareJoinerReply eui64
                     * @property {string|null} [password] PrepareJoinerReply password
                     */
    
                    /**
                     * Constructs a new PrepareJoinerReply.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a PrepareJoinerReply.
                     * @implements IPrepareJoinerReply
                     * @constructor
                     * @param {particle.ctrl.mesh.IPrepareJoinerReply=} [properties] Properties to set
                     */
                    function PrepareJoinerReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * PrepareJoinerReply eui64.
                     * @member {string} eui64
                     * @memberof particle.ctrl.mesh.PrepareJoinerReply
                     * @instance
                     */
                    PrepareJoinerReply.prototype.eui64 = "";
    
                    /**
                     * PrepareJoinerReply password.
                     * @member {string} password
                     * @memberof particle.ctrl.mesh.PrepareJoinerReply
                     * @instance
                     */
                    PrepareJoinerReply.prototype.password = "";
    
                    /**
                     * Creates a new PrepareJoinerReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.PrepareJoinerReply
                     * @static
                     * @param {particle.ctrl.mesh.IPrepareJoinerReply=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.PrepareJoinerReply} PrepareJoinerReply instance
                     */
                    PrepareJoinerReply.create = function create(properties) {
                        return new PrepareJoinerReply(properties);
                    };
    
                    /**
                     * Encodes the specified PrepareJoinerReply message. Does not implicitly {@link particle.ctrl.mesh.PrepareJoinerReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.PrepareJoinerReply
                     * @static
                     * @param {particle.ctrl.mesh.IPrepareJoinerReply} message PrepareJoinerReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PrepareJoinerReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.eui64 != null && Object.hasOwnProperty.call(message, "eui64"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.eui64);
                        if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
                        return writer;
                    };
    
                    /**
                     * Decodes a PrepareJoinerReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.PrepareJoinerReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.PrepareJoinerReply} PrepareJoinerReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PrepareJoinerReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.PrepareJoinerReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.eui64 = reader.string();
                                break;
                            case 2:
                                message.password = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return PrepareJoinerReply;
                })();
    
                mesh.AddJoinerRequest = (function() {
    
                    /**
                     * Properties of an AddJoinerRequest.
                     * @memberof particle.ctrl.mesh
                     * @interface IAddJoinerRequest
                     * @property {string|null} [eui64] AddJoinerRequest eui64
                     * @property {string|null} [password] AddJoinerRequest password
                     * @property {number|null} [timeout] AddJoinerRequest timeout
                     */
    
                    /**
                     * Constructs a new AddJoinerRequest.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents an AddJoinerRequest.
                     * @implements IAddJoinerRequest
                     * @constructor
                     * @param {particle.ctrl.mesh.IAddJoinerRequest=} [properties] Properties to set
                     */
                    function AddJoinerRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * AddJoinerRequest eui64.
                     * @member {string} eui64
                     * @memberof particle.ctrl.mesh.AddJoinerRequest
                     * @instance
                     */
                    AddJoinerRequest.prototype.eui64 = "";
    
                    /**
                     * AddJoinerRequest password.
                     * @member {string} password
                     * @memberof particle.ctrl.mesh.AddJoinerRequest
                     * @instance
                     */
                    AddJoinerRequest.prototype.password = "";
    
                    /**
                     * AddJoinerRequest timeout.
                     * @member {number} timeout
                     * @memberof particle.ctrl.mesh.AddJoinerRequest
                     * @instance
                     */
                    AddJoinerRequest.prototype.timeout = 0;
    
                    /**
                     * Creates a new AddJoinerRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.AddJoinerRequest
                     * @static
                     * @param {particle.ctrl.mesh.IAddJoinerRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.AddJoinerRequest} AddJoinerRequest instance
                     */
                    AddJoinerRequest.create = function create(properties) {
                        return new AddJoinerRequest(properties);
                    };
    
                    /**
                     * Encodes the specified AddJoinerRequest message. Does not implicitly {@link particle.ctrl.mesh.AddJoinerRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.AddJoinerRequest
                     * @static
                     * @param {particle.ctrl.mesh.IAddJoinerRequest} message AddJoinerRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AddJoinerRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.eui64 != null && Object.hasOwnProperty.call(message, "eui64"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.eui64);
                        if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
                        if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timeout);
                        return writer;
                    };
    
                    /**
                     * Decodes an AddJoinerRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.AddJoinerRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.AddJoinerRequest} AddJoinerRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AddJoinerRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.AddJoinerRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.eui64 = reader.string();
                                break;
                            case 2:
                                message.password = reader.string();
                                break;
                            case 3:
                                message.timeout = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return AddJoinerRequest;
                })();
    
                mesh.AddJoinerReply = (function() {
    
                    /**
                     * Properties of an AddJoinerReply.
                     * @memberof particle.ctrl.mesh
                     * @interface IAddJoinerReply
                     */
    
                    /**
                     * Constructs a new AddJoinerReply.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents an AddJoinerReply.
                     * @implements IAddJoinerReply
                     * @constructor
                     * @param {particle.ctrl.mesh.IAddJoinerReply=} [properties] Properties to set
                     */
                    function AddJoinerReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new AddJoinerReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.AddJoinerReply
                     * @static
                     * @param {particle.ctrl.mesh.IAddJoinerReply=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.AddJoinerReply} AddJoinerReply instance
                     */
                    AddJoinerReply.create = function create(properties) {
                        return new AddJoinerReply(properties);
                    };
    
                    /**
                     * Encodes the specified AddJoinerReply message. Does not implicitly {@link particle.ctrl.mesh.AddJoinerReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.AddJoinerReply
                     * @static
                     * @param {particle.ctrl.mesh.IAddJoinerReply} message AddJoinerReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AddJoinerReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes an AddJoinerReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.AddJoinerReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.AddJoinerReply} AddJoinerReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AddJoinerReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.AddJoinerReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return AddJoinerReply;
                })();
    
                mesh.RemoveJoinerRequest = (function() {
    
                    /**
                     * Properties of a RemoveJoinerRequest.
                     * @memberof particle.ctrl.mesh
                     * @interface IRemoveJoinerRequest
                     * @property {string|null} [eui64] RemoveJoinerRequest eui64
                     */
    
                    /**
                     * Constructs a new RemoveJoinerRequest.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a RemoveJoinerRequest.
                     * @implements IRemoveJoinerRequest
                     * @constructor
                     * @param {particle.ctrl.mesh.IRemoveJoinerRequest=} [properties] Properties to set
                     */
                    function RemoveJoinerRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * RemoveJoinerRequest eui64.
                     * @member {string} eui64
                     * @memberof particle.ctrl.mesh.RemoveJoinerRequest
                     * @instance
                     */
                    RemoveJoinerRequest.prototype.eui64 = "";
    
                    /**
                     * Creates a new RemoveJoinerRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.RemoveJoinerRequest
                     * @static
                     * @param {particle.ctrl.mesh.IRemoveJoinerRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.RemoveJoinerRequest} RemoveJoinerRequest instance
                     */
                    RemoveJoinerRequest.create = function create(properties) {
                        return new RemoveJoinerRequest(properties);
                    };
    
                    /**
                     * Encodes the specified RemoveJoinerRequest message. Does not implicitly {@link particle.ctrl.mesh.RemoveJoinerRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.RemoveJoinerRequest
                     * @static
                     * @param {particle.ctrl.mesh.IRemoveJoinerRequest} message RemoveJoinerRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RemoveJoinerRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.eui64 != null && Object.hasOwnProperty.call(message, "eui64"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.eui64);
                        return writer;
                    };
    
                    /**
                     * Decodes a RemoveJoinerRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.RemoveJoinerRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.RemoveJoinerRequest} RemoveJoinerRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RemoveJoinerRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.RemoveJoinerRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.eui64 = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return RemoveJoinerRequest;
                })();
    
                mesh.RemoveJoinerReply = (function() {
    
                    /**
                     * Properties of a RemoveJoinerReply.
                     * @memberof particle.ctrl.mesh
                     * @interface IRemoveJoinerReply
                     */
    
                    /**
                     * Constructs a new RemoveJoinerReply.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a RemoveJoinerReply.
                     * @implements IRemoveJoinerReply
                     * @constructor
                     * @param {particle.ctrl.mesh.IRemoveJoinerReply=} [properties] Properties to set
                     */
                    function RemoveJoinerReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new RemoveJoinerReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.RemoveJoinerReply
                     * @static
                     * @param {particle.ctrl.mesh.IRemoveJoinerReply=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.RemoveJoinerReply} RemoveJoinerReply instance
                     */
                    RemoveJoinerReply.create = function create(properties) {
                        return new RemoveJoinerReply(properties);
                    };
    
                    /**
                     * Encodes the specified RemoveJoinerReply message. Does not implicitly {@link particle.ctrl.mesh.RemoveJoinerReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.RemoveJoinerReply
                     * @static
                     * @param {particle.ctrl.mesh.IRemoveJoinerReply} message RemoveJoinerReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RemoveJoinerReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a RemoveJoinerReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.RemoveJoinerReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.RemoveJoinerReply} RemoveJoinerReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RemoveJoinerReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.RemoveJoinerReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return RemoveJoinerReply;
                })();
    
                mesh.JoinNetworkRequest = (function() {
    
                    /**
                     * Properties of a JoinNetworkRequest.
                     * @memberof particle.ctrl.mesh
                     * @interface IJoinNetworkRequest
                     * @property {number|null} [timeout] JoinNetworkRequest timeout
                     */
    
                    /**
                     * Constructs a new JoinNetworkRequest.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a JoinNetworkRequest.
                     * @implements IJoinNetworkRequest
                     * @constructor
                     * @param {particle.ctrl.mesh.IJoinNetworkRequest=} [properties] Properties to set
                     */
                    function JoinNetworkRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * JoinNetworkRequest timeout.
                     * @member {number} timeout
                     * @memberof particle.ctrl.mesh.JoinNetworkRequest
                     * @instance
                     */
                    JoinNetworkRequest.prototype.timeout = 0;
    
                    /**
                     * Creates a new JoinNetworkRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.JoinNetworkRequest
                     * @static
                     * @param {particle.ctrl.mesh.IJoinNetworkRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.JoinNetworkRequest} JoinNetworkRequest instance
                     */
                    JoinNetworkRequest.create = function create(properties) {
                        return new JoinNetworkRequest(properties);
                    };
    
                    /**
                     * Encodes the specified JoinNetworkRequest message. Does not implicitly {@link particle.ctrl.mesh.JoinNetworkRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.JoinNetworkRequest
                     * @static
                     * @param {particle.ctrl.mesh.IJoinNetworkRequest} message JoinNetworkRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JoinNetworkRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timeout);
                        return writer;
                    };
    
                    /**
                     * Decodes a JoinNetworkRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.JoinNetworkRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.JoinNetworkRequest} JoinNetworkRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JoinNetworkRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.JoinNetworkRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.timeout = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return JoinNetworkRequest;
                })();
    
                mesh.JoinNetworkReply = (function() {
    
                    /**
                     * Properties of a JoinNetworkReply.
                     * @memberof particle.ctrl.mesh
                     * @interface IJoinNetworkReply
                     */
    
                    /**
                     * Constructs a new JoinNetworkReply.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a JoinNetworkReply.
                     * @implements IJoinNetworkReply
                     * @constructor
                     * @param {particle.ctrl.mesh.IJoinNetworkReply=} [properties] Properties to set
                     */
                    function JoinNetworkReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new JoinNetworkReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.JoinNetworkReply
                     * @static
                     * @param {particle.ctrl.mesh.IJoinNetworkReply=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.JoinNetworkReply} JoinNetworkReply instance
                     */
                    JoinNetworkReply.create = function create(properties) {
                        return new JoinNetworkReply(properties);
                    };
    
                    /**
                     * Encodes the specified JoinNetworkReply message. Does not implicitly {@link particle.ctrl.mesh.JoinNetworkReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.JoinNetworkReply
                     * @static
                     * @param {particle.ctrl.mesh.IJoinNetworkReply} message JoinNetworkReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JoinNetworkReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a JoinNetworkReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.JoinNetworkReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.JoinNetworkReply} JoinNetworkReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JoinNetworkReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.JoinNetworkReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return JoinNetworkReply;
                })();
    
                mesh.LeaveNetworkRequest = (function() {
    
                    /**
                     * Properties of a LeaveNetworkRequest.
                     * @memberof particle.ctrl.mesh
                     * @interface ILeaveNetworkRequest
                     */
    
                    /**
                     * Constructs a new LeaveNetworkRequest.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a LeaveNetworkRequest.
                     * @implements ILeaveNetworkRequest
                     * @constructor
                     * @param {particle.ctrl.mesh.ILeaveNetworkRequest=} [properties] Properties to set
                     */
                    function LeaveNetworkRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new LeaveNetworkRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.LeaveNetworkRequest
                     * @static
                     * @param {particle.ctrl.mesh.ILeaveNetworkRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.LeaveNetworkRequest} LeaveNetworkRequest instance
                     */
                    LeaveNetworkRequest.create = function create(properties) {
                        return new LeaveNetworkRequest(properties);
                    };
    
                    /**
                     * Encodes the specified LeaveNetworkRequest message. Does not implicitly {@link particle.ctrl.mesh.LeaveNetworkRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.LeaveNetworkRequest
                     * @static
                     * @param {particle.ctrl.mesh.ILeaveNetworkRequest} message LeaveNetworkRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LeaveNetworkRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a LeaveNetworkRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.LeaveNetworkRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.LeaveNetworkRequest} LeaveNetworkRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LeaveNetworkRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.LeaveNetworkRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return LeaveNetworkRequest;
                })();
    
                mesh.LeaveNetworkReply = (function() {
    
                    /**
                     * Properties of a LeaveNetworkReply.
                     * @memberof particle.ctrl.mesh
                     * @interface ILeaveNetworkReply
                     */
    
                    /**
                     * Constructs a new LeaveNetworkReply.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a LeaveNetworkReply.
                     * @implements ILeaveNetworkReply
                     * @constructor
                     * @param {particle.ctrl.mesh.ILeaveNetworkReply=} [properties] Properties to set
                     */
                    function LeaveNetworkReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new LeaveNetworkReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.LeaveNetworkReply
                     * @static
                     * @param {particle.ctrl.mesh.ILeaveNetworkReply=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.LeaveNetworkReply} LeaveNetworkReply instance
                     */
                    LeaveNetworkReply.create = function create(properties) {
                        return new LeaveNetworkReply(properties);
                    };
    
                    /**
                     * Encodes the specified LeaveNetworkReply message. Does not implicitly {@link particle.ctrl.mesh.LeaveNetworkReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.LeaveNetworkReply
                     * @static
                     * @param {particle.ctrl.mesh.ILeaveNetworkReply} message LeaveNetworkReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LeaveNetworkReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a LeaveNetworkReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.LeaveNetworkReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.LeaveNetworkReply} LeaveNetworkReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LeaveNetworkReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.LeaveNetworkReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return LeaveNetworkReply;
                })();
    
                mesh.GetNetworkInfoRequest = (function() {
    
                    /**
                     * Properties of a GetNetworkInfoRequest.
                     * @memberof particle.ctrl.mesh
                     * @interface IGetNetworkInfoRequest
                     */
    
                    /**
                     * Constructs a new GetNetworkInfoRequest.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a GetNetworkInfoRequest.
                     * @implements IGetNetworkInfoRequest
                     * @constructor
                     * @param {particle.ctrl.mesh.IGetNetworkInfoRequest=} [properties] Properties to set
                     */
                    function GetNetworkInfoRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new GetNetworkInfoRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.GetNetworkInfoRequest
                     * @static
                     * @param {particle.ctrl.mesh.IGetNetworkInfoRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.GetNetworkInfoRequest} GetNetworkInfoRequest instance
                     */
                    GetNetworkInfoRequest.create = function create(properties) {
                        return new GetNetworkInfoRequest(properties);
                    };
    
                    /**
                     * Encodes the specified GetNetworkInfoRequest message. Does not implicitly {@link particle.ctrl.mesh.GetNetworkInfoRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.GetNetworkInfoRequest
                     * @static
                     * @param {particle.ctrl.mesh.IGetNetworkInfoRequest} message GetNetworkInfoRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetNetworkInfoRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a GetNetworkInfoRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.GetNetworkInfoRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.GetNetworkInfoRequest} GetNetworkInfoRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetNetworkInfoRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.GetNetworkInfoRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetNetworkInfoRequest;
                })();
    
                mesh.GetNetworkInfoReply = (function() {
    
                    /**
                     * Properties of a GetNetworkInfoReply.
                     * @memberof particle.ctrl.mesh
                     * @interface IGetNetworkInfoReply
                     * @property {particle.ctrl.mesh.INetworkInfo|null} [network] GetNetworkInfoReply network
                     */
    
                    /**
                     * Constructs a new GetNetworkInfoReply.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a GetNetworkInfoReply.
                     * @implements IGetNetworkInfoReply
                     * @constructor
                     * @param {particle.ctrl.mesh.IGetNetworkInfoReply=} [properties] Properties to set
                     */
                    function GetNetworkInfoReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * GetNetworkInfoReply network.
                     * @member {particle.ctrl.mesh.INetworkInfo|null|undefined} network
                     * @memberof particle.ctrl.mesh.GetNetworkInfoReply
                     * @instance
                     */
                    GetNetworkInfoReply.prototype.network = null;
    
                    /**
                     * Creates a new GetNetworkInfoReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.GetNetworkInfoReply
                     * @static
                     * @param {particle.ctrl.mesh.IGetNetworkInfoReply=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.GetNetworkInfoReply} GetNetworkInfoReply instance
                     */
                    GetNetworkInfoReply.create = function create(properties) {
                        return new GetNetworkInfoReply(properties);
                    };
    
                    /**
                     * Encodes the specified GetNetworkInfoReply message. Does not implicitly {@link particle.ctrl.mesh.GetNetworkInfoReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.GetNetworkInfoReply
                     * @static
                     * @param {particle.ctrl.mesh.IGetNetworkInfoReply} message GetNetworkInfoReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetNetworkInfoReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.network != null && Object.hasOwnProperty.call(message, "network"))
                            $root.particle.ctrl.mesh.NetworkInfo.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a GetNetworkInfoReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.GetNetworkInfoReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.GetNetworkInfoReply} GetNetworkInfoReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetNetworkInfoReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.GetNetworkInfoReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.network = $root.particle.ctrl.mesh.NetworkInfo.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetNetworkInfoReply;
                })();
    
                mesh.ScanNetworksRequest = (function() {
    
                    /**
                     * Properties of a ScanNetworksRequest.
                     * @memberof particle.ctrl.mesh
                     * @interface IScanNetworksRequest
                     * @property {number|null} [duration] ScanNetworksRequest duration
                     */
    
                    /**
                     * Constructs a new ScanNetworksRequest.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a ScanNetworksRequest.
                     * @implements IScanNetworksRequest
                     * @constructor
                     * @param {particle.ctrl.mesh.IScanNetworksRequest=} [properties] Properties to set
                     */
                    function ScanNetworksRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ScanNetworksRequest duration.
                     * @member {number} duration
                     * @memberof particle.ctrl.mesh.ScanNetworksRequest
                     * @instance
                     */
                    ScanNetworksRequest.prototype.duration = 0;
    
                    /**
                     * Creates a new ScanNetworksRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.ScanNetworksRequest
                     * @static
                     * @param {particle.ctrl.mesh.IScanNetworksRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.ScanNetworksRequest} ScanNetworksRequest instance
                     */
                    ScanNetworksRequest.create = function create(properties) {
                        return new ScanNetworksRequest(properties);
                    };
    
                    /**
                     * Encodes the specified ScanNetworksRequest message. Does not implicitly {@link particle.ctrl.mesh.ScanNetworksRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.ScanNetworksRequest
                     * @static
                     * @param {particle.ctrl.mesh.IScanNetworksRequest} message ScanNetworksRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ScanNetworksRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.duration);
                        return writer;
                    };
    
                    /**
                     * Decodes a ScanNetworksRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.ScanNetworksRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.ScanNetworksRequest} ScanNetworksRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ScanNetworksRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.ScanNetworksRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.duration = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return ScanNetworksRequest;
                })();
    
                mesh.ScanNetworksReply = (function() {
    
                    /**
                     * Properties of a ScanNetworksReply.
                     * @memberof particle.ctrl.mesh
                     * @interface IScanNetworksReply
                     * @property {Array.<particle.ctrl.mesh.INetworkInfo>|null} [networks] ScanNetworksReply networks
                     */
    
                    /**
                     * Constructs a new ScanNetworksReply.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a ScanNetworksReply.
                     * @implements IScanNetworksReply
                     * @constructor
                     * @param {particle.ctrl.mesh.IScanNetworksReply=} [properties] Properties to set
                     */
                    function ScanNetworksReply(properties) {
                        this.networks = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ScanNetworksReply networks.
                     * @member {Array.<particle.ctrl.mesh.INetworkInfo>} networks
                     * @memberof particle.ctrl.mesh.ScanNetworksReply
                     * @instance
                     */
                    ScanNetworksReply.prototype.networks = $util.emptyArray;
    
                    /**
                     * Creates a new ScanNetworksReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.ScanNetworksReply
                     * @static
                     * @param {particle.ctrl.mesh.IScanNetworksReply=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.ScanNetworksReply} ScanNetworksReply instance
                     */
                    ScanNetworksReply.create = function create(properties) {
                        return new ScanNetworksReply(properties);
                    };
    
                    /**
                     * Encodes the specified ScanNetworksReply message. Does not implicitly {@link particle.ctrl.mesh.ScanNetworksReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.ScanNetworksReply
                     * @static
                     * @param {particle.ctrl.mesh.IScanNetworksReply} message ScanNetworksReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ScanNetworksReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.networks != null && message.networks.length)
                            for (var i = 0; i < message.networks.length; ++i)
                                $root.particle.ctrl.mesh.NetworkInfo.encode(message.networks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a ScanNetworksReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.ScanNetworksReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.ScanNetworksReply} ScanNetworksReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ScanNetworksReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.ScanNetworksReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.networks && message.networks.length))
                                    message.networks = [];
                                message.networks.push($root.particle.ctrl.mesh.NetworkInfo.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return ScanNetworksReply;
                })();
    
                /**
                 * DiagnosticType enum.
                 * @name particle.ctrl.mesh.DiagnosticType
                 * @enum {number}
                 * @property {number} MAC_EXTENDED_ADDRESS=0 MAC_EXTENDED_ADDRESS value
                 * @property {number} RLOC=1 RLOC value
                 * @property {number} MAC_ADDRESS=1 MAC_ADDRESS value
                 * @property {number} MODE=2 MODE value
                 * @property {number} TIMEOUT=3 TIMEOUT value
                 * @property {number} CONNECTIVITY=4 CONNECTIVITY value
                 * @property {number} ROUTE64=5 ROUTE64 value
                 * @property {number} LEADER_DATA=6 LEADER_DATA value
                 * @property {number} NETWORK_DATA=7 NETWORK_DATA value
                 * @property {number} IPV6_ADDRESS_LIST=8 IPV6_ADDRESS_LIST value
                 * @property {number} MAC_COUNTERS=9 MAC_COUNTERS value
                 * @property {number} BATTERY_LEVEL=14 BATTERY_LEVEL value
                 * @property {number} SUPPLY_VOLTAGE=15 SUPPLY_VOLTAGE value
                 * @property {number} CHILD_TABLE=16 CHILD_TABLE value
                 * @property {number} CHANNEL_PAGES=17 CHANNEL_PAGES value
                 * @property {number} TYPE_LIST=18 TYPE_LIST value
                 * @property {number} MAX_CHILD_TIMEOUT=19 MAX_CHILD_TIMEOUT value
                 */
                mesh.DiagnosticType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "MAC_EXTENDED_ADDRESS"] = 0;
                    values[valuesById[1] = "RLOC"] = 1;
                    values["MAC_ADDRESS"] = 1;
                    values[valuesById[2] = "MODE"] = 2;
                    values[valuesById[3] = "TIMEOUT"] = 3;
                    values[valuesById[4] = "CONNECTIVITY"] = 4;
                    values[valuesById[5] = "ROUTE64"] = 5;
                    values[valuesById[6] = "LEADER_DATA"] = 6;
                    values[valuesById[7] = "NETWORK_DATA"] = 7;
                    values[valuesById[8] = "IPV6_ADDRESS_LIST"] = 8;
                    values[valuesById[9] = "MAC_COUNTERS"] = 9;
                    values[valuesById[14] = "BATTERY_LEVEL"] = 14;
                    values[valuesById[15] = "SUPPLY_VOLTAGE"] = 15;
                    values[valuesById[16] = "CHILD_TABLE"] = 16;
                    values[valuesById[17] = "CHANNEL_PAGES"] = 17;
                    values[valuesById[18] = "TYPE_LIST"] = 18;
                    values[valuesById[19] = "MAX_CHILD_TIMEOUT"] = 19;
                    return values;
                })();
    
                mesh.DiagnosticInfo = (function() {
    
                    /**
                     * Properties of a DiagnosticInfo.
                     * @memberof particle.ctrl.mesh
                     * @interface IDiagnosticInfo
                     * @property {Uint8Array|null} [extMacAddress] DiagnosticInfo extMacAddress
                     * @property {number|null} [rloc] DiagnosticInfo rloc
                     * @property {number|null} [mode] DiagnosticInfo mode
                     * @property {number|null} [timeout] DiagnosticInfo timeout
                     * @property {particle.ctrl.mesh.DiagnosticInfo.IConnectivity|null} [connectivity] DiagnosticInfo connectivity
                     * @property {particle.ctrl.mesh.DiagnosticInfo.IRoute64|null} [route64] DiagnosticInfo route64
                     * @property {particle.ctrl.mesh.DiagnosticInfo.ILeaderData|null} [leaderData] DiagnosticInfo leaderData
                     * @property {particle.ctrl.mesh.DiagnosticInfo.INetworkData|null} [networkData] DiagnosticInfo networkData
                     * @property {Array.<particle.ctrl.IIpv6Address>|null} [ipv6AddressList] DiagnosticInfo ipv6AddressList
                     * @property {particle.ctrl.mesh.DiagnosticInfo.IMacCounters|null} [macCounters] DiagnosticInfo macCounters
                     * @property {number|null} [batteryLevel] DiagnosticInfo batteryLevel
                     * @property {number|null} [supplyVoltage] DiagnosticInfo supplyVoltage
                     * @property {particle.ctrl.mesh.DiagnosticInfo.IChildTable|null} [childTable] DiagnosticInfo childTable
                     * @property {Uint8Array|null} [channelPages] DiagnosticInfo channelPages
                     * @property {Array.<particle.ctrl.mesh.DiagnosticType>|null} [typeList] DiagnosticInfo typeList
                     * @property {number|null} [maxChildTimeout] DiagnosticInfo maxChildTimeout
                     * @property {Uint8Array|null} [deviceId] DiagnosticInfo deviceId
                     */
    
                    /**
                     * Constructs a new DiagnosticInfo.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a DiagnosticInfo.
                     * @implements IDiagnosticInfo
                     * @constructor
                     * @param {particle.ctrl.mesh.IDiagnosticInfo=} [properties] Properties to set
                     */
                    function DiagnosticInfo(properties) {
                        this.ipv6AddressList = [];
                        this.typeList = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DiagnosticInfo extMacAddress.
                     * @member {Uint8Array} extMacAddress
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.extMacAddress = $util.newBuffer([]);
    
                    /**
                     * DiagnosticInfo rloc.
                     * @member {number} rloc
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.rloc = 0;
    
                    /**
                     * DiagnosticInfo mode.
                     * @member {number} mode
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.mode = 0;
    
                    /**
                     * DiagnosticInfo timeout.
                     * @member {number} timeout
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.timeout = 0;
    
                    /**
                     * DiagnosticInfo connectivity.
                     * @member {particle.ctrl.mesh.DiagnosticInfo.IConnectivity|null|undefined} connectivity
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.connectivity = null;
    
                    /**
                     * DiagnosticInfo route64.
                     * @member {particle.ctrl.mesh.DiagnosticInfo.IRoute64|null|undefined} route64
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.route64 = null;
    
                    /**
                     * DiagnosticInfo leaderData.
                     * @member {particle.ctrl.mesh.DiagnosticInfo.ILeaderData|null|undefined} leaderData
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.leaderData = null;
    
                    /**
                     * DiagnosticInfo networkData.
                     * @member {particle.ctrl.mesh.DiagnosticInfo.INetworkData|null|undefined} networkData
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.networkData = null;
    
                    /**
                     * DiagnosticInfo ipv6AddressList.
                     * @member {Array.<particle.ctrl.IIpv6Address>} ipv6AddressList
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.ipv6AddressList = $util.emptyArray;
    
                    /**
                     * DiagnosticInfo macCounters.
                     * @member {particle.ctrl.mesh.DiagnosticInfo.IMacCounters|null|undefined} macCounters
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.macCounters = null;
    
                    /**
                     * DiagnosticInfo batteryLevel.
                     * @member {number} batteryLevel
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.batteryLevel = 0;
    
                    /**
                     * DiagnosticInfo supplyVoltage.
                     * @member {number} supplyVoltage
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.supplyVoltage = 0;
    
                    /**
                     * DiagnosticInfo childTable.
                     * @member {particle.ctrl.mesh.DiagnosticInfo.IChildTable|null|undefined} childTable
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.childTable = null;
    
                    /**
                     * DiagnosticInfo channelPages.
                     * @member {Uint8Array} channelPages
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.channelPages = $util.newBuffer([]);
    
                    /**
                     * DiagnosticInfo typeList.
                     * @member {Array.<particle.ctrl.mesh.DiagnosticType>} typeList
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.typeList = $util.emptyArray;
    
                    /**
                     * DiagnosticInfo maxChildTimeout.
                     * @member {number} maxChildTimeout
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.maxChildTimeout = 0;
    
                    /**
                     * DiagnosticInfo deviceId.
                     * @member {Uint8Array} deviceId
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @instance
                     */
                    DiagnosticInfo.prototype.deviceId = $util.newBuffer([]);
    
                    /**
                     * Creates a new DiagnosticInfo instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @static
                     * @param {particle.ctrl.mesh.IDiagnosticInfo=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.DiagnosticInfo} DiagnosticInfo instance
                     */
                    DiagnosticInfo.create = function create(properties) {
                        return new DiagnosticInfo(properties);
                    };
    
                    /**
                     * Encodes the specified DiagnosticInfo message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @static
                     * @param {particle.ctrl.mesh.IDiagnosticInfo} message DiagnosticInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DiagnosticInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.extMacAddress != null && Object.hasOwnProperty.call(message, "extMacAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.extMacAddress);
                        if (message.rloc != null && Object.hasOwnProperty.call(message, "rloc"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.rloc);
                        if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.mode);
                        if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timeout);
                        if (message.connectivity != null && Object.hasOwnProperty.call(message, "connectivity"))
                            $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity.encode(message.connectivity, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.route64 != null && Object.hasOwnProperty.call(message, "route64"))
                            $root.particle.ctrl.mesh.DiagnosticInfo.Route64.encode(message.route64, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.leaderData != null && Object.hasOwnProperty.call(message, "leaderData"))
                            $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData.encode(message.leaderData, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.networkData != null && Object.hasOwnProperty.call(message, "networkData"))
                            $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.encode(message.networkData, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.ipv6AddressList != null && message.ipv6AddressList.length)
                            for (var i = 0; i < message.ipv6AddressList.length; ++i)
                                $root.particle.ctrl.Ipv6Address.encode(message.ipv6AddressList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.macCounters != null && Object.hasOwnProperty.call(message, "macCounters"))
                            $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters.encode(message.macCounters, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.batteryLevel != null && Object.hasOwnProperty.call(message, "batteryLevel"))
                            writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.batteryLevel);
                        if (message.supplyVoltage != null && Object.hasOwnProperty.call(message, "supplyVoltage"))
                            writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.supplyVoltage);
                        if (message.childTable != null && Object.hasOwnProperty.call(message, "childTable"))
                            $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.encode(message.childTable, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                        if (message.channelPages != null && Object.hasOwnProperty.call(message, "channelPages"))
                            writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.channelPages);
                        if (message.typeList != null && message.typeList.length) {
                            writer.uint32(/* id 19, wireType 2 =*/154).fork();
                            for (var i = 0; i < message.typeList.length; ++i)
                                writer.int32(message.typeList[i]);
                            writer.ldelim();
                        }
                        if (message.maxChildTimeout != null && Object.hasOwnProperty.call(message, "maxChildTimeout"))
                            writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.maxChildTimeout);
                        if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
                            writer.uint32(/* id 100, wireType 2 =*/802).bytes(message.deviceId);
                        return writer;
                    };
    
                    /**
                     * Decodes a DiagnosticInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.DiagnosticInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.DiagnosticInfo} DiagnosticInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DiagnosticInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.extMacAddress = reader.bytes();
                                break;
                            case 2:
                                message.rloc = reader.uint32();
                                break;
                            case 3:
                                message.mode = reader.uint32();
                                break;
                            case 4:
                                message.timeout = reader.uint32();
                                break;
                            case 5:
                                message.connectivity = $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.route64 = $root.particle.ctrl.mesh.DiagnosticInfo.Route64.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.leaderData = $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.networkData = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.decode(reader, reader.uint32());
                                break;
                            case 9:
                                if (!(message.ipv6AddressList && message.ipv6AddressList.length))
                                    message.ipv6AddressList = [];
                                message.ipv6AddressList.push($root.particle.ctrl.Ipv6Address.decode(reader, reader.uint32()));
                                break;
                            case 10:
                                message.macCounters = $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters.decode(reader, reader.uint32());
                                break;
                            case 15:
                                message.batteryLevel = reader.uint32();
                                break;
                            case 16:
                                message.supplyVoltage = reader.uint32();
                                break;
                            case 17:
                                message.childTable = $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.decode(reader, reader.uint32());
                                break;
                            case 18:
                                message.channelPages = reader.bytes();
                                break;
                            case 19:
                                if (!(message.typeList && message.typeList.length))
                                    message.typeList = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.typeList.push(reader.int32());
                                } else
                                    message.typeList.push(reader.int32());
                                break;
                            case 20:
                                message.maxChildTimeout = reader.uint32();
                                break;
                            case 100:
                                message.deviceId = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Mode enum.
                     * @name particle.ctrl.mesh.DiagnosticInfo.Mode
                     * @enum {number}
                     * @property {number} INVALID=0 INVALID value
                     * @property {number} RECEIVER_ON_WHEN_IDLE=16 RECEIVER_ON_WHEN_IDLE value
                     * @property {number} SECURE_DATA_REQUESTS=32 SECURE_DATA_REQUESTS value
                     * @property {number} DEVICE_TYPE=48 DEVICE_TYPE value
                     * @property {number} DEVICE_TYPE_FTD=48 DEVICE_TYPE_FTD value
                     * @property {number} NETWORK_DATA=64 NETWORK_DATA value
                     * @property {number} NETWORK_DATA_FULL=64 NETWORK_DATA_FULL value
                     */
                    DiagnosticInfo.Mode = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "INVALID"] = 0;
                        values[valuesById[16] = "RECEIVER_ON_WHEN_IDLE"] = 16;
                        values[valuesById[32] = "SECURE_DATA_REQUESTS"] = 32;
                        values[valuesById[48] = "DEVICE_TYPE"] = 48;
                        values["DEVICE_TYPE_FTD"] = 48;
                        values[valuesById[64] = "NETWORK_DATA"] = 64;
                        values["NETWORK_DATA_FULL"] = 64;
                        return values;
                    })();
    
                    DiagnosticInfo.Connectivity = (function() {
    
                        /**
                         * Properties of a Connectivity.
                         * @memberof particle.ctrl.mesh.DiagnosticInfo
                         * @interface IConnectivity
                         * @property {number|null} [parentPriority] Connectivity parentPriority
                         * @property {number|null} [linkQuality_1] Connectivity linkQuality_1
                         * @property {number|null} [linkQuality_2] Connectivity linkQuality_2
                         * @property {number|null} [linkQuality_3] Connectivity linkQuality_3
                         * @property {number|null} [leaderCost] Connectivity leaderCost
                         * @property {number|null} [idSequence] Connectivity idSequence
                         * @property {number|null} [activeRouters] Connectivity activeRouters
                         * @property {number|null} [sedBufferSize] Connectivity sedBufferSize
                         * @property {number|null} [sedDatagramCount] Connectivity sedDatagramCount
                         */
    
                        /**
                         * Constructs a new Connectivity.
                         * @memberof particle.ctrl.mesh.DiagnosticInfo
                         * @classdesc Represents a Connectivity.
                         * @implements IConnectivity
                         * @constructor
                         * @param {particle.ctrl.mesh.DiagnosticInfo.IConnectivity=} [properties] Properties to set
                         */
                        function Connectivity(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Connectivity parentPriority.
                         * @member {number} parentPriority
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity
                         * @instance
                         */
                        Connectivity.prototype.parentPriority = 0;
    
                        /**
                         * Connectivity linkQuality_1.
                         * @member {number} linkQuality_1
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity
                         * @instance
                         */
                        Connectivity.prototype.linkQuality_1 = 0;
    
                        /**
                         * Connectivity linkQuality_2.
                         * @member {number} linkQuality_2
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity
                         * @instance
                         */
                        Connectivity.prototype.linkQuality_2 = 0;
    
                        /**
                         * Connectivity linkQuality_3.
                         * @member {number} linkQuality_3
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity
                         * @instance
                         */
                        Connectivity.prototype.linkQuality_3 = 0;
    
                        /**
                         * Connectivity leaderCost.
                         * @member {number} leaderCost
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity
                         * @instance
                         */
                        Connectivity.prototype.leaderCost = 0;
    
                        /**
                         * Connectivity idSequence.
                         * @member {number} idSequence
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity
                         * @instance
                         */
                        Connectivity.prototype.idSequence = 0;
    
                        /**
                         * Connectivity activeRouters.
                         * @member {number} activeRouters
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity
                         * @instance
                         */
                        Connectivity.prototype.activeRouters = 0;
    
                        /**
                         * Connectivity sedBufferSize.
                         * @member {number} sedBufferSize
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity
                         * @instance
                         */
                        Connectivity.prototype.sedBufferSize = 0;
    
                        /**
                         * Connectivity sedDatagramCount.
                         * @member {number} sedDatagramCount
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity
                         * @instance
                         */
                        Connectivity.prototype.sedDatagramCount = 0;
    
                        /**
                         * Creates a new Connectivity instance using the specified properties.
                         * @function create
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity
                         * @static
                         * @param {particle.ctrl.mesh.DiagnosticInfo.IConnectivity=} [properties] Properties to set
                         * @returns {particle.ctrl.mesh.DiagnosticInfo.Connectivity} Connectivity instance
                         */
                        Connectivity.create = function create(properties) {
                            return new Connectivity(properties);
                        };
    
                        /**
                         * Encodes the specified Connectivity message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.Connectivity.verify|verify} messages.
                         * @function encode
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity
                         * @static
                         * @param {particle.ctrl.mesh.DiagnosticInfo.IConnectivity} message Connectivity message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Connectivity.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.parentPriority != null && Object.hasOwnProperty.call(message, "parentPriority"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.parentPriority);
                            if (message.linkQuality_1 != null && Object.hasOwnProperty.call(message, "linkQuality_1"))
                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.linkQuality_1);
                            if (message.linkQuality_2 != null && Object.hasOwnProperty.call(message, "linkQuality_2"))
                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.linkQuality_2);
                            if (message.linkQuality_3 != null && Object.hasOwnProperty.call(message, "linkQuality_3"))
                                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.linkQuality_3);
                            if (message.leaderCost != null && Object.hasOwnProperty.call(message, "leaderCost"))
                                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.leaderCost);
                            if (message.idSequence != null && Object.hasOwnProperty.call(message, "idSequence"))
                                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.idSequence);
                            if (message.activeRouters != null && Object.hasOwnProperty.call(message, "activeRouters"))
                                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.activeRouters);
                            if (message.sedBufferSize != null && Object.hasOwnProperty.call(message, "sedBufferSize"))
                                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.sedBufferSize);
                            if (message.sedDatagramCount != null && Object.hasOwnProperty.call(message, "sedDatagramCount"))
                                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.sedDatagramCount);
                            return writer;
                        };
    
                        /**
                         * Decodes a Connectivity message from the specified reader or buffer.
                         * @function decode
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {particle.ctrl.mesh.DiagnosticInfo.Connectivity} Connectivity
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Connectivity.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.parentPriority = reader.uint32();
                                    break;
                                case 2:
                                    message.linkQuality_1 = reader.uint32();
                                    break;
                                case 3:
                                    message.linkQuality_2 = reader.uint32();
                                    break;
                                case 4:
                                    message.linkQuality_3 = reader.uint32();
                                    break;
                                case 5:
                                    message.leaderCost = reader.uint32();
                                    break;
                                case 6:
                                    message.idSequence = reader.uint32();
                                    break;
                                case 7:
                                    message.activeRouters = reader.uint32();
                                    break;
                                case 8:
                                    message.sedBufferSize = reader.uint32();
                                    break;
                                case 9:
                                    message.sedDatagramCount = reader.uint32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        return Connectivity;
                    })();
    
                    DiagnosticInfo.Route64 = (function() {
    
                        /**
                         * Properties of a Route64.
                         * @memberof particle.ctrl.mesh.DiagnosticInfo
                         * @interface IRoute64
                         * @property {number|null} [idSequence] Route64 idSequence
                         * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData>|null} [routes] Route64 routes
                         */
    
                        /**
                         * Constructs a new Route64.
                         * @memberof particle.ctrl.mesh.DiagnosticInfo
                         * @classdesc Represents a Route64.
                         * @implements IRoute64
                         * @constructor
                         * @param {particle.ctrl.mesh.DiagnosticInfo.IRoute64=} [properties] Properties to set
                         */
                        function Route64(properties) {
                            this.routes = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Route64 idSequence.
                         * @member {number} idSequence
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64
                         * @instance
                         */
                        Route64.prototype.idSequence = 0;
    
                        /**
                         * Route64 routes.
                         * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData>} routes
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64
                         * @instance
                         */
                        Route64.prototype.routes = $util.emptyArray;
    
                        /**
                         * Creates a new Route64 instance using the specified properties.
                         * @function create
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64
                         * @static
                         * @param {particle.ctrl.mesh.DiagnosticInfo.IRoute64=} [properties] Properties to set
                         * @returns {particle.ctrl.mesh.DiagnosticInfo.Route64} Route64 instance
                         */
                        Route64.create = function create(properties) {
                            return new Route64(properties);
                        };
    
                        /**
                         * Encodes the specified Route64 message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.Route64.verify|verify} messages.
                         * @function encode
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64
                         * @static
                         * @param {particle.ctrl.mesh.DiagnosticInfo.IRoute64} message Route64 message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Route64.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.idSequence != null && Object.hasOwnProperty.call(message, "idSequence"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.idSequence);
                            if (message.routes != null && message.routes.length)
                                for (var i = 0; i < message.routes.length; ++i)
                                    $root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.encode(message.routes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };
    
                        /**
                         * Decodes a Route64 message from the specified reader or buffer.
                         * @function decode
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {particle.ctrl.mesh.DiagnosticInfo.Route64} Route64
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Route64.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.Route64();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.idSequence = reader.uint32();
                                    break;
                                case 2:
                                    if (!(message.routes && message.routes.length))
                                        message.routes = [];
                                    message.routes.push($root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        Route64.RouteData = (function() {
    
                            /**
                             * Properties of a RouteData.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64
                             * @interface IRouteData
                             * @property {number|null} [routerRloc] RouteData routerRloc
                             * @property {number|null} [linkQualityOut] RouteData linkQualityOut
                             * @property {number|null} [linkQualityIn] RouteData linkQualityIn
                             * @property {number|null} [routeCost] RouteData routeCost
                             */
    
                            /**
                             * Constructs a new RouteData.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64
                             * @classdesc Represents a RouteData.
                             * @implements IRouteData
                             * @constructor
                             * @param {particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData=} [properties] Properties to set
                             */
                            function RouteData(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }
    
                            /**
                             * RouteData routerRloc.
                             * @member {number} routerRloc
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData
                             * @instance
                             */
                            RouteData.prototype.routerRloc = 0;
    
                            /**
                             * RouteData linkQualityOut.
                             * @member {number} linkQualityOut
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData
                             * @instance
                             */
                            RouteData.prototype.linkQualityOut = 0;
    
                            /**
                             * RouteData linkQualityIn.
                             * @member {number} linkQualityIn
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData
                             * @instance
                             */
                            RouteData.prototype.linkQualityIn = 0;
    
                            /**
                             * RouteData routeCost.
                             * @member {number} routeCost
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData
                             * @instance
                             */
                            RouteData.prototype.routeCost = 0;
    
                            /**
                             * Creates a new RouteData instance using the specified properties.
                             * @function create
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData=} [properties] Properties to set
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData} RouteData instance
                             */
                            RouteData.create = function create(properties) {
                                return new RouteData(properties);
                            };
    
                            /**
                             * Encodes the specified RouteData message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.verify|verify} messages.
                             * @function encode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData} message RouteData message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            RouteData.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.routerRloc != null && Object.hasOwnProperty.call(message, "routerRloc"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.routerRloc);
                                if (message.linkQualityOut != null && Object.hasOwnProperty.call(message, "linkQualityOut"))
                                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.linkQualityOut);
                                if (message.linkQualityIn != null && Object.hasOwnProperty.call(message, "linkQualityIn"))
                                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.linkQualityIn);
                                if (message.routeCost != null && Object.hasOwnProperty.call(message, "routeCost"))
                                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.routeCost);
                                return writer;
                            };
    
                            /**
                             * Decodes a RouteData message from the specified reader or buffer.
                             * @function decode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData} RouteData
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            RouteData.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.routerRloc = reader.uint32();
                                        break;
                                    case 2:
                                        message.linkQualityOut = reader.uint32();
                                        break;
                                    case 3:
                                        message.linkQualityIn = reader.uint32();
                                        break;
                                    case 4:
                                        message.routeCost = reader.uint32();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };
    
                            return RouteData;
                        })();
    
                        return Route64;
                    })();
    
                    DiagnosticInfo.LeaderData = (function() {
    
                        /**
                         * Properties of a LeaderData.
                         * @memberof particle.ctrl.mesh.DiagnosticInfo
                         * @interface ILeaderData
                         * @property {number|null} [partitionId] LeaderData partitionId
                         * @property {number|null} [weighting] LeaderData weighting
                         * @property {number|null} [dataVersion] LeaderData dataVersion
                         * @property {number|null} [stableDataVersion] LeaderData stableDataVersion
                         * @property {number|null} [leaderRloc] LeaderData leaderRloc
                         */
    
                        /**
                         * Constructs a new LeaderData.
                         * @memberof particle.ctrl.mesh.DiagnosticInfo
                         * @classdesc Represents a LeaderData.
                         * @implements ILeaderData
                         * @constructor
                         * @param {particle.ctrl.mesh.DiagnosticInfo.ILeaderData=} [properties] Properties to set
                         */
                        function LeaderData(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * LeaderData partitionId.
                         * @member {number} partitionId
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData
                         * @instance
                         */
                        LeaderData.prototype.partitionId = 0;
    
                        /**
                         * LeaderData weighting.
                         * @member {number} weighting
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData
                         * @instance
                         */
                        LeaderData.prototype.weighting = 0;
    
                        /**
                         * LeaderData dataVersion.
                         * @member {number} dataVersion
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData
                         * @instance
                         */
                        LeaderData.prototype.dataVersion = 0;
    
                        /**
                         * LeaderData stableDataVersion.
                         * @member {number} stableDataVersion
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData
                         * @instance
                         */
                        LeaderData.prototype.stableDataVersion = 0;
    
                        /**
                         * LeaderData leaderRloc.
                         * @member {number} leaderRloc
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData
                         * @instance
                         */
                        LeaderData.prototype.leaderRloc = 0;
    
                        /**
                         * Creates a new LeaderData instance using the specified properties.
                         * @function create
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData
                         * @static
                         * @param {particle.ctrl.mesh.DiagnosticInfo.ILeaderData=} [properties] Properties to set
                         * @returns {particle.ctrl.mesh.DiagnosticInfo.LeaderData} LeaderData instance
                         */
                        LeaderData.create = function create(properties) {
                            return new LeaderData(properties);
                        };
    
                        /**
                         * Encodes the specified LeaderData message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.LeaderData.verify|verify} messages.
                         * @function encode
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData
                         * @static
                         * @param {particle.ctrl.mesh.DiagnosticInfo.ILeaderData} message LeaderData message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        LeaderData.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.partitionId != null && Object.hasOwnProperty.call(message, "partitionId"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.partitionId);
                            if (message.weighting != null && Object.hasOwnProperty.call(message, "weighting"))
                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.weighting);
                            if (message.dataVersion != null && Object.hasOwnProperty.call(message, "dataVersion"))
                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.dataVersion);
                            if (message.stableDataVersion != null && Object.hasOwnProperty.call(message, "stableDataVersion"))
                                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.stableDataVersion);
                            if (message.leaderRloc != null && Object.hasOwnProperty.call(message, "leaderRloc"))
                                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.leaderRloc);
                            return writer;
                        };
    
                        /**
                         * Decodes a LeaderData message from the specified reader or buffer.
                         * @function decode
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {particle.ctrl.mesh.DiagnosticInfo.LeaderData} LeaderData
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        LeaderData.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.partitionId = reader.uint32();
                                    break;
                                case 2:
                                    message.weighting = reader.uint32();
                                    break;
                                case 3:
                                    message.dataVersion = reader.uint32();
                                    break;
                                case 4:
                                    message.stableDataVersion = reader.uint32();
                                    break;
                                case 5:
                                    message.leaderRloc = reader.uint32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        return LeaderData;
                    })();
    
                    /**
                     * RoutePreference enum.
                     * @name particle.ctrl.mesh.DiagnosticInfo.RoutePreference
                     * @enum {number}
                     * @property {number} MEDIUM=0 MEDIUM value
                     * @property {number} HIGH=1 HIGH value
                     * @property {number} LOW=-1 LOW value
                     */
                    DiagnosticInfo.RoutePreference = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "MEDIUM"] = 0;
                        values[valuesById[1] = "HIGH"] = 1;
                        values[valuesById[-1] = "LOW"] = -1;
                        return values;
                    })();
    
                    DiagnosticInfo.NetworkData = (function() {
    
                        /**
                         * Properties of a NetworkData.
                         * @memberof particle.ctrl.mesh.DiagnosticInfo
                         * @interface INetworkData
                         * @property {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData|null} [stable] NetworkData stable
                         * @property {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData|null} [temporary] NetworkData temporary
                         */
    
                        /**
                         * Constructs a new NetworkData.
                         * @memberof particle.ctrl.mesh.DiagnosticInfo
                         * @classdesc Represents a NetworkData.
                         * @implements INetworkData
                         * @constructor
                         * @param {particle.ctrl.mesh.DiagnosticInfo.INetworkData=} [properties] Properties to set
                         */
                        function NetworkData(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * NetworkData stable.
                         * @member {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData|null|undefined} stable
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                         * @instance
                         */
                        NetworkData.prototype.stable = null;
    
                        /**
                         * NetworkData temporary.
                         * @member {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData|null|undefined} temporary
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                         * @instance
                         */
                        NetworkData.prototype.temporary = null;
    
                        /**
                         * Creates a new NetworkData instance using the specified properties.
                         * @function create
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                         * @static
                         * @param {particle.ctrl.mesh.DiagnosticInfo.INetworkData=} [properties] Properties to set
                         * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData} NetworkData instance
                         */
                        NetworkData.create = function create(properties) {
                            return new NetworkData(properties);
                        };
    
                        /**
                         * Encodes the specified NetworkData message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.verify|verify} messages.
                         * @function encode
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                         * @static
                         * @param {particle.ctrl.mesh.DiagnosticInfo.INetworkData} message NetworkData message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        NetworkData.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.stable != null && Object.hasOwnProperty.call(message, "stable"))
                                $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.encode(message.stable, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.temporary != null && Object.hasOwnProperty.call(message, "temporary"))
                                $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.encode(message.temporary, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };
    
                        /**
                         * Decodes a NetworkData message from the specified reader or buffer.
                         * @function decode
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData} NetworkData
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        NetworkData.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.stable = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.temporary = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        NetworkData.HasRoute = (function() {
    
                            /**
                             * Properties of a HasRoute.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @interface IHasRoute
                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry>|null} [entries] HasRoute entries
                             */
    
                            /**
                             * Constructs a new HasRoute.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @classdesc Represents a HasRoute.
                             * @implements IHasRoute
                             * @constructor
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute=} [properties] Properties to set
                             */
                            function HasRoute(properties) {
                                this.entries = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }
    
                            /**
                             * HasRoute entries.
                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry>} entries
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute
                             * @instance
                             */
                            HasRoute.prototype.entries = $util.emptyArray;
    
                            /**
                             * Creates a new HasRoute instance using the specified properties.
                             * @function create
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute=} [properties] Properties to set
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute} HasRoute instance
                             */
                            HasRoute.create = function create(properties) {
                                return new HasRoute(properties);
                            };
    
                            /**
                             * Encodes the specified HasRoute message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.verify|verify} messages.
                             * @function encode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute} message HasRoute message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            HasRoute.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.entries != null && message.entries.length)
                                    for (var i = 0; i < message.entries.length; ++i)
                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };
    
                            /**
                             * Decodes a HasRoute message from the specified reader or buffer.
                             * @function decode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute} HasRoute
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            HasRoute.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        if (!(message.entries && message.entries.length))
                                            message.entries = [];
                                        message.entries.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.decode(reader, reader.uint32()));
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };
    
                            HasRoute.HasRouteEntry = (function() {
    
                                /**
                                 * Properties of a HasRouteEntry.
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute
                                 * @interface IHasRouteEntry
                                 * @property {number|null} [rloc] HasRouteEntry rloc
                                 * @property {particle.ctrl.mesh.DiagnosticInfo.RoutePreference|null} [preference] HasRouteEntry preference
                                 */
    
                                /**
                                 * Constructs a new HasRouteEntry.
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute
                                 * @classdesc Represents a HasRouteEntry.
                                 * @implements IHasRouteEntry
                                 * @constructor
                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry=} [properties] Properties to set
                                 */
                                function HasRouteEntry(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }
    
                                /**
                                 * HasRouteEntry rloc.
                                 * @member {number} rloc
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry
                                 * @instance
                                 */
                                HasRouteEntry.prototype.rloc = 0;
    
                                /**
                                 * HasRouteEntry preference.
                                 * @member {particle.ctrl.mesh.DiagnosticInfo.RoutePreference} preference
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry
                                 * @instance
                                 */
                                HasRouteEntry.prototype.preference = 0;
    
                                /**
                                 * Creates a new HasRouteEntry instance using the specified properties.
                                 * @function create
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry
                                 * @static
                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry=} [properties] Properties to set
                                 * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry} HasRouteEntry instance
                                 */
                                HasRouteEntry.create = function create(properties) {
                                    return new HasRouteEntry(properties);
                                };
    
                                /**
                                 * Encodes the specified HasRouteEntry message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.verify|verify} messages.
                                 * @function encode
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry
                                 * @static
                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry} message HasRouteEntry message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                HasRouteEntry.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.rloc != null && Object.hasOwnProperty.call(message, "rloc"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rloc);
                                    if (message.preference != null && Object.hasOwnProperty.call(message, "preference"))
                                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.preference);
                                    return writer;
                                };
    
                                /**
                                 * Decodes a HasRouteEntry message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry} HasRouteEntry
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                HasRouteEntry.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.rloc = reader.uint32();
                                            break;
                                        case 2:
                                            message.preference = reader.int32();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };
    
                                return HasRouteEntry;
                            })();
    
                            return HasRoute;
                        })();
    
                        NetworkData.BorderRouter = (function() {
    
                            /**
                             * Properties of a BorderRouter.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @interface IBorderRouter
                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry>|null} [entries] BorderRouter entries
                             */
    
                            /**
                             * Constructs a new BorderRouter.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @classdesc Represents a BorderRouter.
                             * @implements IBorderRouter
                             * @constructor
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter=} [properties] Properties to set
                             */
                            function BorderRouter(properties) {
                                this.entries = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }
    
                            /**
                             * BorderRouter entries.
                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry>} entries
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter
                             * @instance
                             */
                            BorderRouter.prototype.entries = $util.emptyArray;
    
                            /**
                             * Creates a new BorderRouter instance using the specified properties.
                             * @function create
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter=} [properties] Properties to set
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter} BorderRouter instance
                             */
                            BorderRouter.create = function create(properties) {
                                return new BorderRouter(properties);
                            };
    
                            /**
                             * Encodes the specified BorderRouter message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.verify|verify} messages.
                             * @function encode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter} message BorderRouter message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            BorderRouter.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.entries != null && message.entries.length)
                                    for (var i = 0; i < message.entries.length; ++i)
                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };
    
                            /**
                             * Decodes a BorderRouter message from the specified reader or buffer.
                             * @function decode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter} BorderRouter
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            BorderRouter.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        if (!(message.entries && message.entries.length))
                                            message.entries = [];
                                        message.entries.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.decode(reader, reader.uint32()));
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };
    
                            BorderRouter.BorderRouterEntry = (function() {
    
                                /**
                                 * Properties of a BorderRouterEntry.
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter
                                 * @interface IBorderRouterEntry
                                 * @property {number|null} [rloc] BorderRouterEntry rloc
                                 * @property {particle.ctrl.mesh.DiagnosticInfo.RoutePreference|null} [preference] BorderRouterEntry preference
                                 * @property {number|null} [flags] BorderRouterEntry flags
                                 */
    
                                /**
                                 * Constructs a new BorderRouterEntry.
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter
                                 * @classdesc Represents a BorderRouterEntry.
                                 * @implements IBorderRouterEntry
                                 * @constructor
                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry=} [properties] Properties to set
                                 */
                                function BorderRouterEntry(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }
    
                                /**
                                 * BorderRouterEntry rloc.
                                 * @member {number} rloc
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry
                                 * @instance
                                 */
                                BorderRouterEntry.prototype.rloc = 0;
    
                                /**
                                 * BorderRouterEntry preference.
                                 * @member {particle.ctrl.mesh.DiagnosticInfo.RoutePreference} preference
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry
                                 * @instance
                                 */
                                BorderRouterEntry.prototype.preference = 0;
    
                                /**
                                 * BorderRouterEntry flags.
                                 * @member {number} flags
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry
                                 * @instance
                                 */
                                BorderRouterEntry.prototype.flags = 0;
    
                                /**
                                 * Creates a new BorderRouterEntry instance using the specified properties.
                                 * @function create
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry
                                 * @static
                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry=} [properties] Properties to set
                                 * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry} BorderRouterEntry instance
                                 */
                                BorderRouterEntry.create = function create(properties) {
                                    return new BorderRouterEntry(properties);
                                };
    
                                /**
                                 * Encodes the specified BorderRouterEntry message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.verify|verify} messages.
                                 * @function encode
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry
                                 * @static
                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry} message BorderRouterEntry message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                BorderRouterEntry.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.rloc != null && Object.hasOwnProperty.call(message, "rloc"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rloc);
                                    if (message.preference != null && Object.hasOwnProperty.call(message, "preference"))
                                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.preference);
                                    if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.flags);
                                    return writer;
                                };
    
                                /**
                                 * Decodes a BorderRouterEntry message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry} BorderRouterEntry
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                BorderRouterEntry.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.rloc = reader.uint32();
                                            break;
                                        case 2:
                                            message.preference = reader.int32();
                                            break;
                                        case 3:
                                            message.flags = reader.uint32();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };
    
                                /**
                                 * Flags enum.
                                 * @name particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.Flags
                                 * @enum {number}
                                 * @property {number} NONE=0 NONE value
                                 * @property {number} PREFERRED=1 PREFERRED value
                                 * @property {number} SLAAC=2 SLAAC value
                                 * @property {number} DHCP=4 DHCP value
                                 * @property {number} CONFIGURE=8 CONFIGURE value
                                 * @property {number} DEFAULT_ROUTE=16 DEFAULT_ROUTE value
                                 * @property {number} ON_MESH=32 ON_MESH value
                                 * @property {number} ND_DNS=64 ND_DNS value
                                 */
                                BorderRouterEntry.Flags = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NONE"] = 0;
                                    values[valuesById[1] = "PREFERRED"] = 1;
                                    values[valuesById[2] = "SLAAC"] = 2;
                                    values[valuesById[4] = "DHCP"] = 4;
                                    values[valuesById[8] = "CONFIGURE"] = 8;
                                    values[valuesById[16] = "DEFAULT_ROUTE"] = 16;
                                    values[valuesById[32] = "ON_MESH"] = 32;
                                    values[valuesById[64] = "ND_DNS"] = 64;
                                    return values;
                                })();
    
                                return BorderRouterEntry;
                            })();
    
                            return BorderRouter;
                        })();
    
                        NetworkData.Context = (function() {
    
                            /**
                             * Properties of a Context.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @interface IContext
                             * @property {number|null} [cid] Context cid
                             * @property {boolean|null} [compress] Context compress
                             * @property {number|null} [contextLength] Context contextLength
                             */
    
                            /**
                             * Constructs a new Context.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @classdesc Represents a Context.
                             * @implements IContext
                             * @constructor
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext=} [properties] Properties to set
                             */
                            function Context(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }
    
                            /**
                             * Context cid.
                             * @member {number} cid
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context
                             * @instance
                             */
                            Context.prototype.cid = 0;
    
                            /**
                             * Context compress.
                             * @member {boolean} compress
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context
                             * @instance
                             */
                            Context.prototype.compress = false;
    
                            /**
                             * Context contextLength.
                             * @member {number} contextLength
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context
                             * @instance
                             */
                            Context.prototype.contextLength = 0;
    
                            /**
                             * Creates a new Context instance using the specified properties.
                             * @function create
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext=} [properties] Properties to set
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context} Context instance
                             */
                            Context.create = function create(properties) {
                                return new Context(properties);
                            };
    
                            /**
                             * Encodes the specified Context message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.verify|verify} messages.
                             * @function encode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext} message Context message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Context.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.cid != null && Object.hasOwnProperty.call(message, "cid"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.cid);
                                if (message.compress != null && Object.hasOwnProperty.call(message, "compress"))
                                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.compress);
                                if (message.contextLength != null && Object.hasOwnProperty.call(message, "contextLength"))
                                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.contextLength);
                                return writer;
                            };
    
                            /**
                             * Decodes a Context message from the specified reader or buffer.
                             * @function decode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context} Context
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Context.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.cid = reader.uint32();
                                        break;
                                    case 2:
                                        message.compress = reader.bool();
                                        break;
                                    case 3:
                                        message.contextLength = reader.uint32();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };
    
                            return Context;
                        })();
    
                        NetworkData.Prefix = (function() {
    
                            /**
                             * Properties of a Prefix.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @interface IPrefix
                             * @property {number|null} [domainId] Prefix domainId
                             * @property {number|null} [prefixLength] Prefix prefixLength
                             * @property {Uint8Array|null} [prefix] Prefix prefix
                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext>|null} [context] Prefix context
                             * @property {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute|null} [hasRoute] Prefix hasRoute
                             * @property {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter|null} [borderRouter] Prefix borderRouter
                             */
    
                            /**
                             * Constructs a new Prefix.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @classdesc Represents a Prefix.
                             * @implements IPrefix
                             * @constructor
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix=} [properties] Properties to set
                             */
                            function Prefix(properties) {
                                this.context = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }
    
                            /**
                             * Prefix domainId.
                             * @member {number} domainId
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix
                             * @instance
                             */
                            Prefix.prototype.domainId = 0;
    
                            /**
                             * Prefix prefixLength.
                             * @member {number} prefixLength
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix
                             * @instance
                             */
                            Prefix.prototype.prefixLength = 0;
    
                            /**
                             * Prefix prefix.
                             * @member {Uint8Array} prefix
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix
                             * @instance
                             */
                            Prefix.prototype.prefix = $util.newBuffer([]);
    
                            /**
                             * Prefix context.
                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext>} context
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix
                             * @instance
                             */
                            Prefix.prototype.context = $util.emptyArray;
    
                            /**
                             * Prefix hasRoute.
                             * @member {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute|null|undefined} hasRoute
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix
                             * @instance
                             */
                            Prefix.prototype.hasRoute = null;
    
                            /**
                             * Prefix borderRouter.
                             * @member {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter|null|undefined} borderRouter
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix
                             * @instance
                             */
                            Prefix.prototype.borderRouter = null;
    
                            /**
                             * Creates a new Prefix instance using the specified properties.
                             * @function create
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix=} [properties] Properties to set
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix} Prefix instance
                             */
                            Prefix.create = function create(properties) {
                                return new Prefix(properties);
                            };
    
                            /**
                             * Encodes the specified Prefix message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.verify|verify} messages.
                             * @function encode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix} message Prefix message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Prefix.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.domainId != null && Object.hasOwnProperty.call(message, "domainId"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.domainId);
                                if (message.prefixLength != null && Object.hasOwnProperty.call(message, "prefixLength"))
                                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.prefixLength);
                                if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.prefix);
                                if (message.context != null && message.context.length)
                                    for (var i = 0; i < message.context.length; ++i)
                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.encode(message.context[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                                if (message.hasRoute != null && Object.hasOwnProperty.call(message, "hasRoute"))
                                    $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.encode(message.hasRoute, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                                if (message.borderRouter != null && Object.hasOwnProperty.call(message, "borderRouter"))
                                    $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.encode(message.borderRouter, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                                return writer;
                            };
    
                            /**
                             * Decodes a Prefix message from the specified reader or buffer.
                             * @function decode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix} Prefix
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Prefix.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.domainId = reader.uint32();
                                        break;
                                    case 2:
                                        message.prefixLength = reader.uint32();
                                        break;
                                    case 3:
                                        message.prefix = reader.bytes();
                                        break;
                                    case 4:
                                        if (!(message.context && message.context.length))
                                            message.context = [];
                                        message.context.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.decode(reader, reader.uint32()));
                                        break;
                                    case 5:
                                        message.hasRoute = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.decode(reader, reader.uint32());
                                        break;
                                    case 6:
                                        message.borderRouter = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };
    
                            return Prefix;
                        })();
    
                        NetworkData.Server = (function() {
    
                            /**
                             * Properties of a Server.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @interface IServer
                             * @property {number|null} [rloc] Server rloc
                             * @property {Uint8Array|null} [data] Server data
                             */
    
                            /**
                             * Constructs a new Server.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @classdesc Represents a Server.
                             * @implements IServer
                             * @constructor
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer=} [properties] Properties to set
                             */
                            function Server(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }
    
                            /**
                             * Server rloc.
                             * @member {number} rloc
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server
                             * @instance
                             */
                            Server.prototype.rloc = 0;
    
                            /**
                             * Server data.
                             * @member {Uint8Array} data
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server
                             * @instance
                             */
                            Server.prototype.data = $util.newBuffer([]);
    
                            /**
                             * Creates a new Server instance using the specified properties.
                             * @function create
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer=} [properties] Properties to set
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server} Server instance
                             */
                            Server.create = function create(properties) {
                                return new Server(properties);
                            };
    
                            /**
                             * Encodes the specified Server message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.verify|verify} messages.
                             * @function encode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer} message Server message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Server.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.rloc != null && Object.hasOwnProperty.call(message, "rloc"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rloc);
                                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                                return writer;
                            };
    
                            /**
                             * Decodes a Server message from the specified reader or buffer.
                             * @function decode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server} Server
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Server.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.rloc = reader.uint32();
                                        break;
                                    case 2:
                                        message.data = reader.bytes();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };
    
                            return Server;
                        })();
    
                        NetworkData.Service = (function() {
    
                            /**
                             * Properties of a Service.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @interface IService
                             * @property {number|null} [sid] Service sid
                             * @property {number|null} [enterpriseNumber] Service enterpriseNumber
                             * @property {Uint8Array|null} [data] Service data
                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer>|null} [servers] Service servers
                             */
    
                            /**
                             * Constructs a new Service.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @classdesc Represents a Service.
                             * @implements IService
                             * @constructor
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService=} [properties] Properties to set
                             */
                            function Service(properties) {
                                this.servers = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }
    
                            /**
                             * Service sid.
                             * @member {number} sid
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service
                             * @instance
                             */
                            Service.prototype.sid = 0;
    
                            /**
                             * Service enterpriseNumber.
                             * @member {number} enterpriseNumber
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service
                             * @instance
                             */
                            Service.prototype.enterpriseNumber = 0;
    
                            /**
                             * Service data.
                             * @member {Uint8Array} data
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service
                             * @instance
                             */
                            Service.prototype.data = $util.newBuffer([]);
    
                            /**
                             * Service servers.
                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer>} servers
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service
                             * @instance
                             */
                            Service.prototype.servers = $util.emptyArray;
    
                            /**
                             * Creates a new Service instance using the specified properties.
                             * @function create
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService=} [properties] Properties to set
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service} Service instance
                             */
                            Service.create = function create(properties) {
                                return new Service(properties);
                            };
    
                            /**
                             * Encodes the specified Service message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.verify|verify} messages.
                             * @function encode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService} message Service message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Service.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.sid != null && Object.hasOwnProperty.call(message, "sid"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sid);
                                if (message.enterpriseNumber != null && Object.hasOwnProperty.call(message, "enterpriseNumber"))
                                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.enterpriseNumber);
                                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                                if (message.servers != null && message.servers.length)
                                    for (var i = 0; i < message.servers.length; ++i)
                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.encode(message.servers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                                return writer;
                            };
    
                            /**
                             * Decodes a Service message from the specified reader or buffer.
                             * @function decode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service} Service
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Service.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.sid = reader.uint32();
                                        break;
                                    case 2:
                                        message.enterpriseNumber = reader.uint32();
                                        break;
                                    case 3:
                                        message.data = reader.bytes();
                                        break;
                                    case 4:
                                        if (!(message.servers && message.servers.length))
                                            message.servers = [];
                                        message.servers.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.decode(reader, reader.uint32()));
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };
    
                            return Service;
                        })();
    
                        NetworkData.Data = (function() {
    
                            /**
                             * Properties of a Data.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @interface IData
                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix>|null} [prefixes] Data prefixes
                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService>|null} [services] Data services
                             */
    
                            /**
                             * Constructs a new Data.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData
                             * @classdesc Represents a Data.
                             * @implements IData
                             * @constructor
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData=} [properties] Properties to set
                             */
                            function Data(properties) {
                                this.prefixes = [];
                                this.services = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }
    
                            /**
                             * Data prefixes.
                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix>} prefixes
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data
                             * @instance
                             */
                            Data.prototype.prefixes = $util.emptyArray;
    
                            /**
                             * Data services.
                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService>} services
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data
                             * @instance
                             */
                            Data.prototype.services = $util.emptyArray;
    
                            /**
                             * Creates a new Data instance using the specified properties.
                             * @function create
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData=} [properties] Properties to set
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data} Data instance
                             */
                            Data.create = function create(properties) {
                                return new Data(properties);
                            };
    
                            /**
                             * Encodes the specified Data message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.verify|verify} messages.
                             * @function encode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData} message Data message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Data.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.prefixes != null && message.prefixes.length)
                                    for (var i = 0; i < message.prefixes.length; ++i)
                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.encode(message.prefixes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.services != null && message.services.length)
                                    for (var i = 0; i < message.services.length; ++i)
                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.encode(message.services[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                                return writer;
                            };
    
                            /**
                             * Decodes a Data message from the specified reader or buffer.
                             * @function decode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data} Data
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Data.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        if (!(message.prefixes && message.prefixes.length))
                                            message.prefixes = [];
                                        message.prefixes.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.decode(reader, reader.uint32()));
                                        break;
                                    case 2:
                                        if (!(message.services && message.services.length))
                                            message.services = [];
                                        message.services.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.decode(reader, reader.uint32()));
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };
    
                            return Data;
                        })();
    
                        return NetworkData;
                    })();
    
                    DiagnosticInfo.MacCounters = (function() {
    
                        /**
                         * Properties of a MacCounters.
                         * @memberof particle.ctrl.mesh.DiagnosticInfo
                         * @interface IMacCounters
                         * @property {number|null} [ifInUnknownProtos] MacCounters ifInUnknownProtos
                         * @property {number|null} [ifInErrors] MacCounters ifInErrors
                         * @property {number|null} [ifOutErrors] MacCounters ifOutErrors
                         * @property {number|null} [ifInUcastPkts] MacCounters ifInUcastPkts
                         * @property {number|null} [ifInBroadcastPkts] MacCounters ifInBroadcastPkts
                         * @property {number|null} [ifInDiscards] MacCounters ifInDiscards
                         * @property {number|null} [ifOutUcastPkts] MacCounters ifOutUcastPkts
                         * @property {number|null} [ifOutBroadcastPkts] MacCounters ifOutBroadcastPkts
                         * @property {number|null} [ifOutDiscards] MacCounters ifOutDiscards
                         */
    
                        /**
                         * Constructs a new MacCounters.
                         * @memberof particle.ctrl.mesh.DiagnosticInfo
                         * @classdesc Represents a MacCounters.
                         * @implements IMacCounters
                         * @constructor
                         * @param {particle.ctrl.mesh.DiagnosticInfo.IMacCounters=} [properties] Properties to set
                         */
                        function MacCounters(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * MacCounters ifInUnknownProtos.
                         * @member {number} ifInUnknownProtos
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters
                         * @instance
                         */
                        MacCounters.prototype.ifInUnknownProtos = 0;
    
                        /**
                         * MacCounters ifInErrors.
                         * @member {number} ifInErrors
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters
                         * @instance
                         */
                        MacCounters.prototype.ifInErrors = 0;
    
                        /**
                         * MacCounters ifOutErrors.
                         * @member {number} ifOutErrors
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters
                         * @instance
                         */
                        MacCounters.prototype.ifOutErrors = 0;
    
                        /**
                         * MacCounters ifInUcastPkts.
                         * @member {number} ifInUcastPkts
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters
                         * @instance
                         */
                        MacCounters.prototype.ifInUcastPkts = 0;
    
                        /**
                         * MacCounters ifInBroadcastPkts.
                         * @member {number} ifInBroadcastPkts
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters
                         * @instance
                         */
                        MacCounters.prototype.ifInBroadcastPkts = 0;
    
                        /**
                         * MacCounters ifInDiscards.
                         * @member {number} ifInDiscards
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters
                         * @instance
                         */
                        MacCounters.prototype.ifInDiscards = 0;
    
                        /**
                         * MacCounters ifOutUcastPkts.
                         * @member {number} ifOutUcastPkts
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters
                         * @instance
                         */
                        MacCounters.prototype.ifOutUcastPkts = 0;
    
                        /**
                         * MacCounters ifOutBroadcastPkts.
                         * @member {number} ifOutBroadcastPkts
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters
                         * @instance
                         */
                        MacCounters.prototype.ifOutBroadcastPkts = 0;
    
                        /**
                         * MacCounters ifOutDiscards.
                         * @member {number} ifOutDiscards
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters
                         * @instance
                         */
                        MacCounters.prototype.ifOutDiscards = 0;
    
                        /**
                         * Creates a new MacCounters instance using the specified properties.
                         * @function create
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters
                         * @static
                         * @param {particle.ctrl.mesh.DiagnosticInfo.IMacCounters=} [properties] Properties to set
                         * @returns {particle.ctrl.mesh.DiagnosticInfo.MacCounters} MacCounters instance
                         */
                        MacCounters.create = function create(properties) {
                            return new MacCounters(properties);
                        };
    
                        /**
                         * Encodes the specified MacCounters message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.MacCounters.verify|verify} messages.
                         * @function encode
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters
                         * @static
                         * @param {particle.ctrl.mesh.DiagnosticInfo.IMacCounters} message MacCounters message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        MacCounters.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.ifInUnknownProtos != null && Object.hasOwnProperty.call(message, "ifInUnknownProtos"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ifInUnknownProtos);
                            if (message.ifInErrors != null && Object.hasOwnProperty.call(message, "ifInErrors"))
                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.ifInErrors);
                            if (message.ifOutErrors != null && Object.hasOwnProperty.call(message, "ifOutErrors"))
                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.ifOutErrors);
                            if (message.ifInUcastPkts != null && Object.hasOwnProperty.call(message, "ifInUcastPkts"))
                                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.ifInUcastPkts);
                            if (message.ifInBroadcastPkts != null && Object.hasOwnProperty.call(message, "ifInBroadcastPkts"))
                                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.ifInBroadcastPkts);
                            if (message.ifInDiscards != null && Object.hasOwnProperty.call(message, "ifInDiscards"))
                                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.ifInDiscards);
                            if (message.ifOutUcastPkts != null && Object.hasOwnProperty.call(message, "ifOutUcastPkts"))
                                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.ifOutUcastPkts);
                            if (message.ifOutBroadcastPkts != null && Object.hasOwnProperty.call(message, "ifOutBroadcastPkts"))
                                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.ifOutBroadcastPkts);
                            if (message.ifOutDiscards != null && Object.hasOwnProperty.call(message, "ifOutDiscards"))
                                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.ifOutDiscards);
                            return writer;
                        };
    
                        /**
                         * Decodes a MacCounters message from the specified reader or buffer.
                         * @function decode
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {particle.ctrl.mesh.DiagnosticInfo.MacCounters} MacCounters
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        MacCounters.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.ifInUnknownProtos = reader.uint32();
                                    break;
                                case 2:
                                    message.ifInErrors = reader.uint32();
                                    break;
                                case 3:
                                    message.ifOutErrors = reader.uint32();
                                    break;
                                case 4:
                                    message.ifInUcastPkts = reader.uint32();
                                    break;
                                case 5:
                                    message.ifInBroadcastPkts = reader.uint32();
                                    break;
                                case 6:
                                    message.ifInDiscards = reader.uint32();
                                    break;
                                case 7:
                                    message.ifOutUcastPkts = reader.uint32();
                                    break;
                                case 8:
                                    message.ifOutBroadcastPkts = reader.uint32();
                                    break;
                                case 9:
                                    message.ifOutDiscards = reader.uint32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        return MacCounters;
                    })();
    
                    DiagnosticInfo.ChildTable = (function() {
    
                        /**
                         * Properties of a ChildTable.
                         * @memberof particle.ctrl.mesh.DiagnosticInfo
                         * @interface IChildTable
                         * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry>|null} [children] ChildTable children
                         */
    
                        /**
                         * Constructs a new ChildTable.
                         * @memberof particle.ctrl.mesh.DiagnosticInfo
                         * @classdesc Represents a ChildTable.
                         * @implements IChildTable
                         * @constructor
                         * @param {particle.ctrl.mesh.DiagnosticInfo.IChildTable=} [properties] Properties to set
                         */
                        function ChildTable(properties) {
                            this.children = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * ChildTable children.
                         * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry>} children
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable
                         * @instance
                         */
                        ChildTable.prototype.children = $util.emptyArray;
    
                        /**
                         * Creates a new ChildTable instance using the specified properties.
                         * @function create
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable
                         * @static
                         * @param {particle.ctrl.mesh.DiagnosticInfo.IChildTable=} [properties] Properties to set
                         * @returns {particle.ctrl.mesh.DiagnosticInfo.ChildTable} ChildTable instance
                         */
                        ChildTable.create = function create(properties) {
                            return new ChildTable(properties);
                        };
    
                        /**
                         * Encodes the specified ChildTable message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.ChildTable.verify|verify} messages.
                         * @function encode
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable
                         * @static
                         * @param {particle.ctrl.mesh.DiagnosticInfo.IChildTable} message ChildTable message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ChildTable.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.children != null && message.children.length)
                                for (var i = 0; i < message.children.length; ++i)
                                    $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.encode(message.children[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };
    
                        /**
                         * Decodes a ChildTable message from the specified reader or buffer.
                         * @function decode
                         * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {particle.ctrl.mesh.DiagnosticInfo.ChildTable} ChildTable
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ChildTable.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    if (!(message.children && message.children.length))
                                        message.children = [];
                                    message.children.push($root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        ChildTable.ChildEntry = (function() {
    
                            /**
                             * Properties of a ChildEntry.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable
                             * @interface IChildEntry
                             * @property {number|null} [timeout] ChildEntry timeout
                             * @property {number|null} [childId] ChildEntry childId
                             * @property {number|null} [mode] ChildEntry mode
                             */
    
                            /**
                             * Constructs a new ChildEntry.
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable
                             * @classdesc Represents a ChildEntry.
                             * @implements IChildEntry
                             * @constructor
                             * @param {particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry=} [properties] Properties to set
                             */
                            function ChildEntry(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }
    
                            /**
                             * ChildEntry timeout.
                             * @member {number} timeout
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry
                             * @instance
                             */
                            ChildEntry.prototype.timeout = 0;
    
                            /**
                             * ChildEntry childId.
                             * @member {number} childId
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry
                             * @instance
                             */
                            ChildEntry.prototype.childId = 0;
    
                            /**
                             * ChildEntry mode.
                             * @member {number} mode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry
                             * @instance
                             */
                            ChildEntry.prototype.mode = 0;
    
                            /**
                             * Creates a new ChildEntry instance using the specified properties.
                             * @function create
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry=} [properties] Properties to set
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry} ChildEntry instance
                             */
                            ChildEntry.create = function create(properties) {
                                return new ChildEntry(properties);
                            };
    
                            /**
                             * Encodes the specified ChildEntry message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.verify|verify} messages.
                             * @function encode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry
                             * @static
                             * @param {particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry} message ChildEntry message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            ChildEntry.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timeout);
                                if (message.childId != null && Object.hasOwnProperty.call(message, "childId"))
                                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.childId);
                                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.mode);
                                return writer;
                            };
    
                            /**
                             * Decodes a ChildEntry message from the specified reader or buffer.
                             * @function decode
                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry} ChildEntry
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            ChildEntry.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.timeout = reader.uint32();
                                        break;
                                    case 2:
                                        message.childId = reader.uint32();
                                        break;
                                    case 3:
                                        message.mode = reader.uint32();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };
    
                            return ChildEntry;
                        })();
    
                        return ChildTable;
                    })();
    
                    return DiagnosticInfo;
                })();
    
                mesh.GetNetworkDiagnosticsRequest = (function() {
    
                    /**
                     * Properties of a GetNetworkDiagnosticsRequest.
                     * @memberof particle.ctrl.mesh
                     * @interface IGetNetworkDiagnosticsRequest
                     * @property {number|null} [flags] GetNetworkDiagnosticsRequest flags
                     * @property {Array.<particle.ctrl.mesh.DiagnosticType>|null} [diagnosticTypes] GetNetworkDiagnosticsRequest diagnosticTypes
                     * @property {number|null} [timeout] GetNetworkDiagnosticsRequest timeout
                     */
    
                    /**
                     * Constructs a new GetNetworkDiagnosticsRequest.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a GetNetworkDiagnosticsRequest.
                     * @implements IGetNetworkDiagnosticsRequest
                     * @constructor
                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsRequest=} [properties] Properties to set
                     */
                    function GetNetworkDiagnosticsRequest(properties) {
                        this.diagnosticTypes = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * GetNetworkDiagnosticsRequest flags.
                     * @member {number} flags
                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest
                     * @instance
                     */
                    GetNetworkDiagnosticsRequest.prototype.flags = 0;
    
                    /**
                     * GetNetworkDiagnosticsRequest diagnosticTypes.
                     * @member {Array.<particle.ctrl.mesh.DiagnosticType>} diagnosticTypes
                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest
                     * @instance
                     */
                    GetNetworkDiagnosticsRequest.prototype.diagnosticTypes = $util.emptyArray;
    
                    /**
                     * GetNetworkDiagnosticsRequest timeout.
                     * @member {number} timeout
                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest
                     * @instance
                     */
                    GetNetworkDiagnosticsRequest.prototype.timeout = 0;
    
                    /**
                     * Creates a new GetNetworkDiagnosticsRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest
                     * @static
                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.GetNetworkDiagnosticsRequest} GetNetworkDiagnosticsRequest instance
                     */
                    GetNetworkDiagnosticsRequest.create = function create(properties) {
                        return new GetNetworkDiagnosticsRequest(properties);
                    };
    
                    /**
                     * Encodes the specified GetNetworkDiagnosticsRequest message. Does not implicitly {@link particle.ctrl.mesh.GetNetworkDiagnosticsRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest
                     * @static
                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsRequest} message GetNetworkDiagnosticsRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetNetworkDiagnosticsRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flags);
                        if (message.diagnosticTypes != null && message.diagnosticTypes.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.diagnosticTypes.length; ++i)
                                writer.int32(message.diagnosticTypes[i]);
                            writer.ldelim();
                        }
                        if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timeout);
                        return writer;
                    };
    
                    /**
                     * Decodes a GetNetworkDiagnosticsRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.GetNetworkDiagnosticsRequest} GetNetworkDiagnosticsRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetNetworkDiagnosticsRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.GetNetworkDiagnosticsRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.flags = reader.uint32();
                                break;
                            case 2:
                                if (!(message.diagnosticTypes && message.diagnosticTypes.length))
                                    message.diagnosticTypes = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.diagnosticTypes.push(reader.int32());
                                } else
                                    message.diagnosticTypes.push(reader.int32());
                                break;
                            case 3:
                                message.timeout = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Flags enum.
                     * @name particle.ctrl.mesh.GetNetworkDiagnosticsRequest.Flags
                     * @enum {number}
                     * @property {number} INVALID=0 INVALID value
                     * @property {number} QUERY_CHILDREN=1 QUERY_CHILDREN value
                     * @property {number} RESOLVE_DEVICE_ID=2 RESOLVE_DEVICE_ID value
                     */
                    GetNetworkDiagnosticsRequest.Flags = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "INVALID"] = 0;
                        values[valuesById[1] = "QUERY_CHILDREN"] = 1;
                        values[valuesById[2] = "RESOLVE_DEVICE_ID"] = 2;
                        return values;
                    })();
    
                    return GetNetworkDiagnosticsRequest;
                })();
    
                mesh.GetNetworkDiagnosticsReply = (function() {
    
                    /**
                     * Properties of a GetNetworkDiagnosticsReply.
                     * @memberof particle.ctrl.mesh
                     * @interface IGetNetworkDiagnosticsReply
                     * @property {Array.<particle.ctrl.mesh.IDiagnosticInfo>|null} [nodes] GetNetworkDiagnosticsReply nodes
                     */
    
                    /**
                     * Constructs a new GetNetworkDiagnosticsReply.
                     * @memberof particle.ctrl.mesh
                     * @classdesc Represents a GetNetworkDiagnosticsReply.
                     * @implements IGetNetworkDiagnosticsReply
                     * @constructor
                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsReply=} [properties] Properties to set
                     */
                    function GetNetworkDiagnosticsReply(properties) {
                        this.nodes = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * GetNetworkDiagnosticsReply nodes.
                     * @member {Array.<particle.ctrl.mesh.IDiagnosticInfo>} nodes
                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsReply
                     * @instance
                     */
                    GetNetworkDiagnosticsReply.prototype.nodes = $util.emptyArray;
    
                    /**
                     * Creates a new GetNetworkDiagnosticsReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsReply
                     * @static
                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsReply=} [properties] Properties to set
                     * @returns {particle.ctrl.mesh.GetNetworkDiagnosticsReply} GetNetworkDiagnosticsReply instance
                     */
                    GetNetworkDiagnosticsReply.create = function create(properties) {
                        return new GetNetworkDiagnosticsReply(properties);
                    };
    
                    /**
                     * Encodes the specified GetNetworkDiagnosticsReply message. Does not implicitly {@link particle.ctrl.mesh.GetNetworkDiagnosticsReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsReply
                     * @static
                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsReply} message GetNetworkDiagnosticsReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetNetworkDiagnosticsReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nodes != null && message.nodes.length)
                            for (var i = 0; i < message.nodes.length; ++i)
                                $root.particle.ctrl.mesh.DiagnosticInfo.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a GetNetworkDiagnosticsReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.mesh.GetNetworkDiagnosticsReply} GetNetworkDiagnosticsReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetNetworkDiagnosticsReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.GetNetworkDiagnosticsReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.nodes && message.nodes.length))
                                    message.nodes = [];
                                message.nodes.push($root.particle.ctrl.mesh.DiagnosticInfo.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetNetworkDiagnosticsReply;
                })();
    
                return mesh;
            })();
    
            ctrl.NetworkGetStatusRequest = (function() {
    
                /**
                 * Properties of a NetworkGetStatusRequest.
                 * @memberof particle.ctrl
                 * @interface INetworkGetStatusRequest
                 * @property {number|null} ["interface"] NetworkGetStatusRequest interface
                 */
    
                /**
                 * Constructs a new NetworkGetStatusRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a NetworkGetStatusRequest.
                 * @implements INetworkGetStatusRequest
                 * @constructor
                 * @param {particle.ctrl.INetworkGetStatusRequest=} [properties] Properties to set
                 */
                function NetworkGetStatusRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NetworkGetStatusRequest interface.
                 * @member {number} interface
                 * @memberof particle.ctrl.NetworkGetStatusRequest
                 * @instance
                 */
                NetworkGetStatusRequest.prototype["interface"] = 0;
    
                /**
                 * Creates a new NetworkGetStatusRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.NetworkGetStatusRequest
                 * @static
                 * @param {particle.ctrl.INetworkGetStatusRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.NetworkGetStatusRequest} NetworkGetStatusRequest instance
                 */
                NetworkGetStatusRequest.create = function create(properties) {
                    return new NetworkGetStatusRequest(properties);
                };
    
                /**
                 * Encodes the specified NetworkGetStatusRequest message. Does not implicitly {@link particle.ctrl.NetworkGetStatusRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.NetworkGetStatusRequest
                 * @static
                 * @param {particle.ctrl.INetworkGetStatusRequest} message NetworkGetStatusRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkGetStatusRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message["interface"] != null && Object.hasOwnProperty.call(message, "interface"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message["interface"]);
                    return writer;
                };
    
                /**
                 * Decodes a NetworkGetStatusRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.NetworkGetStatusRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.NetworkGetStatusRequest} NetworkGetStatusRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkGetStatusRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkGetStatusRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message["interface"] = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return NetworkGetStatusRequest;
            })();
    
            ctrl.NetworkGetStatusReply = (function() {
    
                /**
                 * Properties of a NetworkGetStatusReply.
                 * @memberof particle.ctrl
                 * @interface INetworkGetStatusReply
                 * @property {particle.ctrl.INetworkConfiguration|null} [config] NetworkGetStatusReply config
                 */
    
                /**
                 * Constructs a new NetworkGetStatusReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a NetworkGetStatusReply.
                 * @implements INetworkGetStatusReply
                 * @constructor
                 * @param {particle.ctrl.INetworkGetStatusReply=} [properties] Properties to set
                 */
                function NetworkGetStatusReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NetworkGetStatusReply config.
                 * @member {particle.ctrl.INetworkConfiguration|null|undefined} config
                 * @memberof particle.ctrl.NetworkGetStatusReply
                 * @instance
                 */
                NetworkGetStatusReply.prototype.config = null;
    
                /**
                 * Creates a new NetworkGetStatusReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.NetworkGetStatusReply
                 * @static
                 * @param {particle.ctrl.INetworkGetStatusReply=} [properties] Properties to set
                 * @returns {particle.ctrl.NetworkGetStatusReply} NetworkGetStatusReply instance
                 */
                NetworkGetStatusReply.create = function create(properties) {
                    return new NetworkGetStatusReply(properties);
                };
    
                /**
                 * Encodes the specified NetworkGetStatusReply message. Does not implicitly {@link particle.ctrl.NetworkGetStatusReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.NetworkGetStatusReply
                 * @static
                 * @param {particle.ctrl.INetworkGetStatusReply} message NetworkGetStatusReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkGetStatusReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.config != null && Object.hasOwnProperty.call(message, "config"))
                        $root.particle.ctrl.NetworkConfiguration.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NetworkGetStatusReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.NetworkGetStatusReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.NetworkGetStatusReply} NetworkGetStatusReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkGetStatusReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkGetStatusReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.config = $root.particle.ctrl.NetworkConfiguration.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return NetworkGetStatusReply;
            })();
    
            ctrl.NetworkGetConfigurationRequest = (function() {
    
                /**
                 * Properties of a NetworkGetConfigurationRequest.
                 * @memberof particle.ctrl
                 * @interface INetworkGetConfigurationRequest
                 * @property {number|null} ["interface"] NetworkGetConfigurationRequest interface
                 */
    
                /**
                 * Constructs a new NetworkGetConfigurationRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a NetworkGetConfigurationRequest.
                 * @implements INetworkGetConfigurationRequest
                 * @constructor
                 * @param {particle.ctrl.INetworkGetConfigurationRequest=} [properties] Properties to set
                 */
                function NetworkGetConfigurationRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NetworkGetConfigurationRequest interface.
                 * @member {number} interface
                 * @memberof particle.ctrl.NetworkGetConfigurationRequest
                 * @instance
                 */
                NetworkGetConfigurationRequest.prototype["interface"] = 0;
    
                /**
                 * Creates a new NetworkGetConfigurationRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.NetworkGetConfigurationRequest
                 * @static
                 * @param {particle.ctrl.INetworkGetConfigurationRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.NetworkGetConfigurationRequest} NetworkGetConfigurationRequest instance
                 */
                NetworkGetConfigurationRequest.create = function create(properties) {
                    return new NetworkGetConfigurationRequest(properties);
                };
    
                /**
                 * Encodes the specified NetworkGetConfigurationRequest message. Does not implicitly {@link particle.ctrl.NetworkGetConfigurationRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.NetworkGetConfigurationRequest
                 * @static
                 * @param {particle.ctrl.INetworkGetConfigurationRequest} message NetworkGetConfigurationRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkGetConfigurationRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message["interface"] != null && Object.hasOwnProperty.call(message, "interface"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message["interface"]);
                    return writer;
                };
    
                /**
                 * Decodes a NetworkGetConfigurationRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.NetworkGetConfigurationRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.NetworkGetConfigurationRequest} NetworkGetConfigurationRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkGetConfigurationRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkGetConfigurationRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message["interface"] = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return NetworkGetConfigurationRequest;
            })();
    
            ctrl.NetworkGetConfigurationReply = (function() {
    
                /**
                 * Properties of a NetworkGetConfigurationReply.
                 * @memberof particle.ctrl
                 * @interface INetworkGetConfigurationReply
                 * @property {particle.ctrl.INetworkConfiguration|null} [config] NetworkGetConfigurationReply config
                 */
    
                /**
                 * Constructs a new NetworkGetConfigurationReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a NetworkGetConfigurationReply.
                 * @implements INetworkGetConfigurationReply
                 * @constructor
                 * @param {particle.ctrl.INetworkGetConfigurationReply=} [properties] Properties to set
                 */
                function NetworkGetConfigurationReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NetworkGetConfigurationReply config.
                 * @member {particle.ctrl.INetworkConfiguration|null|undefined} config
                 * @memberof particle.ctrl.NetworkGetConfigurationReply
                 * @instance
                 */
                NetworkGetConfigurationReply.prototype.config = null;
    
                /**
                 * Creates a new NetworkGetConfigurationReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.NetworkGetConfigurationReply
                 * @static
                 * @param {particle.ctrl.INetworkGetConfigurationReply=} [properties] Properties to set
                 * @returns {particle.ctrl.NetworkGetConfigurationReply} NetworkGetConfigurationReply instance
                 */
                NetworkGetConfigurationReply.create = function create(properties) {
                    return new NetworkGetConfigurationReply(properties);
                };
    
                /**
                 * Encodes the specified NetworkGetConfigurationReply message. Does not implicitly {@link particle.ctrl.NetworkGetConfigurationReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.NetworkGetConfigurationReply
                 * @static
                 * @param {particle.ctrl.INetworkGetConfigurationReply} message NetworkGetConfigurationReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkGetConfigurationReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.config != null && Object.hasOwnProperty.call(message, "config"))
                        $root.particle.ctrl.NetworkConfiguration.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NetworkGetConfigurationReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.NetworkGetConfigurationReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.NetworkGetConfigurationReply} NetworkGetConfigurationReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkGetConfigurationReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkGetConfigurationReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.config = $root.particle.ctrl.NetworkConfiguration.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return NetworkGetConfigurationReply;
            })();
    
            ctrl.NetworkSetConfigurationRequest = (function() {
    
                /**
                 * Properties of a NetworkSetConfigurationRequest.
                 * @memberof particle.ctrl
                 * @interface INetworkSetConfigurationRequest
                 * @property {particle.ctrl.INetworkConfiguration|null} [config] NetworkSetConfigurationRequest config
                 */
    
                /**
                 * Constructs a new NetworkSetConfigurationRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a NetworkSetConfigurationRequest.
                 * @implements INetworkSetConfigurationRequest
                 * @constructor
                 * @param {particle.ctrl.INetworkSetConfigurationRequest=} [properties] Properties to set
                 */
                function NetworkSetConfigurationRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NetworkSetConfigurationRequest config.
                 * @member {particle.ctrl.INetworkConfiguration|null|undefined} config
                 * @memberof particle.ctrl.NetworkSetConfigurationRequest
                 * @instance
                 */
                NetworkSetConfigurationRequest.prototype.config = null;
    
                /**
                 * Creates a new NetworkSetConfigurationRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.NetworkSetConfigurationRequest
                 * @static
                 * @param {particle.ctrl.INetworkSetConfigurationRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.NetworkSetConfigurationRequest} NetworkSetConfigurationRequest instance
                 */
                NetworkSetConfigurationRequest.create = function create(properties) {
                    return new NetworkSetConfigurationRequest(properties);
                };
    
                /**
                 * Encodes the specified NetworkSetConfigurationRequest message. Does not implicitly {@link particle.ctrl.NetworkSetConfigurationRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.NetworkSetConfigurationRequest
                 * @static
                 * @param {particle.ctrl.INetworkSetConfigurationRequest} message NetworkSetConfigurationRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkSetConfigurationRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.config != null && Object.hasOwnProperty.call(message, "config"))
                        $root.particle.ctrl.NetworkConfiguration.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NetworkSetConfigurationRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.NetworkSetConfigurationRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.NetworkSetConfigurationRequest} NetworkSetConfigurationRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkSetConfigurationRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkSetConfigurationRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.config = $root.particle.ctrl.NetworkConfiguration.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return NetworkSetConfigurationRequest;
            })();
    
            ctrl.NetworkSetConfigurationReply = (function() {
    
                /**
                 * Properties of a NetworkSetConfigurationReply.
                 * @memberof particle.ctrl
                 * @interface INetworkSetConfigurationReply
                 */
    
                /**
                 * Constructs a new NetworkSetConfigurationReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a NetworkSetConfigurationReply.
                 * @implements INetworkSetConfigurationReply
                 * @constructor
                 * @param {particle.ctrl.INetworkSetConfigurationReply=} [properties] Properties to set
                 */
                function NetworkSetConfigurationReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new NetworkSetConfigurationReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.NetworkSetConfigurationReply
                 * @static
                 * @param {particle.ctrl.INetworkSetConfigurationReply=} [properties] Properties to set
                 * @returns {particle.ctrl.NetworkSetConfigurationReply} NetworkSetConfigurationReply instance
                 */
                NetworkSetConfigurationReply.create = function create(properties) {
                    return new NetworkSetConfigurationReply(properties);
                };
    
                /**
                 * Encodes the specified NetworkSetConfigurationReply message. Does not implicitly {@link particle.ctrl.NetworkSetConfigurationReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.NetworkSetConfigurationReply
                 * @static
                 * @param {particle.ctrl.INetworkSetConfigurationReply} message NetworkSetConfigurationReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkSetConfigurationReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a NetworkSetConfigurationReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.NetworkSetConfigurationReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.NetworkSetConfigurationReply} NetworkSetConfigurationReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkSetConfigurationReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkSetConfigurationReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return NetworkSetConfigurationReply;
            })();
    
            /**
             * NetworkState enum.
             * @name particle.ctrl.NetworkState
             * @enum {number}
             * @property {number} NETWORK_STATUS_NONE=0 NETWORK_STATUS_NONE value
             * @property {number} DOWN=1 DOWN value
             * @property {number} UP=2 UP value
             */
            ctrl.NetworkState = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NETWORK_STATUS_NONE"] = 0;
                values[valuesById[1] = "DOWN"] = 1;
                values[valuesById[2] = "UP"] = 2;
                return values;
            })();
    
            ctrl.IPConfiguration = (function() {
    
                /**
                 * Properties of a IPConfiguration.
                 * @memberof particle.ctrl
                 * @interface IIPConfiguration
                 * @property {particle.ctrl.IPConfiguration.Type|null} [type] IPConfiguration type
                 * @property {particle.ctrl.IIPAddress|null} [address] IPConfiguration address
                 * @property {particle.ctrl.IIPAddress|null} [netmask] IPConfiguration netmask
                 * @property {particle.ctrl.IIPAddress|null} [gateway] IPConfiguration gateway
                 * @property {particle.ctrl.IIPAddress|null} [dhcpServer] IPConfiguration dhcpServer
                 * @property {string|null} [hostname] IPConfiguration hostname
                 */
    
                /**
                 * Constructs a new IPConfiguration.
                 * @memberof particle.ctrl
                 * @classdesc Represents a IPConfiguration.
                 * @implements IIPConfiguration
                 * @constructor
                 * @param {particle.ctrl.IIPConfiguration=} [properties] Properties to set
                 */
                function IPConfiguration(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * IPConfiguration type.
                 * @member {particle.ctrl.IPConfiguration.Type} type
                 * @memberof particle.ctrl.IPConfiguration
                 * @instance
                 */
                IPConfiguration.prototype.type = 0;
    
                /**
                 * IPConfiguration address.
                 * @member {particle.ctrl.IIPAddress|null|undefined} address
                 * @memberof particle.ctrl.IPConfiguration
                 * @instance
                 */
                IPConfiguration.prototype.address = null;
    
                /**
                 * IPConfiguration netmask.
                 * @member {particle.ctrl.IIPAddress|null|undefined} netmask
                 * @memberof particle.ctrl.IPConfiguration
                 * @instance
                 */
                IPConfiguration.prototype.netmask = null;
    
                /**
                 * IPConfiguration gateway.
                 * @member {particle.ctrl.IIPAddress|null|undefined} gateway
                 * @memberof particle.ctrl.IPConfiguration
                 * @instance
                 */
                IPConfiguration.prototype.gateway = null;
    
                /**
                 * IPConfiguration dhcpServer.
                 * @member {particle.ctrl.IIPAddress|null|undefined} dhcpServer
                 * @memberof particle.ctrl.IPConfiguration
                 * @instance
                 */
                IPConfiguration.prototype.dhcpServer = null;
    
                /**
                 * IPConfiguration hostname.
                 * @member {string} hostname
                 * @memberof particle.ctrl.IPConfiguration
                 * @instance
                 */
                IPConfiguration.prototype.hostname = "";
    
                /**
                 * Creates a new IPConfiguration instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.IPConfiguration
                 * @static
                 * @param {particle.ctrl.IIPConfiguration=} [properties] Properties to set
                 * @returns {particle.ctrl.IPConfiguration} IPConfiguration instance
                 */
                IPConfiguration.create = function create(properties) {
                    return new IPConfiguration(properties);
                };
    
                /**
                 * Encodes the specified IPConfiguration message. Does not implicitly {@link particle.ctrl.IPConfiguration.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.IPConfiguration
                 * @static
                 * @param {particle.ctrl.IIPConfiguration} message IPConfiguration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IPConfiguration.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        $root.particle.ctrl.IPAddress.encode(message.address, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.netmask != null && Object.hasOwnProperty.call(message, "netmask"))
                        $root.particle.ctrl.IPAddress.encode(message.netmask, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.gateway != null && Object.hasOwnProperty.call(message, "gateway"))
                        $root.particle.ctrl.IPAddress.encode(message.gateway, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.dhcpServer != null && Object.hasOwnProperty.call(message, "dhcpServer"))
                        $root.particle.ctrl.IPAddress.encode(message.dhcpServer, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.hostname);
                    return writer;
                };
    
                /**
                 * Decodes a IPConfiguration message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.IPConfiguration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.IPConfiguration} IPConfiguration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IPConfiguration.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IPConfiguration();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.address = $root.particle.ctrl.IPAddress.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.netmask = $root.particle.ctrl.IPAddress.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.gateway = $root.particle.ctrl.IPAddress.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.dhcpServer = $root.particle.ctrl.IPAddress.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.hostname = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Type enum.
                 * @name particle.ctrl.IPConfiguration.Type
                 * @enum {number}
                 * @property {number} NONE=0 NONE value
                 * @property {number} DHCP=1 DHCP value
                 * @property {number} STATIC=2 STATIC value
                 */
                IPConfiguration.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NONE"] = 0;
                    values[valuesById[1] = "DHCP"] = 1;
                    values[valuesById[2] = "STATIC"] = 2;
                    return values;
                })();
    
                return IPConfiguration;
            })();
    
            ctrl.DNSConfiguration = (function() {
    
                /**
                 * Properties of a DNSConfiguration.
                 * @memberof particle.ctrl
                 * @interface IDNSConfiguration
                 * @property {Array.<particle.ctrl.IIPAddress>|null} [servers] DNSConfiguration servers
                 */
    
                /**
                 * Constructs a new DNSConfiguration.
                 * @memberof particle.ctrl
                 * @classdesc Represents a DNSConfiguration.
                 * @implements IDNSConfiguration
                 * @constructor
                 * @param {particle.ctrl.IDNSConfiguration=} [properties] Properties to set
                 */
                function DNSConfiguration(properties) {
                    this.servers = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DNSConfiguration servers.
                 * @member {Array.<particle.ctrl.IIPAddress>} servers
                 * @memberof particle.ctrl.DNSConfiguration
                 * @instance
                 */
                DNSConfiguration.prototype.servers = $util.emptyArray;
    
                /**
                 * Creates a new DNSConfiguration instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.DNSConfiguration
                 * @static
                 * @param {particle.ctrl.IDNSConfiguration=} [properties] Properties to set
                 * @returns {particle.ctrl.DNSConfiguration} DNSConfiguration instance
                 */
                DNSConfiguration.create = function create(properties) {
                    return new DNSConfiguration(properties);
                };
    
                /**
                 * Encodes the specified DNSConfiguration message. Does not implicitly {@link particle.ctrl.DNSConfiguration.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.DNSConfiguration
                 * @static
                 * @param {particle.ctrl.IDNSConfiguration} message DNSConfiguration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DNSConfiguration.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.servers != null && message.servers.length)
                        for (var i = 0; i < message.servers.length; ++i)
                            $root.particle.ctrl.IPAddress.encode(message.servers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a DNSConfiguration message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.DNSConfiguration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.DNSConfiguration} DNSConfiguration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DNSConfiguration.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DNSConfiguration();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.servers && message.servers.length))
                                message.servers = [];
                            message.servers.push($root.particle.ctrl.IPAddress.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return DNSConfiguration;
            })();
    
            ctrl.NetworkConfiguration = (function() {
    
                /**
                 * Properties of a NetworkConfiguration.
                 * @memberof particle.ctrl
                 * @interface INetworkConfiguration
                 * @property {number|null} ["interface"] NetworkConfiguration interface
                 * @property {particle.ctrl.NetworkState|null} [state] NetworkConfiguration state
                 * @property {string|null} [name] NetworkConfiguration name
                 * @property {Uint8Array|null} [mac] NetworkConfiguration mac
                 * @property {particle.ctrl.IIPConfiguration|null} [ipconfig] NetworkConfiguration ipconfig
                 * @property {particle.ctrl.IDNSConfiguration|null} [dnsconfig] NetworkConfiguration dnsconfig
                 */
    
                /**
                 * Constructs a new NetworkConfiguration.
                 * @memberof particle.ctrl
                 * @classdesc Represents a NetworkConfiguration.
                 * @implements INetworkConfiguration
                 * @constructor
                 * @param {particle.ctrl.INetworkConfiguration=} [properties] Properties to set
                 */
                function NetworkConfiguration(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NetworkConfiguration interface.
                 * @member {number} interface
                 * @memberof particle.ctrl.NetworkConfiguration
                 * @instance
                 */
                NetworkConfiguration.prototype["interface"] = 0;
    
                /**
                 * NetworkConfiguration state.
                 * @member {particle.ctrl.NetworkState} state
                 * @memberof particle.ctrl.NetworkConfiguration
                 * @instance
                 */
                NetworkConfiguration.prototype.state = 0;
    
                /**
                 * NetworkConfiguration name.
                 * @member {string} name
                 * @memberof particle.ctrl.NetworkConfiguration
                 * @instance
                 */
                NetworkConfiguration.prototype.name = "";
    
                /**
                 * NetworkConfiguration mac.
                 * @member {Uint8Array} mac
                 * @memberof particle.ctrl.NetworkConfiguration
                 * @instance
                 */
                NetworkConfiguration.prototype.mac = $util.newBuffer([]);
    
                /**
                 * NetworkConfiguration ipconfig.
                 * @member {particle.ctrl.IIPConfiguration|null|undefined} ipconfig
                 * @memberof particle.ctrl.NetworkConfiguration
                 * @instance
                 */
                NetworkConfiguration.prototype.ipconfig = null;
    
                /**
                 * NetworkConfiguration dnsconfig.
                 * @member {particle.ctrl.IDNSConfiguration|null|undefined} dnsconfig
                 * @memberof particle.ctrl.NetworkConfiguration
                 * @instance
                 */
                NetworkConfiguration.prototype.dnsconfig = null;
    
                /**
                 * Creates a new NetworkConfiguration instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.NetworkConfiguration
                 * @static
                 * @param {particle.ctrl.INetworkConfiguration=} [properties] Properties to set
                 * @returns {particle.ctrl.NetworkConfiguration} NetworkConfiguration instance
                 */
                NetworkConfiguration.create = function create(properties) {
                    return new NetworkConfiguration(properties);
                };
    
                /**
                 * Encodes the specified NetworkConfiguration message. Does not implicitly {@link particle.ctrl.NetworkConfiguration.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.NetworkConfiguration
                 * @static
                 * @param {particle.ctrl.INetworkConfiguration} message NetworkConfiguration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkConfiguration.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message["interface"] != null && Object.hasOwnProperty.call(message, "interface"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message["interface"]);
                    if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.mac != null && Object.hasOwnProperty.call(message, "mac"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.mac);
                    if (message.ipconfig != null && Object.hasOwnProperty.call(message, "ipconfig"))
                        $root.particle.ctrl.IPConfiguration.encode(message.ipconfig, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.dnsconfig != null && Object.hasOwnProperty.call(message, "dnsconfig"))
                        $root.particle.ctrl.DNSConfiguration.encode(message.dnsconfig, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a NetworkConfiguration message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.NetworkConfiguration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.NetworkConfiguration} NetworkConfiguration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkConfiguration.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkConfiguration();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message["interface"] = reader.int32();
                            break;
                        case 2:
                            message.state = reader.int32();
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        case 4:
                            message.mac = reader.bytes();
                            break;
                        case 5:
                            message.ipconfig = $root.particle.ctrl.IPConfiguration.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.dnsconfig = $root.particle.ctrl.DNSConfiguration.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return NetworkConfiguration;
            })();
    
            /**
             * InterfaceConfigurationSource enum.
             * @name particle.ctrl.InterfaceConfigurationSource
             * @enum {number}
             * @property {number} NONE=0 NONE value
             * @property {number} DHCP=1 DHCP value
             * @property {number} STATIC=2 STATIC value
             * @property {number} SLAAC=3 SLAAC value
             * @property {number} DHCPV6=4 DHCPV6 value
             */
            ctrl.InterfaceConfigurationSource = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NONE"] = 0;
                values[valuesById[1] = "DHCP"] = 1;
                values[valuesById[2] = "STATIC"] = 2;
                values[valuesById[3] = "SLAAC"] = 3;
                values[valuesById[4] = "DHCPV6"] = 4;
                return values;
            })();
    
            ctrl.InterfaceAddress = (function() {
    
                /**
                 * Properties of an InterfaceAddress.
                 * @memberof particle.ctrl
                 * @interface IInterfaceAddress
                 * @property {particle.ctrl.IIpAddress|null} [address] InterfaceAddress address
                 * @property {number|null} [prefixLength] InterfaceAddress prefixLength
                 */
    
                /**
                 * Constructs a new InterfaceAddress.
                 * @memberof particle.ctrl
                 * @classdesc Represents an InterfaceAddress.
                 * @implements IInterfaceAddress
                 * @constructor
                 * @param {particle.ctrl.IInterfaceAddress=} [properties] Properties to set
                 */
                function InterfaceAddress(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InterfaceAddress address.
                 * @member {particle.ctrl.IIpAddress|null|undefined} address
                 * @memberof particle.ctrl.InterfaceAddress
                 * @instance
                 */
                InterfaceAddress.prototype.address = null;
    
                /**
                 * InterfaceAddress prefixLength.
                 * @member {number} prefixLength
                 * @memberof particle.ctrl.InterfaceAddress
                 * @instance
                 */
                InterfaceAddress.prototype.prefixLength = 0;
    
                /**
                 * Creates a new InterfaceAddress instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.InterfaceAddress
                 * @static
                 * @param {particle.ctrl.IInterfaceAddress=} [properties] Properties to set
                 * @returns {particle.ctrl.InterfaceAddress} InterfaceAddress instance
                 */
                InterfaceAddress.create = function create(properties) {
                    return new InterfaceAddress(properties);
                };
    
                /**
                 * Encodes the specified InterfaceAddress message. Does not implicitly {@link particle.ctrl.InterfaceAddress.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.InterfaceAddress
                 * @static
                 * @param {particle.ctrl.IInterfaceAddress} message InterfaceAddress message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InterfaceAddress.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                        $root.particle.ctrl.IpAddress.encode(message.address, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.prefixLength != null && Object.hasOwnProperty.call(message, "prefixLength"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.prefixLength);
                    return writer;
                };
    
                /**
                 * Decodes an InterfaceAddress message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.InterfaceAddress
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.InterfaceAddress} InterfaceAddress
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InterfaceAddress.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.InterfaceAddress();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.address = $root.particle.ctrl.IpAddress.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.prefixLength = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return InterfaceAddress;
            })();
    
            ctrl.Ipv4Config = (function() {
    
                /**
                 * Properties of an Ipv4Config.
                 * @memberof particle.ctrl
                 * @interface IIpv4Config
                 * @property {Array.<particle.ctrl.IInterfaceAddress>|null} [addresses] Ipv4Config addresses
                 * @property {particle.ctrl.IIpv4Address|null} [peer] Ipv4Config peer
                 * @property {particle.ctrl.IIpv4Address|null} [gateway] Ipv4Config gateway
                 * @property {Array.<particle.ctrl.IIpv4Address>|null} [dns] Ipv4Config dns
                 * @property {particle.ctrl.InterfaceConfigurationSource|null} [source] Ipv4Config source
                 */
    
                /**
                 * Constructs a new Ipv4Config.
                 * @memberof particle.ctrl
                 * @classdesc Represents an Ipv4Config.
                 * @implements IIpv4Config
                 * @constructor
                 * @param {particle.ctrl.IIpv4Config=} [properties] Properties to set
                 */
                function Ipv4Config(properties) {
                    this.addresses = [];
                    this.dns = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Ipv4Config addresses.
                 * @member {Array.<particle.ctrl.IInterfaceAddress>} addresses
                 * @memberof particle.ctrl.Ipv4Config
                 * @instance
                 */
                Ipv4Config.prototype.addresses = $util.emptyArray;
    
                /**
                 * Ipv4Config peer.
                 * @member {particle.ctrl.IIpv4Address|null|undefined} peer
                 * @memberof particle.ctrl.Ipv4Config
                 * @instance
                 */
                Ipv4Config.prototype.peer = null;
    
                /**
                 * Ipv4Config gateway.
                 * @member {particle.ctrl.IIpv4Address|null|undefined} gateway
                 * @memberof particle.ctrl.Ipv4Config
                 * @instance
                 */
                Ipv4Config.prototype.gateway = null;
    
                /**
                 * Ipv4Config dns.
                 * @member {Array.<particle.ctrl.IIpv4Address>} dns
                 * @memberof particle.ctrl.Ipv4Config
                 * @instance
                 */
                Ipv4Config.prototype.dns = $util.emptyArray;
    
                /**
                 * Ipv4Config source.
                 * @member {particle.ctrl.InterfaceConfigurationSource} source
                 * @memberof particle.ctrl.Ipv4Config
                 * @instance
                 */
                Ipv4Config.prototype.source = 0;
    
                /**
                 * Creates a new Ipv4Config instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.Ipv4Config
                 * @static
                 * @param {particle.ctrl.IIpv4Config=} [properties] Properties to set
                 * @returns {particle.ctrl.Ipv4Config} Ipv4Config instance
                 */
                Ipv4Config.create = function create(properties) {
                    return new Ipv4Config(properties);
                };
    
                /**
                 * Encodes the specified Ipv4Config message. Does not implicitly {@link particle.ctrl.Ipv4Config.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.Ipv4Config
                 * @static
                 * @param {particle.ctrl.IIpv4Config} message Ipv4Config message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ipv4Config.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.addresses != null && message.addresses.length)
                        for (var i = 0; i < message.addresses.length; ++i)
                            $root.particle.ctrl.InterfaceAddress.encode(message.addresses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
                        $root.particle.ctrl.Ipv4Address.encode(message.peer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.gateway != null && Object.hasOwnProperty.call(message, "gateway"))
                        $root.particle.ctrl.Ipv4Address.encode(message.gateway, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.dns != null && message.dns.length)
                        for (var i = 0; i < message.dns.length; ++i)
                            $root.particle.ctrl.Ipv4Address.encode(message.dns[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.source);
                    return writer;
                };
    
                /**
                 * Decodes an Ipv4Config message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.Ipv4Config
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.Ipv4Config} Ipv4Config
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ipv4Config.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Ipv4Config();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.addresses && message.addresses.length))
                                message.addresses = [];
                            message.addresses.push($root.particle.ctrl.InterfaceAddress.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.peer = $root.particle.ctrl.Ipv4Address.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.gateway = $root.particle.ctrl.Ipv4Address.decode(reader, reader.uint32());
                            break;
                        case 4:
                            if (!(message.dns && message.dns.length))
                                message.dns = [];
                            message.dns.push($root.particle.ctrl.Ipv4Address.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            message.source = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return Ipv4Config;
            })();
    
            ctrl.Ipv6Config = (function() {
    
                /**
                 * Properties of an Ipv6Config.
                 * @memberof particle.ctrl
                 * @interface IIpv6Config
                 * @property {Array.<particle.ctrl.IInterfaceAddress>|null} [addresses] Ipv6Config addresses
                 * @property {Array.<particle.ctrl.IIpv6Address>|null} [dns] Ipv6Config dns
                 * @property {particle.ctrl.InterfaceConfigurationSource|null} [source] Ipv6Config source
                 * @property {particle.ctrl.IIpv6Address|null} [gateway] Ipv6Config gateway
                 */
    
                /**
                 * Constructs a new Ipv6Config.
                 * @memberof particle.ctrl
                 * @classdesc Represents an Ipv6Config.
                 * @implements IIpv6Config
                 * @constructor
                 * @param {particle.ctrl.IIpv6Config=} [properties] Properties to set
                 */
                function Ipv6Config(properties) {
                    this.addresses = [];
                    this.dns = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Ipv6Config addresses.
                 * @member {Array.<particle.ctrl.IInterfaceAddress>} addresses
                 * @memberof particle.ctrl.Ipv6Config
                 * @instance
                 */
                Ipv6Config.prototype.addresses = $util.emptyArray;
    
                /**
                 * Ipv6Config dns.
                 * @member {Array.<particle.ctrl.IIpv6Address>} dns
                 * @memberof particle.ctrl.Ipv6Config
                 * @instance
                 */
                Ipv6Config.prototype.dns = $util.emptyArray;
    
                /**
                 * Ipv6Config source.
                 * @member {particle.ctrl.InterfaceConfigurationSource} source
                 * @memberof particle.ctrl.Ipv6Config
                 * @instance
                 */
                Ipv6Config.prototype.source = 0;
    
                /**
                 * Ipv6Config gateway.
                 * @member {particle.ctrl.IIpv6Address|null|undefined} gateway
                 * @memberof particle.ctrl.Ipv6Config
                 * @instance
                 */
                Ipv6Config.prototype.gateway = null;
    
                /**
                 * Creates a new Ipv6Config instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.Ipv6Config
                 * @static
                 * @param {particle.ctrl.IIpv6Config=} [properties] Properties to set
                 * @returns {particle.ctrl.Ipv6Config} Ipv6Config instance
                 */
                Ipv6Config.create = function create(properties) {
                    return new Ipv6Config(properties);
                };
    
                /**
                 * Encodes the specified Ipv6Config message. Does not implicitly {@link particle.ctrl.Ipv6Config.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.Ipv6Config
                 * @static
                 * @param {particle.ctrl.IIpv6Config} message Ipv6Config message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ipv6Config.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.addresses != null && message.addresses.length)
                        for (var i = 0; i < message.addresses.length; ++i)
                            $root.particle.ctrl.InterfaceAddress.encode(message.addresses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.dns != null && message.dns.length)
                        for (var i = 0; i < message.dns.length; ++i)
                            $root.particle.ctrl.Ipv6Address.encode(message.dns[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.source);
                    if (message.gateway != null && Object.hasOwnProperty.call(message, "gateway"))
                        $root.particle.ctrl.Ipv6Address.encode(message.gateway, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an Ipv6Config message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.Ipv6Config
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.Ipv6Config} Ipv6Config
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ipv6Config.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Ipv6Config();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.addresses && message.addresses.length))
                                message.addresses = [];
                            message.addresses.push($root.particle.ctrl.InterfaceAddress.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.dns && message.dns.length))
                                message.dns = [];
                            message.dns.push($root.particle.ctrl.Ipv6Address.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.source = reader.int32();
                            break;
                        case 4:
                            message.gateway = $root.particle.ctrl.Ipv6Address.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return Ipv6Config;
            })();
    
            /**
             * InterfaceFlag enum.
             * @name particle.ctrl.InterfaceFlag
             * @enum {number}
             * @property {number} IFF_NONE=0 IFF_NONE value
             * @property {number} IFF_UP=1 IFF_UP value
             * @property {number} IFF_BROADCAST=2 IFF_BROADCAST value
             * @property {number} IFF_DEBUG=4 IFF_DEBUG value
             * @property {number} IFF_LOOPBACK=8 IFF_LOOPBACK value
             * @property {number} IFF_POINTTOPOINT=16 IFF_POINTTOPOINT value
             * @property {number} IFF_RUNNING=64 IFF_RUNNING value
             * @property {number} IFF_LOWER_UP=64 IFF_LOWER_UP value
             * @property {number} IFF_NOARP=128 IFF_NOARP value
             * @property {number} IFF_PROMISC=256 IFF_PROMISC value
             * @property {number} IFF_ALLMULTI=512 IFF_ALLMULTI value
             * @property {number} IFF_MULTICAST=32768 IFF_MULTICAST value
             * @property {number} IFF_NOND6=65536 IFF_NOND6 value
             */
            ctrl.InterfaceFlag = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "IFF_NONE"] = 0;
                values[valuesById[1] = "IFF_UP"] = 1;
                values[valuesById[2] = "IFF_BROADCAST"] = 2;
                values[valuesById[4] = "IFF_DEBUG"] = 4;
                values[valuesById[8] = "IFF_LOOPBACK"] = 8;
                values[valuesById[16] = "IFF_POINTTOPOINT"] = 16;
                values[valuesById[64] = "IFF_RUNNING"] = 64;
                values["IFF_LOWER_UP"] = 64;
                values[valuesById[128] = "IFF_NOARP"] = 128;
                values[valuesById[256] = "IFF_PROMISC"] = 256;
                values[valuesById[512] = "IFF_ALLMULTI"] = 512;
                values[valuesById[32768] = "IFF_MULTICAST"] = 32768;
                values[valuesById[65536] = "IFF_NOND6"] = 65536;
                return values;
            })();
    
            /**
             * InterfaceExtFlag enum.
             * @name particle.ctrl.InterfaceExtFlag
             * @enum {number}
             * @property {number} IFXF_NONE=0 IFXF_NONE value
             * @property {number} IFXF_WOL=16 IFXF_WOL value
             * @property {number} IFXF_AUTOCONF6=32 IFXF_AUTOCONF6 value
             * @property {number} IFXF_DHCP=65536 IFXF_DHCP value
             * @property {number} IFXF_DHCP6=131072 IFXF_DHCP6 value
             * @property {number} IFXF_AUTOIP=262144 IFXF_AUTOIP value
             */
            ctrl.InterfaceExtFlag = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "IFXF_NONE"] = 0;
                values[valuesById[16] = "IFXF_WOL"] = 16;
                values[valuesById[32] = "IFXF_AUTOCONF6"] = 32;
                values[valuesById[65536] = "IFXF_DHCP"] = 65536;
                values[valuesById[131072] = "IFXF_DHCP6"] = 131072;
                values[valuesById[262144] = "IFXF_AUTOIP"] = 262144;
                return values;
            })();
    
            /**
             * InterfaceType enum.
             * @name particle.ctrl.InterfaceType
             * @enum {number}
             * @property {number} INVALID_INTERFACE_TYPE=0 INVALID_INTERFACE_TYPE value
             * @property {number} LOOPBACK=1 LOOPBACK value
             * @property {number} THREAD=2 THREAD value
             * @property {number} ETHERNET=4 ETHERNET value
             * @property {number} WIFI=8 WIFI value
             * @property {number} PPP=16 PPP value
             */
            ctrl.InterfaceType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INVALID_INTERFACE_TYPE"] = 0;
                values[valuesById[1] = "LOOPBACK"] = 1;
                values[valuesById[2] = "THREAD"] = 2;
                values[valuesById[4] = "ETHERNET"] = 4;
                values[valuesById[8] = "WIFI"] = 8;
                values[valuesById[16] = "PPP"] = 16;
                return values;
            })();
    
            ctrl.Interface = (function() {
    
                /**
                 * Properties of an Interface.
                 * @memberof particle.ctrl
                 * @interface IInterface
                 * @property {number|null} [index] Interface index
                 * @property {string|null} [name] Interface name
                 * @property {particle.ctrl.InterfaceType|null} [type] Interface type
                 * @property {number|null} [flags] Interface flags
                 * @property {number|null} [extFlags] Interface extFlags
                 * @property {particle.ctrl.IIpv4Config|null} [ipv4Config] Interface ipv4Config
                 * @property {particle.ctrl.IIpv6Config|null} [ipv6Config] Interface ipv6Config
                 * @property {Uint8Array|null} [hwAddress] Interface hwAddress
                 * @property {number|null} [mtu] Interface mtu
                 * @property {number|null} [metric] Interface metric
                 * @property {Uint8Array|null} [profile] Interface profile
                 */
    
                /**
                 * Constructs a new Interface.
                 * @memberof particle.ctrl
                 * @classdesc Represents an Interface.
                 * @implements IInterface
                 * @constructor
                 * @param {particle.ctrl.IInterface=} [properties] Properties to set
                 */
                function Interface(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Interface index.
                 * @member {number} index
                 * @memberof particle.ctrl.Interface
                 * @instance
                 */
                Interface.prototype.index = 0;
    
                /**
                 * Interface name.
                 * @member {string} name
                 * @memberof particle.ctrl.Interface
                 * @instance
                 */
                Interface.prototype.name = "";
    
                /**
                 * Interface type.
                 * @member {particle.ctrl.InterfaceType} type
                 * @memberof particle.ctrl.Interface
                 * @instance
                 */
                Interface.prototype.type = 0;
    
                /**
                 * Interface flags.
                 * @member {number} flags
                 * @memberof particle.ctrl.Interface
                 * @instance
                 */
                Interface.prototype.flags = 0;
    
                /**
                 * Interface extFlags.
                 * @member {number} extFlags
                 * @memberof particle.ctrl.Interface
                 * @instance
                 */
                Interface.prototype.extFlags = 0;
    
                /**
                 * Interface ipv4Config.
                 * @member {particle.ctrl.IIpv4Config|null|undefined} ipv4Config
                 * @memberof particle.ctrl.Interface
                 * @instance
                 */
                Interface.prototype.ipv4Config = null;
    
                /**
                 * Interface ipv6Config.
                 * @member {particle.ctrl.IIpv6Config|null|undefined} ipv6Config
                 * @memberof particle.ctrl.Interface
                 * @instance
                 */
                Interface.prototype.ipv6Config = null;
    
                /**
                 * Interface hwAddress.
                 * @member {Uint8Array} hwAddress
                 * @memberof particle.ctrl.Interface
                 * @instance
                 */
                Interface.prototype.hwAddress = $util.newBuffer([]);
    
                /**
                 * Interface mtu.
                 * @member {number} mtu
                 * @memberof particle.ctrl.Interface
                 * @instance
                 */
                Interface.prototype.mtu = 0;
    
                /**
                 * Interface metric.
                 * @member {number} metric
                 * @memberof particle.ctrl.Interface
                 * @instance
                 */
                Interface.prototype.metric = 0;
    
                /**
                 * Interface profile.
                 * @member {Uint8Array} profile
                 * @memberof particle.ctrl.Interface
                 * @instance
                 */
                Interface.prototype.profile = $util.newBuffer([]);
    
                /**
                 * Creates a new Interface instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.Interface
                 * @static
                 * @param {particle.ctrl.IInterface=} [properties] Properties to set
                 * @returns {particle.ctrl.Interface} Interface instance
                 */
                Interface.create = function create(properties) {
                    return new Interface(properties);
                };
    
                /**
                 * Encodes the specified Interface message. Does not implicitly {@link particle.ctrl.Interface.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.Interface
                 * @static
                 * @param {particle.ctrl.IInterface} message Interface message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Interface.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                    if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.flags);
                    if (message.extFlags != null && Object.hasOwnProperty.call(message, "extFlags"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.extFlags);
                    if (message.ipv4Config != null && Object.hasOwnProperty.call(message, "ipv4Config"))
                        $root.particle.ctrl.Ipv4Config.encode(message.ipv4Config, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.ipv6Config != null && Object.hasOwnProperty.call(message, "ipv6Config"))
                        $root.particle.ctrl.Ipv6Config.encode(message.ipv6Config, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.hwAddress != null && Object.hasOwnProperty.call(message, "hwAddress"))
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.hwAddress);
                    if (message.mtu != null && Object.hasOwnProperty.call(message, "mtu"))
                        writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.mtu);
                    if (message.metric != null && Object.hasOwnProperty.call(message, "metric"))
                        writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.metric);
                    if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.profile);
                    return writer;
                };
    
                /**
                 * Decodes an Interface message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.Interface
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.Interface} Interface
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Interface.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Interface();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.index = reader.uint32();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.type = reader.int32();
                            break;
                        case 4:
                            message.flags = reader.uint32();
                            break;
                        case 5:
                            message.extFlags = reader.uint32();
                            break;
                        case 6:
                            message.ipv4Config = $root.particle.ctrl.Ipv4Config.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.ipv6Config = $root.particle.ctrl.Ipv6Config.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.hwAddress = reader.bytes();
                            break;
                        case 9:
                            message.mtu = reader.uint32();
                            break;
                        case 10:
                            message.metric = reader.uint32();
                            break;
                        case 11:
                            message.profile = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return Interface;
            })();
    
            ctrl.InterfaceEntry = (function() {
    
                /**
                 * Properties of an InterfaceEntry.
                 * @memberof particle.ctrl
                 * @interface IInterfaceEntry
                 * @property {number|null} [index] InterfaceEntry index
                 * @property {string|null} [name] InterfaceEntry name
                 * @property {particle.ctrl.InterfaceType|null} [type] InterfaceEntry type
                 */
    
                /**
                 * Constructs a new InterfaceEntry.
                 * @memberof particle.ctrl
                 * @classdesc Represents an InterfaceEntry.
                 * @implements IInterfaceEntry
                 * @constructor
                 * @param {particle.ctrl.IInterfaceEntry=} [properties] Properties to set
                 */
                function InterfaceEntry(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InterfaceEntry index.
                 * @member {number} index
                 * @memberof particle.ctrl.InterfaceEntry
                 * @instance
                 */
                InterfaceEntry.prototype.index = 0;
    
                /**
                 * InterfaceEntry name.
                 * @member {string} name
                 * @memberof particle.ctrl.InterfaceEntry
                 * @instance
                 */
                InterfaceEntry.prototype.name = "";
    
                /**
                 * InterfaceEntry type.
                 * @member {particle.ctrl.InterfaceType} type
                 * @memberof particle.ctrl.InterfaceEntry
                 * @instance
                 */
                InterfaceEntry.prototype.type = 0;
    
                /**
                 * Creates a new InterfaceEntry instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.InterfaceEntry
                 * @static
                 * @param {particle.ctrl.IInterfaceEntry=} [properties] Properties to set
                 * @returns {particle.ctrl.InterfaceEntry} InterfaceEntry instance
                 */
                InterfaceEntry.create = function create(properties) {
                    return new InterfaceEntry(properties);
                };
    
                /**
                 * Encodes the specified InterfaceEntry message. Does not implicitly {@link particle.ctrl.InterfaceEntry.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.InterfaceEntry
                 * @static
                 * @param {particle.ctrl.IInterfaceEntry} message InterfaceEntry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InterfaceEntry.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                    return writer;
                };
    
                /**
                 * Decodes an InterfaceEntry message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.InterfaceEntry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.InterfaceEntry} InterfaceEntry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InterfaceEntry.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.InterfaceEntry();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.index = reader.uint32();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.type = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return InterfaceEntry;
            })();
    
            ctrl.GetInterfaceListRequest = (function() {
    
                /**
                 * Properties of a GetInterfaceListRequest.
                 * @memberof particle.ctrl
                 * @interface IGetInterfaceListRequest
                 */
    
                /**
                 * Constructs a new GetInterfaceListRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetInterfaceListRequest.
                 * @implements IGetInterfaceListRequest
                 * @constructor
                 * @param {particle.ctrl.IGetInterfaceListRequest=} [properties] Properties to set
                 */
                function GetInterfaceListRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new GetInterfaceListRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetInterfaceListRequest
                 * @static
                 * @param {particle.ctrl.IGetInterfaceListRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetInterfaceListRequest} GetInterfaceListRequest instance
                 */
                GetInterfaceListRequest.create = function create(properties) {
                    return new GetInterfaceListRequest(properties);
                };
    
                /**
                 * Encodes the specified GetInterfaceListRequest message. Does not implicitly {@link particle.ctrl.GetInterfaceListRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetInterfaceListRequest
                 * @static
                 * @param {particle.ctrl.IGetInterfaceListRequest} message GetInterfaceListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetInterfaceListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a GetInterfaceListRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetInterfaceListRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetInterfaceListRequest} GetInterfaceListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetInterfaceListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceListRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetInterfaceListRequest;
            })();
    
            ctrl.GetInterfaceListReply = (function() {
    
                /**
                 * Properties of a GetInterfaceListReply.
                 * @memberof particle.ctrl
                 * @interface IGetInterfaceListReply
                 * @property {Array.<particle.ctrl.IInterfaceEntry>|null} [interfaces] GetInterfaceListReply interfaces
                 */
    
                /**
                 * Constructs a new GetInterfaceListReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetInterfaceListReply.
                 * @implements IGetInterfaceListReply
                 * @constructor
                 * @param {particle.ctrl.IGetInterfaceListReply=} [properties] Properties to set
                 */
                function GetInterfaceListReply(properties) {
                    this.interfaces = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetInterfaceListReply interfaces.
                 * @member {Array.<particle.ctrl.IInterfaceEntry>} interfaces
                 * @memberof particle.ctrl.GetInterfaceListReply
                 * @instance
                 */
                GetInterfaceListReply.prototype.interfaces = $util.emptyArray;
    
                /**
                 * Creates a new GetInterfaceListReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetInterfaceListReply
                 * @static
                 * @param {particle.ctrl.IGetInterfaceListReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetInterfaceListReply} GetInterfaceListReply instance
                 */
                GetInterfaceListReply.create = function create(properties) {
                    return new GetInterfaceListReply(properties);
                };
    
                /**
                 * Encodes the specified GetInterfaceListReply message. Does not implicitly {@link particle.ctrl.GetInterfaceListReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetInterfaceListReply
                 * @static
                 * @param {particle.ctrl.IGetInterfaceListReply} message GetInterfaceListReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetInterfaceListReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.interfaces != null && message.interfaces.length)
                        for (var i = 0; i < message.interfaces.length; ++i)
                            $root.particle.ctrl.InterfaceEntry.encode(message.interfaces[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a GetInterfaceListReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetInterfaceListReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetInterfaceListReply} GetInterfaceListReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetInterfaceListReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceListReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.interfaces && message.interfaces.length))
                                message.interfaces = [];
                            message.interfaces.push($root.particle.ctrl.InterfaceEntry.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetInterfaceListReply;
            })();
    
            ctrl.GetInterfaceRequest = (function() {
    
                /**
                 * Properties of a GetInterfaceRequest.
                 * @memberof particle.ctrl
                 * @interface IGetInterfaceRequest
                 * @property {number|null} [index] GetInterfaceRequest index
                 */
    
                /**
                 * Constructs a new GetInterfaceRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetInterfaceRequest.
                 * @implements IGetInterfaceRequest
                 * @constructor
                 * @param {particle.ctrl.IGetInterfaceRequest=} [properties] Properties to set
                 */
                function GetInterfaceRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetInterfaceRequest index.
                 * @member {number} index
                 * @memberof particle.ctrl.GetInterfaceRequest
                 * @instance
                 */
                GetInterfaceRequest.prototype.index = 0;
    
                /**
                 * Creates a new GetInterfaceRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetInterfaceRequest
                 * @static
                 * @param {particle.ctrl.IGetInterfaceRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetInterfaceRequest} GetInterfaceRequest instance
                 */
                GetInterfaceRequest.create = function create(properties) {
                    return new GetInterfaceRequest(properties);
                };
    
                /**
                 * Encodes the specified GetInterfaceRequest message. Does not implicitly {@link particle.ctrl.GetInterfaceRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetInterfaceRequest
                 * @static
                 * @param {particle.ctrl.IGetInterfaceRequest} message GetInterfaceRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetInterfaceRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                    return writer;
                };
    
                /**
                 * Decodes a GetInterfaceRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetInterfaceRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetInterfaceRequest} GetInterfaceRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetInterfaceRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.index = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetInterfaceRequest;
            })();
    
            ctrl.GetInterfaceReply = (function() {
    
                /**
                 * Properties of a GetInterfaceReply.
                 * @memberof particle.ctrl
                 * @interface IGetInterfaceReply
                 * @property {particle.ctrl.IInterface|null} ["interface"] GetInterfaceReply interface
                 */
    
                /**
                 * Constructs a new GetInterfaceReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetInterfaceReply.
                 * @implements IGetInterfaceReply
                 * @constructor
                 * @param {particle.ctrl.IGetInterfaceReply=} [properties] Properties to set
                 */
                function GetInterfaceReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetInterfaceReply interface.
                 * @member {particle.ctrl.IInterface|null|undefined} interface
                 * @memberof particle.ctrl.GetInterfaceReply
                 * @instance
                 */
                GetInterfaceReply.prototype["interface"] = null;
    
                /**
                 * Creates a new GetInterfaceReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetInterfaceReply
                 * @static
                 * @param {particle.ctrl.IGetInterfaceReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetInterfaceReply} GetInterfaceReply instance
                 */
                GetInterfaceReply.create = function create(properties) {
                    return new GetInterfaceReply(properties);
                };
    
                /**
                 * Encodes the specified GetInterfaceReply message. Does not implicitly {@link particle.ctrl.GetInterfaceReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetInterfaceReply
                 * @static
                 * @param {particle.ctrl.IGetInterfaceReply} message GetInterfaceReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetInterfaceReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message["interface"] != null && Object.hasOwnProperty.call(message, "interface"))
                        $root.particle.ctrl.Interface.encode(message["interface"], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a GetInterfaceReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetInterfaceReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetInterfaceReply} GetInterfaceReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetInterfaceReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message["interface"] = $root.particle.ctrl.Interface.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetInterfaceReply;
            })();
    
            ctrl.GetInterfaceStoredConfigurationRequest = (function() {
    
                /**
                 * Properties of a GetInterfaceStoredConfigurationRequest.
                 * @memberof particle.ctrl
                 * @interface IGetInterfaceStoredConfigurationRequest
                 * @property {number|null} [index] GetInterfaceStoredConfigurationRequest index
                 */
    
                /**
                 * Constructs a new GetInterfaceStoredConfigurationRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetInterfaceStoredConfigurationRequest.
                 * @implements IGetInterfaceStoredConfigurationRequest
                 * @constructor
                 * @param {particle.ctrl.IGetInterfaceStoredConfigurationRequest=} [properties] Properties to set
                 */
                function GetInterfaceStoredConfigurationRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetInterfaceStoredConfigurationRequest index.
                 * @member {number} index
                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationRequest
                 * @instance
                 */
                GetInterfaceStoredConfigurationRequest.prototype.index = 0;
    
                /**
                 * Creates a new GetInterfaceStoredConfigurationRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationRequest
                 * @static
                 * @param {particle.ctrl.IGetInterfaceStoredConfigurationRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetInterfaceStoredConfigurationRequest} GetInterfaceStoredConfigurationRequest instance
                 */
                GetInterfaceStoredConfigurationRequest.create = function create(properties) {
                    return new GetInterfaceStoredConfigurationRequest(properties);
                };
    
                /**
                 * Encodes the specified GetInterfaceStoredConfigurationRequest message. Does not implicitly {@link particle.ctrl.GetInterfaceStoredConfigurationRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationRequest
                 * @static
                 * @param {particle.ctrl.IGetInterfaceStoredConfigurationRequest} message GetInterfaceStoredConfigurationRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetInterfaceStoredConfigurationRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                    return writer;
                };
    
                /**
                 * Decodes a GetInterfaceStoredConfigurationRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetInterfaceStoredConfigurationRequest} GetInterfaceStoredConfigurationRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetInterfaceStoredConfigurationRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceStoredConfigurationRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.index = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetInterfaceStoredConfigurationRequest;
            })();
    
            ctrl.GetInterfaceStoredConfigurationReply = (function() {
    
                /**
                 * Properties of a GetInterfaceStoredConfigurationReply.
                 * @memberof particle.ctrl
                 * @interface IGetInterfaceStoredConfigurationReply
                 * @property {Array.<particle.ctrl.IInterface>|null} [config] GetInterfaceStoredConfigurationReply config
                 */
    
                /**
                 * Constructs a new GetInterfaceStoredConfigurationReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetInterfaceStoredConfigurationReply.
                 * @implements IGetInterfaceStoredConfigurationReply
                 * @constructor
                 * @param {particle.ctrl.IGetInterfaceStoredConfigurationReply=} [properties] Properties to set
                 */
                function GetInterfaceStoredConfigurationReply(properties) {
                    this.config = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetInterfaceStoredConfigurationReply config.
                 * @member {Array.<particle.ctrl.IInterface>} config
                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationReply
                 * @instance
                 */
                GetInterfaceStoredConfigurationReply.prototype.config = $util.emptyArray;
    
                /**
                 * Creates a new GetInterfaceStoredConfigurationReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationReply
                 * @static
                 * @param {particle.ctrl.IGetInterfaceStoredConfigurationReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetInterfaceStoredConfigurationReply} GetInterfaceStoredConfigurationReply instance
                 */
                GetInterfaceStoredConfigurationReply.create = function create(properties) {
                    return new GetInterfaceStoredConfigurationReply(properties);
                };
    
                /**
                 * Encodes the specified GetInterfaceStoredConfigurationReply message. Does not implicitly {@link particle.ctrl.GetInterfaceStoredConfigurationReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationReply
                 * @static
                 * @param {particle.ctrl.IGetInterfaceStoredConfigurationReply} message GetInterfaceStoredConfigurationReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetInterfaceStoredConfigurationReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.config != null && message.config.length)
                        for (var i = 0; i < message.config.length; ++i)
                            $root.particle.ctrl.Interface.encode(message.config[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a GetInterfaceStoredConfigurationReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetInterfaceStoredConfigurationReply} GetInterfaceStoredConfigurationReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetInterfaceStoredConfigurationReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceStoredConfigurationReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.config && message.config.length))
                                message.config = [];
                            message.config.push($root.particle.ctrl.Interface.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetInterfaceStoredConfigurationReply;
            })();
    
            ctrl.SetInterfaceStoredConfigurationRequest = (function() {
    
                /**
                 * Properties of a SetInterfaceStoredConfigurationRequest.
                 * @memberof particle.ctrl
                 * @interface ISetInterfaceStoredConfigurationRequest
                 * @property {particle.ctrl.IInterface|null} [config] SetInterfaceStoredConfigurationRequest config
                 */
    
                /**
                 * Constructs a new SetInterfaceStoredConfigurationRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetInterfaceStoredConfigurationRequest.
                 * @implements ISetInterfaceStoredConfigurationRequest
                 * @constructor
                 * @param {particle.ctrl.ISetInterfaceStoredConfigurationRequest=} [properties] Properties to set
                 */
                function SetInterfaceStoredConfigurationRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SetInterfaceStoredConfigurationRequest config.
                 * @member {particle.ctrl.IInterface|null|undefined} config
                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationRequest
                 * @instance
                 */
                SetInterfaceStoredConfigurationRequest.prototype.config = null;
    
                /**
                 * Creates a new SetInterfaceStoredConfigurationRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationRequest
                 * @static
                 * @param {particle.ctrl.ISetInterfaceStoredConfigurationRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.SetInterfaceStoredConfigurationRequest} SetInterfaceStoredConfigurationRequest instance
                 */
                SetInterfaceStoredConfigurationRequest.create = function create(properties) {
                    return new SetInterfaceStoredConfigurationRequest(properties);
                };
    
                /**
                 * Encodes the specified SetInterfaceStoredConfigurationRequest message. Does not implicitly {@link particle.ctrl.SetInterfaceStoredConfigurationRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationRequest
                 * @static
                 * @param {particle.ctrl.ISetInterfaceStoredConfigurationRequest} message SetInterfaceStoredConfigurationRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetInterfaceStoredConfigurationRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.config != null && Object.hasOwnProperty.call(message, "config"))
                        $root.particle.ctrl.Interface.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a SetInterfaceStoredConfigurationRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetInterfaceStoredConfigurationRequest} SetInterfaceStoredConfigurationRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetInterfaceStoredConfigurationRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetInterfaceStoredConfigurationRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.config = $root.particle.ctrl.Interface.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetInterfaceStoredConfigurationRequest;
            })();
    
            ctrl.SetInterfaceStoredConfigurationReply = (function() {
    
                /**
                 * Properties of a SetInterfaceStoredConfigurationReply.
                 * @memberof particle.ctrl
                 * @interface ISetInterfaceStoredConfigurationReply
                 */
    
                /**
                 * Constructs a new SetInterfaceStoredConfigurationReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a SetInterfaceStoredConfigurationReply.
                 * @implements ISetInterfaceStoredConfigurationReply
                 * @constructor
                 * @param {particle.ctrl.ISetInterfaceStoredConfigurationReply=} [properties] Properties to set
                 */
                function SetInterfaceStoredConfigurationReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SetInterfaceStoredConfigurationReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationReply
                 * @static
                 * @param {particle.ctrl.ISetInterfaceStoredConfigurationReply=} [properties] Properties to set
                 * @returns {particle.ctrl.SetInterfaceStoredConfigurationReply} SetInterfaceStoredConfigurationReply instance
                 */
                SetInterfaceStoredConfigurationReply.create = function create(properties) {
                    return new SetInterfaceStoredConfigurationReply(properties);
                };
    
                /**
                 * Encodes the specified SetInterfaceStoredConfigurationReply message. Does not implicitly {@link particle.ctrl.SetInterfaceStoredConfigurationReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationReply
                 * @static
                 * @param {particle.ctrl.ISetInterfaceStoredConfigurationReply} message SetInterfaceStoredConfigurationReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetInterfaceStoredConfigurationReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a SetInterfaceStoredConfigurationReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.SetInterfaceStoredConfigurationReply} SetInterfaceStoredConfigurationReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetInterfaceStoredConfigurationReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetInterfaceStoredConfigurationReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SetInterfaceStoredConfigurationReply;
            })();
    
            ctrl.DeleteInterfaceStoredConfigurationRequest = (function() {
    
                /**
                 * Properties of a DeleteInterfaceStoredConfigurationRequest.
                 * @memberof particle.ctrl
                 * @interface IDeleteInterfaceStoredConfigurationRequest
                 * @property {number|null} [index] DeleteInterfaceStoredConfigurationRequest index
                 * @property {Uint8Array|null} [profile] DeleteInterfaceStoredConfigurationRequest profile
                 */
    
                /**
                 * Constructs a new DeleteInterfaceStoredConfigurationRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a DeleteInterfaceStoredConfigurationRequest.
                 * @implements IDeleteInterfaceStoredConfigurationRequest
                 * @constructor
                 * @param {particle.ctrl.IDeleteInterfaceStoredConfigurationRequest=} [properties] Properties to set
                 */
                function DeleteInterfaceStoredConfigurationRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DeleteInterfaceStoredConfigurationRequest index.
                 * @member {number} index
                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationRequest
                 * @instance
                 */
                DeleteInterfaceStoredConfigurationRequest.prototype.index = 0;
    
                /**
                 * DeleteInterfaceStoredConfigurationRequest profile.
                 * @member {Uint8Array} profile
                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationRequest
                 * @instance
                 */
                DeleteInterfaceStoredConfigurationRequest.prototype.profile = $util.newBuffer([]);
    
                /**
                 * Creates a new DeleteInterfaceStoredConfigurationRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationRequest
                 * @static
                 * @param {particle.ctrl.IDeleteInterfaceStoredConfigurationRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.DeleteInterfaceStoredConfigurationRequest} DeleteInterfaceStoredConfigurationRequest instance
                 */
                DeleteInterfaceStoredConfigurationRequest.create = function create(properties) {
                    return new DeleteInterfaceStoredConfigurationRequest(properties);
                };
    
                /**
                 * Encodes the specified DeleteInterfaceStoredConfigurationRequest message. Does not implicitly {@link particle.ctrl.DeleteInterfaceStoredConfigurationRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationRequest
                 * @static
                 * @param {particle.ctrl.IDeleteInterfaceStoredConfigurationRequest} message DeleteInterfaceStoredConfigurationRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteInterfaceStoredConfigurationRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                    if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.profile);
                    return writer;
                };
    
                /**
                 * Decodes a DeleteInterfaceStoredConfigurationRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.DeleteInterfaceStoredConfigurationRequest} DeleteInterfaceStoredConfigurationRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteInterfaceStoredConfigurationRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DeleteInterfaceStoredConfigurationRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.index = reader.uint32();
                            break;
                        case 2:
                            message.profile = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return DeleteInterfaceStoredConfigurationRequest;
            })();
    
            ctrl.DeleteInterfaceStoredConfigurationReply = (function() {
    
                /**
                 * Properties of a DeleteInterfaceStoredConfigurationReply.
                 * @memberof particle.ctrl
                 * @interface IDeleteInterfaceStoredConfigurationReply
                 */
    
                /**
                 * Constructs a new DeleteInterfaceStoredConfigurationReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a DeleteInterfaceStoredConfigurationReply.
                 * @implements IDeleteInterfaceStoredConfigurationReply
                 * @constructor
                 * @param {particle.ctrl.IDeleteInterfaceStoredConfigurationReply=} [properties] Properties to set
                 */
                function DeleteInterfaceStoredConfigurationReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new DeleteInterfaceStoredConfigurationReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationReply
                 * @static
                 * @param {particle.ctrl.IDeleteInterfaceStoredConfigurationReply=} [properties] Properties to set
                 * @returns {particle.ctrl.DeleteInterfaceStoredConfigurationReply} DeleteInterfaceStoredConfigurationReply instance
                 */
                DeleteInterfaceStoredConfigurationReply.create = function create(properties) {
                    return new DeleteInterfaceStoredConfigurationReply(properties);
                };
    
                /**
                 * Encodes the specified DeleteInterfaceStoredConfigurationReply message. Does not implicitly {@link particle.ctrl.DeleteInterfaceStoredConfigurationReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationReply
                 * @static
                 * @param {particle.ctrl.IDeleteInterfaceStoredConfigurationReply} message DeleteInterfaceStoredConfigurationReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteInterfaceStoredConfigurationReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a DeleteInterfaceStoredConfigurationReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.DeleteInterfaceStoredConfigurationReply} DeleteInterfaceStoredConfigurationReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteInterfaceStoredConfigurationReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DeleteInterfaceStoredConfigurationReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return DeleteInterfaceStoredConfigurationReply;
            })();
    
            /**
             * StorageType enum.
             * @name particle.ctrl.StorageType
             * @enum {number}
             * @property {number} INVALID_STORAGE=0 INVALID_STORAGE value
             * @property {number} INTERNAL=1 INTERNAL value
             */
            ctrl.StorageType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INVALID_STORAGE"] = 0;
                values[valuesById[1] = "INTERNAL"] = 1;
                return values;
            })();
    
            /**
             * SectionType enum.
             * @name particle.ctrl.SectionType
             * @enum {number}
             * @property {number} INVALID_SECTION=0 INVALID_SECTION value
             * @property {number} FIRMWARE=1 FIRMWARE value
             * @property {number} OTA_BACKUP=2 OTA_BACKUP value
             * @property {number} FACTORY_BACKUP=3 FACTORY_BACKUP value
             * @property {number} CONFIG=4 CONFIG value
             * @property {number} EEPROM=5 EEPROM value
             */
            ctrl.SectionType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INVALID_SECTION"] = 0;
                values[valuesById[1] = "FIRMWARE"] = 1;
                values[valuesById[2] = "OTA_BACKUP"] = 2;
                values[valuesById[3] = "FACTORY_BACKUP"] = 3;
                values[valuesById[4] = "CONFIG"] = 4;
                values[valuesById[5] = "EEPROM"] = 5;
                return values;
            })();
    
            /**
             * FirmwareModuleType enum.
             * @name particle.ctrl.FirmwareModuleType
             * @enum {number}
             * @property {number} INVALID_FIRMWARE_MODULE=0 INVALID_FIRMWARE_MODULE value
             * @property {number} BOOTLOADER=1 BOOTLOADER value
             * @property {number} SYSTEM_PART=2 SYSTEM_PART value
             * @property {number} USER_PART=3 USER_PART value
             * @property {number} MONO_FIRMWARE=4 MONO_FIRMWARE value
             * @property {number} NCP_FIRMWARE=5 NCP_FIRMWARE value
             * @property {number} RADIO_STACK=6 RADIO_STACK value
             */
            ctrl.FirmwareModuleType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INVALID_FIRMWARE_MODULE"] = 0;
                values[valuesById[1] = "BOOTLOADER"] = 1;
                values[valuesById[2] = "SYSTEM_PART"] = 2;
                values[valuesById[3] = "USER_PART"] = 3;
                values[valuesById[4] = "MONO_FIRMWARE"] = 4;
                values[valuesById[5] = "NCP_FIRMWARE"] = 5;
                values[valuesById[6] = "RADIO_STACK"] = 6;
                return values;
            })();
    
            /**
             * FirmwareModuleValidityFlag enum.
             * @name particle.ctrl.FirmwareModuleValidityFlag
             * @enum {number}
             * @property {number} NO_VALIDATION_ERRORS=0 NO_VALIDATION_ERRORS value
             * @property {number} INTEGRITY_CHECK_FAILED=1 INTEGRITY_CHECK_FAILED value
             * @property {number} DEPENDENCY_CHECK_FAILED=2 DEPENDENCY_CHECK_FAILED value
             */
            ctrl.FirmwareModuleValidityFlag = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NO_VALIDATION_ERRORS"] = 0;
                values[valuesById[1] = "INTEGRITY_CHECK_FAILED"] = 1;
                values[valuesById[2] = "DEPENDENCY_CHECK_FAILED"] = 2;
                return values;
            })();
    
            /**
             * SectionFlag enum.
             * @name particle.ctrl.SectionFlag
             * @enum {number}
             * @property {number} NO_SECTION_FLAGS=0 NO_SECTION_FLAGS value
             * @property {number} CAN_READ=1 CAN_READ value
             * @property {number} CAN_WRITE=2 CAN_WRITE value
             * @property {number} CAN_CLEAR=4 CAN_CLEAR value
             * @property {number} CAN_GET_SIZE=8 CAN_GET_SIZE value
             * @property {number} NEED_CLEAR=16 NEED_CLEAR value
             */
            ctrl.SectionFlag = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NO_SECTION_FLAGS"] = 0;
                values[valuesById[1] = "CAN_READ"] = 1;
                values[valuesById[2] = "CAN_WRITE"] = 2;
                values[valuesById[4] = "CAN_CLEAR"] = 4;
                values[valuesById[8] = "CAN_GET_SIZE"] = 8;
                values[valuesById[16] = "NEED_CLEAR"] = 16;
                return values;
            })();
    
            /**
             * FileFormat enum.
             * @name particle.ctrl.FileFormat
             * @enum {number}
             * @property {number} BIN=0 BIN value
             * @property {number} MINIZ=1 MINIZ value
             */
            ctrl.FileFormat = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "BIN"] = 0;
                values[valuesById[1] = "MINIZ"] = 1;
                return values;
            })();
    
            ctrl.StartFirmwareUpdateRequest = (function() {
    
                /**
                 * Properties of a StartFirmwareUpdateRequest.
                 * @memberof particle.ctrl
                 * @interface IStartFirmwareUpdateRequest
                 * @property {number|null} [size] StartFirmwareUpdateRequest size
                 * @property {particle.ctrl.FileFormat|null} [format] StartFirmwareUpdateRequest format
                 */
    
                /**
                 * Constructs a new StartFirmwareUpdateRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a StartFirmwareUpdateRequest.
                 * @implements IStartFirmwareUpdateRequest
                 * @constructor
                 * @param {particle.ctrl.IStartFirmwareUpdateRequest=} [properties] Properties to set
                 */
                function StartFirmwareUpdateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * StartFirmwareUpdateRequest size.
                 * @member {number} size
                 * @memberof particle.ctrl.StartFirmwareUpdateRequest
                 * @instance
                 */
                StartFirmwareUpdateRequest.prototype.size = 0;
    
                /**
                 * StartFirmwareUpdateRequest format.
                 * @member {particle.ctrl.FileFormat} format
                 * @memberof particle.ctrl.StartFirmwareUpdateRequest
                 * @instance
                 */
                StartFirmwareUpdateRequest.prototype.format = 0;
    
                /**
                 * Creates a new StartFirmwareUpdateRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.StartFirmwareUpdateRequest
                 * @static
                 * @param {particle.ctrl.IStartFirmwareUpdateRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.StartFirmwareUpdateRequest} StartFirmwareUpdateRequest instance
                 */
                StartFirmwareUpdateRequest.create = function create(properties) {
                    return new StartFirmwareUpdateRequest(properties);
                };
    
                /**
                 * Encodes the specified StartFirmwareUpdateRequest message. Does not implicitly {@link particle.ctrl.StartFirmwareUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.StartFirmwareUpdateRequest
                 * @static
                 * @param {particle.ctrl.IStartFirmwareUpdateRequest} message StartFirmwareUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StartFirmwareUpdateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.size);
                    if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.format);
                    return writer;
                };
    
                /**
                 * Decodes a StartFirmwareUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.StartFirmwareUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.StartFirmwareUpdateRequest} StartFirmwareUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StartFirmwareUpdateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartFirmwareUpdateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.size = reader.uint32();
                            break;
                        case 2:
                            message.format = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return StartFirmwareUpdateRequest;
            })();
    
            ctrl.StartFirmwareUpdateReply = (function() {
    
                /**
                 * Properties of a StartFirmwareUpdateReply.
                 * @memberof particle.ctrl
                 * @interface IStartFirmwareUpdateReply
                 * @property {number|null} [chunkSize] StartFirmwareUpdateReply chunkSize
                 */
    
                /**
                 * Constructs a new StartFirmwareUpdateReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a StartFirmwareUpdateReply.
                 * @implements IStartFirmwareUpdateReply
                 * @constructor
                 * @param {particle.ctrl.IStartFirmwareUpdateReply=} [properties] Properties to set
                 */
                function StartFirmwareUpdateReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * StartFirmwareUpdateReply chunkSize.
                 * @member {number} chunkSize
                 * @memberof particle.ctrl.StartFirmwareUpdateReply
                 * @instance
                 */
                StartFirmwareUpdateReply.prototype.chunkSize = 0;
    
                /**
                 * Creates a new StartFirmwareUpdateReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.StartFirmwareUpdateReply
                 * @static
                 * @param {particle.ctrl.IStartFirmwareUpdateReply=} [properties] Properties to set
                 * @returns {particle.ctrl.StartFirmwareUpdateReply} StartFirmwareUpdateReply instance
                 */
                StartFirmwareUpdateReply.create = function create(properties) {
                    return new StartFirmwareUpdateReply(properties);
                };
    
                /**
                 * Encodes the specified StartFirmwareUpdateReply message. Does not implicitly {@link particle.ctrl.StartFirmwareUpdateReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.StartFirmwareUpdateReply
                 * @static
                 * @param {particle.ctrl.IStartFirmwareUpdateReply} message StartFirmwareUpdateReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StartFirmwareUpdateReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chunkSize != null && Object.hasOwnProperty.call(message, "chunkSize"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.chunkSize);
                    return writer;
                };
    
                /**
                 * Decodes a StartFirmwareUpdateReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.StartFirmwareUpdateReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.StartFirmwareUpdateReply} StartFirmwareUpdateReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StartFirmwareUpdateReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartFirmwareUpdateReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.chunkSize = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return StartFirmwareUpdateReply;
            })();
    
            ctrl.FinishFirmwareUpdateRequest = (function() {
    
                /**
                 * Properties of a FinishFirmwareUpdateRequest.
                 * @memberof particle.ctrl
                 * @interface IFinishFirmwareUpdateRequest
                 * @property {boolean|null} [validateOnly] FinishFirmwareUpdateRequest validateOnly
                 */
    
                /**
                 * Constructs a new FinishFirmwareUpdateRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a FinishFirmwareUpdateRequest.
                 * @implements IFinishFirmwareUpdateRequest
                 * @constructor
                 * @param {particle.ctrl.IFinishFirmwareUpdateRequest=} [properties] Properties to set
                 */
                function FinishFirmwareUpdateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FinishFirmwareUpdateRequest validateOnly.
                 * @member {boolean} validateOnly
                 * @memberof particle.ctrl.FinishFirmwareUpdateRequest
                 * @instance
                 */
                FinishFirmwareUpdateRequest.prototype.validateOnly = false;
    
                /**
                 * Creates a new FinishFirmwareUpdateRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.FinishFirmwareUpdateRequest
                 * @static
                 * @param {particle.ctrl.IFinishFirmwareUpdateRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.FinishFirmwareUpdateRequest} FinishFirmwareUpdateRequest instance
                 */
                FinishFirmwareUpdateRequest.create = function create(properties) {
                    return new FinishFirmwareUpdateRequest(properties);
                };
    
                /**
                 * Encodes the specified FinishFirmwareUpdateRequest message. Does not implicitly {@link particle.ctrl.FinishFirmwareUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.FinishFirmwareUpdateRequest
                 * @static
                 * @param {particle.ctrl.IFinishFirmwareUpdateRequest} message FinishFirmwareUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FinishFirmwareUpdateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.validateOnly != null && Object.hasOwnProperty.call(message, "validateOnly"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.validateOnly);
                    return writer;
                };
    
                /**
                 * Decodes a FinishFirmwareUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.FinishFirmwareUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.FinishFirmwareUpdateRequest} FinishFirmwareUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FinishFirmwareUpdateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.FinishFirmwareUpdateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.validateOnly = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return FinishFirmwareUpdateRequest;
            })();
    
            ctrl.FinishFirmwareUpdateReply = (function() {
    
                /**
                 * Properties of a FinishFirmwareUpdateReply.
                 * @memberof particle.ctrl
                 * @interface IFinishFirmwareUpdateReply
                 */
    
                /**
                 * Constructs a new FinishFirmwareUpdateReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a FinishFirmwareUpdateReply.
                 * @implements IFinishFirmwareUpdateReply
                 * @constructor
                 * @param {particle.ctrl.IFinishFirmwareUpdateReply=} [properties] Properties to set
                 */
                function FinishFirmwareUpdateReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new FinishFirmwareUpdateReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.FinishFirmwareUpdateReply
                 * @static
                 * @param {particle.ctrl.IFinishFirmwareUpdateReply=} [properties] Properties to set
                 * @returns {particle.ctrl.FinishFirmwareUpdateReply} FinishFirmwareUpdateReply instance
                 */
                FinishFirmwareUpdateReply.create = function create(properties) {
                    return new FinishFirmwareUpdateReply(properties);
                };
    
                /**
                 * Encodes the specified FinishFirmwareUpdateReply message. Does not implicitly {@link particle.ctrl.FinishFirmwareUpdateReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.FinishFirmwareUpdateReply
                 * @static
                 * @param {particle.ctrl.IFinishFirmwareUpdateReply} message FinishFirmwareUpdateReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FinishFirmwareUpdateReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a FinishFirmwareUpdateReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.FinishFirmwareUpdateReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.FinishFirmwareUpdateReply} FinishFirmwareUpdateReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FinishFirmwareUpdateReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.FinishFirmwareUpdateReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return FinishFirmwareUpdateReply;
            })();
    
            ctrl.CancelFirmwareUpdateRequest = (function() {
    
                /**
                 * Properties of a CancelFirmwareUpdateRequest.
                 * @memberof particle.ctrl
                 * @interface ICancelFirmwareUpdateRequest
                 */
    
                /**
                 * Constructs a new CancelFirmwareUpdateRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a CancelFirmwareUpdateRequest.
                 * @implements ICancelFirmwareUpdateRequest
                 * @constructor
                 * @param {particle.ctrl.ICancelFirmwareUpdateRequest=} [properties] Properties to set
                 */
                function CancelFirmwareUpdateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new CancelFirmwareUpdateRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.CancelFirmwareUpdateRequest
                 * @static
                 * @param {particle.ctrl.ICancelFirmwareUpdateRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.CancelFirmwareUpdateRequest} CancelFirmwareUpdateRequest instance
                 */
                CancelFirmwareUpdateRequest.create = function create(properties) {
                    return new CancelFirmwareUpdateRequest(properties);
                };
    
                /**
                 * Encodes the specified CancelFirmwareUpdateRequest message. Does not implicitly {@link particle.ctrl.CancelFirmwareUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.CancelFirmwareUpdateRequest
                 * @static
                 * @param {particle.ctrl.ICancelFirmwareUpdateRequest} message CancelFirmwareUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CancelFirmwareUpdateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a CancelFirmwareUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.CancelFirmwareUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.CancelFirmwareUpdateRequest} CancelFirmwareUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CancelFirmwareUpdateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.CancelFirmwareUpdateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return CancelFirmwareUpdateRequest;
            })();
    
            ctrl.CancelFirmwareUpdateReply = (function() {
    
                /**
                 * Properties of a CancelFirmwareUpdateReply.
                 * @memberof particle.ctrl
                 * @interface ICancelFirmwareUpdateReply
                 */
    
                /**
                 * Constructs a new CancelFirmwareUpdateReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a CancelFirmwareUpdateReply.
                 * @implements ICancelFirmwareUpdateReply
                 * @constructor
                 * @param {particle.ctrl.ICancelFirmwareUpdateReply=} [properties] Properties to set
                 */
                function CancelFirmwareUpdateReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new CancelFirmwareUpdateReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.CancelFirmwareUpdateReply
                 * @static
                 * @param {particle.ctrl.ICancelFirmwareUpdateReply=} [properties] Properties to set
                 * @returns {particle.ctrl.CancelFirmwareUpdateReply} CancelFirmwareUpdateReply instance
                 */
                CancelFirmwareUpdateReply.create = function create(properties) {
                    return new CancelFirmwareUpdateReply(properties);
                };
    
                /**
                 * Encodes the specified CancelFirmwareUpdateReply message. Does not implicitly {@link particle.ctrl.CancelFirmwareUpdateReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.CancelFirmwareUpdateReply
                 * @static
                 * @param {particle.ctrl.ICancelFirmwareUpdateReply} message CancelFirmwareUpdateReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CancelFirmwareUpdateReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a CancelFirmwareUpdateReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.CancelFirmwareUpdateReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.CancelFirmwareUpdateReply} CancelFirmwareUpdateReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CancelFirmwareUpdateReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.CancelFirmwareUpdateReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return CancelFirmwareUpdateReply;
            })();
    
            ctrl.FirmwareUpdateDataRequest = (function() {
    
                /**
                 * Properties of a FirmwareUpdateDataRequest.
                 * @memberof particle.ctrl
                 * @interface IFirmwareUpdateDataRequest
                 * @property {Uint8Array|null} [data] FirmwareUpdateDataRequest data
                 */
    
                /**
                 * Constructs a new FirmwareUpdateDataRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a FirmwareUpdateDataRequest.
                 * @implements IFirmwareUpdateDataRequest
                 * @constructor
                 * @param {particle.ctrl.IFirmwareUpdateDataRequest=} [properties] Properties to set
                 */
                function FirmwareUpdateDataRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FirmwareUpdateDataRequest data.
                 * @member {Uint8Array} data
                 * @memberof particle.ctrl.FirmwareUpdateDataRequest
                 * @instance
                 */
                FirmwareUpdateDataRequest.prototype.data = $util.newBuffer([]);
    
                /**
                 * Creates a new FirmwareUpdateDataRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.FirmwareUpdateDataRequest
                 * @static
                 * @param {particle.ctrl.IFirmwareUpdateDataRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.FirmwareUpdateDataRequest} FirmwareUpdateDataRequest instance
                 */
                FirmwareUpdateDataRequest.create = function create(properties) {
                    return new FirmwareUpdateDataRequest(properties);
                };
    
                /**
                 * Encodes the specified FirmwareUpdateDataRequest message. Does not implicitly {@link particle.ctrl.FirmwareUpdateDataRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.FirmwareUpdateDataRequest
                 * @static
                 * @param {particle.ctrl.IFirmwareUpdateDataRequest} message FirmwareUpdateDataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FirmwareUpdateDataRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
                    return writer;
                };
    
                /**
                 * Decodes a FirmwareUpdateDataRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.FirmwareUpdateDataRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.FirmwareUpdateDataRequest} FirmwareUpdateDataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FirmwareUpdateDataRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.FirmwareUpdateDataRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return FirmwareUpdateDataRequest;
            })();
    
            ctrl.FirmwareUpdateDataReply = (function() {
    
                /**
                 * Properties of a FirmwareUpdateDataReply.
                 * @memberof particle.ctrl
                 * @interface IFirmwareUpdateDataReply
                 */
    
                /**
                 * Constructs a new FirmwareUpdateDataReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a FirmwareUpdateDataReply.
                 * @implements IFirmwareUpdateDataReply
                 * @constructor
                 * @param {particle.ctrl.IFirmwareUpdateDataReply=} [properties] Properties to set
                 */
                function FirmwareUpdateDataReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new FirmwareUpdateDataReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.FirmwareUpdateDataReply
                 * @static
                 * @param {particle.ctrl.IFirmwareUpdateDataReply=} [properties] Properties to set
                 * @returns {particle.ctrl.FirmwareUpdateDataReply} FirmwareUpdateDataReply instance
                 */
                FirmwareUpdateDataReply.create = function create(properties) {
                    return new FirmwareUpdateDataReply(properties);
                };
    
                /**
                 * Encodes the specified FirmwareUpdateDataReply message. Does not implicitly {@link particle.ctrl.FirmwareUpdateDataReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.FirmwareUpdateDataReply
                 * @static
                 * @param {particle.ctrl.IFirmwareUpdateDataReply} message FirmwareUpdateDataReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FirmwareUpdateDataReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a FirmwareUpdateDataReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.FirmwareUpdateDataReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.FirmwareUpdateDataReply} FirmwareUpdateDataReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FirmwareUpdateDataReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.FirmwareUpdateDataReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return FirmwareUpdateDataReply;
            })();
    
            ctrl.DescribeStorageRequest = (function() {
    
                /**
                 * Properties of a DescribeStorageRequest.
                 * @memberof particle.ctrl
                 * @interface IDescribeStorageRequest
                 */
    
                /**
                 * Constructs a new DescribeStorageRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a DescribeStorageRequest.
                 * @implements IDescribeStorageRequest
                 * @constructor
                 * @param {particle.ctrl.IDescribeStorageRequest=} [properties] Properties to set
                 */
                function DescribeStorageRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new DescribeStorageRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.DescribeStorageRequest
                 * @static
                 * @param {particle.ctrl.IDescribeStorageRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.DescribeStorageRequest} DescribeStorageRequest instance
                 */
                DescribeStorageRequest.create = function create(properties) {
                    return new DescribeStorageRequest(properties);
                };
    
                /**
                 * Encodes the specified DescribeStorageRequest message. Does not implicitly {@link particle.ctrl.DescribeStorageRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.DescribeStorageRequest
                 * @static
                 * @param {particle.ctrl.IDescribeStorageRequest} message DescribeStorageRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescribeStorageRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a DescribeStorageRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.DescribeStorageRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.DescribeStorageRequest} DescribeStorageRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescribeStorageRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return DescribeStorageRequest;
            })();
    
            ctrl.DescribeStorageReply = (function() {
    
                /**
                 * Properties of a DescribeStorageReply.
                 * @memberof particle.ctrl
                 * @interface IDescribeStorageReply
                 * @property {Array.<particle.ctrl.DescribeStorageReply.IStorage>|null} [storage] DescribeStorageReply storage
                 */
    
                /**
                 * Constructs a new DescribeStorageReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a DescribeStorageReply.
                 * @implements IDescribeStorageReply
                 * @constructor
                 * @param {particle.ctrl.IDescribeStorageReply=} [properties] Properties to set
                 */
                function DescribeStorageReply(properties) {
                    this.storage = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescribeStorageReply storage.
                 * @member {Array.<particle.ctrl.DescribeStorageReply.IStorage>} storage
                 * @memberof particle.ctrl.DescribeStorageReply
                 * @instance
                 */
                DescribeStorageReply.prototype.storage = $util.emptyArray;
    
                /**
                 * Creates a new DescribeStorageReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.DescribeStorageReply
                 * @static
                 * @param {particle.ctrl.IDescribeStorageReply=} [properties] Properties to set
                 * @returns {particle.ctrl.DescribeStorageReply} DescribeStorageReply instance
                 */
                DescribeStorageReply.create = function create(properties) {
                    return new DescribeStorageReply(properties);
                };
    
                /**
                 * Encodes the specified DescribeStorageReply message. Does not implicitly {@link particle.ctrl.DescribeStorageReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.DescribeStorageReply
                 * @static
                 * @param {particle.ctrl.IDescribeStorageReply} message DescribeStorageReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescribeStorageReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.storage != null && message.storage.length)
                        for (var i = 0; i < message.storage.length; ++i)
                            $root.particle.ctrl.DescribeStorageReply.Storage.encode(message.storage[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a DescribeStorageReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.DescribeStorageReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.DescribeStorageReply} DescribeStorageReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescribeStorageReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.storage && message.storage.length))
                                message.storage = [];
                            message.storage.push($root.particle.ctrl.DescribeStorageReply.Storage.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                DescribeStorageReply.Section = (function() {
    
                    /**
                     * Properties of a Section.
                     * @memberof particle.ctrl.DescribeStorageReply
                     * @interface ISection
                     * @property {particle.ctrl.SectionType|null} [type] Section type
                     * @property {number|null} [size] Section size
                     * @property {number|null} [flags] Section flags
                     * @property {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule|null} [firmwareModule] Section firmwareModule
                     */
    
                    /**
                     * Constructs a new Section.
                     * @memberof particle.ctrl.DescribeStorageReply
                     * @classdesc Represents a Section.
                     * @implements ISection
                     * @constructor
                     * @param {particle.ctrl.DescribeStorageReply.ISection=} [properties] Properties to set
                     */
                    function Section(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Section type.
                     * @member {particle.ctrl.SectionType} type
                     * @memberof particle.ctrl.DescribeStorageReply.Section
                     * @instance
                     */
                    Section.prototype.type = 0;
    
                    /**
                     * Section size.
                     * @member {number} size
                     * @memberof particle.ctrl.DescribeStorageReply.Section
                     * @instance
                     */
                    Section.prototype.size = 0;
    
                    /**
                     * Section flags.
                     * @member {number} flags
                     * @memberof particle.ctrl.DescribeStorageReply.Section
                     * @instance
                     */
                    Section.prototype.flags = 0;
    
                    /**
                     * Section firmwareModule.
                     * @member {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule|null|undefined} firmwareModule
                     * @memberof particle.ctrl.DescribeStorageReply.Section
                     * @instance
                     */
                    Section.prototype.firmwareModule = null;
    
                    /**
                     * Creates a new Section instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.DescribeStorageReply.Section
                     * @static
                     * @param {particle.ctrl.DescribeStorageReply.ISection=} [properties] Properties to set
                     * @returns {particle.ctrl.DescribeStorageReply.Section} Section instance
                     */
                    Section.create = function create(properties) {
                        return new Section(properties);
                    };
    
                    /**
                     * Encodes the specified Section message. Does not implicitly {@link particle.ctrl.DescribeStorageReply.Section.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.DescribeStorageReply.Section
                     * @static
                     * @param {particle.ctrl.DescribeStorageReply.ISection} message Section message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Section.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                        if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.size);
                        if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.flags);
                        if (message.firmwareModule != null && Object.hasOwnProperty.call(message, "firmwareModule"))
                            $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule.encode(message.firmwareModule, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a Section message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.DescribeStorageReply.Section
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.DescribeStorageReply.Section} Section
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Section.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageReply.Section();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.type = reader.int32();
                                break;
                            case 2:
                                message.size = reader.uint32();
                                break;
                            case 3:
                                message.flags = reader.uint32();
                                break;
                            case 4:
                                message.firmwareModule = $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    Section.FirmwareModule = (function() {
    
                        /**
                         * Properties of a FirmwareModule.
                         * @memberof particle.ctrl.DescribeStorageReply.Section
                         * @interface IFirmwareModule
                         * @property {particle.ctrl.FirmwareModuleType|null} [type] FirmwareModule type
                         * @property {number|null} [index] FirmwareModule index
                         */
    
                        /**
                         * Constructs a new FirmwareModule.
                         * @memberof particle.ctrl.DescribeStorageReply.Section
                         * @classdesc Represents a FirmwareModule.
                         * @implements IFirmwareModule
                         * @constructor
                         * @param {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule=} [properties] Properties to set
                         */
                        function FirmwareModule(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * FirmwareModule type.
                         * @member {particle.ctrl.FirmwareModuleType} type
                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule
                         * @instance
                         */
                        FirmwareModule.prototype.type = 0;
    
                        /**
                         * FirmwareModule index.
                         * @member {number} index
                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule
                         * @instance
                         */
                        FirmwareModule.prototype.index = 0;
    
                        /**
                         * Creates a new FirmwareModule instance using the specified properties.
                         * @function create
                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule
                         * @static
                         * @param {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule=} [properties] Properties to set
                         * @returns {particle.ctrl.DescribeStorageReply.Section.FirmwareModule} FirmwareModule instance
                         */
                        FirmwareModule.create = function create(properties) {
                            return new FirmwareModule(properties);
                        };
    
                        /**
                         * Encodes the specified FirmwareModule message. Does not implicitly {@link particle.ctrl.DescribeStorageReply.Section.FirmwareModule.verify|verify} messages.
                         * @function encode
                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule
                         * @static
                         * @param {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule} message FirmwareModule message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FirmwareModule.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
                            return writer;
                        };
    
                        /**
                         * Decodes a FirmwareModule message from the specified reader or buffer.
                         * @function decode
                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {particle.ctrl.DescribeStorageReply.Section.FirmwareModule} FirmwareModule
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FirmwareModule.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.type = reader.int32();
                                    break;
                                case 2:
                                    message.index = reader.uint32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        return FirmwareModule;
                    })();
    
                    return Section;
                })();
    
                DescribeStorageReply.Storage = (function() {
    
                    /**
                     * Properties of a Storage.
                     * @memberof particle.ctrl.DescribeStorageReply
                     * @interface IStorage
                     * @property {particle.ctrl.StorageType|null} [type] Storage type
                     * @property {number|null} [flags] Storage flags
                     * @property {Array.<particle.ctrl.DescribeStorageReply.ISection>|null} [sections] Storage sections
                     */
    
                    /**
                     * Constructs a new Storage.
                     * @memberof particle.ctrl.DescribeStorageReply
                     * @classdesc Represents a Storage.
                     * @implements IStorage
                     * @constructor
                     * @param {particle.ctrl.DescribeStorageReply.IStorage=} [properties] Properties to set
                     */
                    function Storage(properties) {
                        this.sections = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Storage type.
                     * @member {particle.ctrl.StorageType} type
                     * @memberof particle.ctrl.DescribeStorageReply.Storage
                     * @instance
                     */
                    Storage.prototype.type = 0;
    
                    /**
                     * Storage flags.
                     * @member {number} flags
                     * @memberof particle.ctrl.DescribeStorageReply.Storage
                     * @instance
                     */
                    Storage.prototype.flags = 0;
    
                    /**
                     * Storage sections.
                     * @member {Array.<particle.ctrl.DescribeStorageReply.ISection>} sections
                     * @memberof particle.ctrl.DescribeStorageReply.Storage
                     * @instance
                     */
                    Storage.prototype.sections = $util.emptyArray;
    
                    /**
                     * Creates a new Storage instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.DescribeStorageReply.Storage
                     * @static
                     * @param {particle.ctrl.DescribeStorageReply.IStorage=} [properties] Properties to set
                     * @returns {particle.ctrl.DescribeStorageReply.Storage} Storage instance
                     */
                    Storage.create = function create(properties) {
                        return new Storage(properties);
                    };
    
                    /**
                     * Encodes the specified Storage message. Does not implicitly {@link particle.ctrl.DescribeStorageReply.Storage.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.DescribeStorageReply.Storage
                     * @static
                     * @param {particle.ctrl.DescribeStorageReply.IStorage} message Storage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Storage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                        if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.flags);
                        if (message.sections != null && message.sections.length)
                            for (var i = 0; i < message.sections.length; ++i)
                                $root.particle.ctrl.DescribeStorageReply.Section.encode(message.sections[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a Storage message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.DescribeStorageReply.Storage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.DescribeStorageReply.Storage} Storage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Storage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageReply.Storage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.type = reader.int32();
                                break;
                            case 2:
                                message.flags = reader.uint32();
                                break;
                            case 3:
                                if (!(message.sections && message.sections.length))
                                    message.sections = [];
                                message.sections.push($root.particle.ctrl.DescribeStorageReply.Section.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return Storage;
                })();
    
                return DescribeStorageReply;
            })();
    
            ctrl.ReadSectionDataRequest = (function() {
    
                /**
                 * Properties of a ReadSectionDataRequest.
                 * @memberof particle.ctrl
                 * @interface IReadSectionDataRequest
                 * @property {number|null} [storage] ReadSectionDataRequest storage
                 * @property {number|null} [section] ReadSectionDataRequest section
                 * @property {number|null} [offset] ReadSectionDataRequest offset
                 * @property {number|null} [size] ReadSectionDataRequest size
                 */
    
                /**
                 * Constructs a new ReadSectionDataRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a ReadSectionDataRequest.
                 * @implements IReadSectionDataRequest
                 * @constructor
                 * @param {particle.ctrl.IReadSectionDataRequest=} [properties] Properties to set
                 */
                function ReadSectionDataRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ReadSectionDataRequest storage.
                 * @member {number} storage
                 * @memberof particle.ctrl.ReadSectionDataRequest
                 * @instance
                 */
                ReadSectionDataRequest.prototype.storage = 0;
    
                /**
                 * ReadSectionDataRequest section.
                 * @member {number} section
                 * @memberof particle.ctrl.ReadSectionDataRequest
                 * @instance
                 */
                ReadSectionDataRequest.prototype.section = 0;
    
                /**
                 * ReadSectionDataRequest offset.
                 * @member {number} offset
                 * @memberof particle.ctrl.ReadSectionDataRequest
                 * @instance
                 */
                ReadSectionDataRequest.prototype.offset = 0;
    
                /**
                 * ReadSectionDataRequest size.
                 * @member {number} size
                 * @memberof particle.ctrl.ReadSectionDataRequest
                 * @instance
                 */
                ReadSectionDataRequest.prototype.size = 0;
    
                /**
                 * Creates a new ReadSectionDataRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.ReadSectionDataRequest
                 * @static
                 * @param {particle.ctrl.IReadSectionDataRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.ReadSectionDataRequest} ReadSectionDataRequest instance
                 */
                ReadSectionDataRequest.create = function create(properties) {
                    return new ReadSectionDataRequest(properties);
                };
    
                /**
                 * Encodes the specified ReadSectionDataRequest message. Does not implicitly {@link particle.ctrl.ReadSectionDataRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.ReadSectionDataRequest
                 * @static
                 * @param {particle.ctrl.IReadSectionDataRequest} message ReadSectionDataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReadSectionDataRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.storage != null && Object.hasOwnProperty.call(message, "storage"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.storage);
                    if (message.section != null && Object.hasOwnProperty.call(message, "section"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.section);
                    if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.offset);
                    if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.size);
                    return writer;
                };
    
                /**
                 * Decodes a ReadSectionDataRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.ReadSectionDataRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.ReadSectionDataRequest} ReadSectionDataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReadSectionDataRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.ReadSectionDataRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.storage = reader.uint32();
                            break;
                        case 2:
                            message.section = reader.uint32();
                            break;
                        case 3:
                            message.offset = reader.uint32();
                            break;
                        case 4:
                            message.size = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return ReadSectionDataRequest;
            })();
    
            ctrl.ReadSectionDataReply = (function() {
    
                /**
                 * Properties of a ReadSectionDataReply.
                 * @memberof particle.ctrl
                 * @interface IReadSectionDataReply
                 * @property {Uint8Array|null} [data] ReadSectionDataReply data
                 */
    
                /**
                 * Constructs a new ReadSectionDataReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a ReadSectionDataReply.
                 * @implements IReadSectionDataReply
                 * @constructor
                 * @param {particle.ctrl.IReadSectionDataReply=} [properties] Properties to set
                 */
                function ReadSectionDataReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ReadSectionDataReply data.
                 * @member {Uint8Array} data
                 * @memberof particle.ctrl.ReadSectionDataReply
                 * @instance
                 */
                ReadSectionDataReply.prototype.data = $util.newBuffer([]);
    
                /**
                 * Creates a new ReadSectionDataReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.ReadSectionDataReply
                 * @static
                 * @param {particle.ctrl.IReadSectionDataReply=} [properties] Properties to set
                 * @returns {particle.ctrl.ReadSectionDataReply} ReadSectionDataReply instance
                 */
                ReadSectionDataReply.create = function create(properties) {
                    return new ReadSectionDataReply(properties);
                };
    
                /**
                 * Encodes the specified ReadSectionDataReply message. Does not implicitly {@link particle.ctrl.ReadSectionDataReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.ReadSectionDataReply
                 * @static
                 * @param {particle.ctrl.IReadSectionDataReply} message ReadSectionDataReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReadSectionDataReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
                    return writer;
                };
    
                /**
                 * Decodes a ReadSectionDataReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.ReadSectionDataReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.ReadSectionDataReply} ReadSectionDataReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReadSectionDataReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.ReadSectionDataReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return ReadSectionDataReply;
            })();
    
            ctrl.WriteSectionDataRequest = (function() {
    
                /**
                 * Properties of a WriteSectionDataRequest.
                 * @memberof particle.ctrl
                 * @interface IWriteSectionDataRequest
                 * @property {number|null} [storage] WriteSectionDataRequest storage
                 * @property {number|null} [section] WriteSectionDataRequest section
                 * @property {number|null} [offset] WriteSectionDataRequest offset
                 * @property {Uint8Array|null} [data] WriteSectionDataRequest data
                 */
    
                /**
                 * Constructs a new WriteSectionDataRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WriteSectionDataRequest.
                 * @implements IWriteSectionDataRequest
                 * @constructor
                 * @param {particle.ctrl.IWriteSectionDataRequest=} [properties] Properties to set
                 */
                function WriteSectionDataRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WriteSectionDataRequest storage.
                 * @member {number} storage
                 * @memberof particle.ctrl.WriteSectionDataRequest
                 * @instance
                 */
                WriteSectionDataRequest.prototype.storage = 0;
    
                /**
                 * WriteSectionDataRequest section.
                 * @member {number} section
                 * @memberof particle.ctrl.WriteSectionDataRequest
                 * @instance
                 */
                WriteSectionDataRequest.prototype.section = 0;
    
                /**
                 * WriteSectionDataRequest offset.
                 * @member {number} offset
                 * @memberof particle.ctrl.WriteSectionDataRequest
                 * @instance
                 */
                WriteSectionDataRequest.prototype.offset = 0;
    
                /**
                 * WriteSectionDataRequest data.
                 * @member {Uint8Array} data
                 * @memberof particle.ctrl.WriteSectionDataRequest
                 * @instance
                 */
                WriteSectionDataRequest.prototype.data = $util.newBuffer([]);
    
                /**
                 * Creates a new WriteSectionDataRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WriteSectionDataRequest
                 * @static
                 * @param {particle.ctrl.IWriteSectionDataRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.WriteSectionDataRequest} WriteSectionDataRequest instance
                 */
                WriteSectionDataRequest.create = function create(properties) {
                    return new WriteSectionDataRequest(properties);
                };
    
                /**
                 * Encodes the specified WriteSectionDataRequest message. Does not implicitly {@link particle.ctrl.WriteSectionDataRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WriteSectionDataRequest
                 * @static
                 * @param {particle.ctrl.IWriteSectionDataRequest} message WriteSectionDataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WriteSectionDataRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.storage != null && Object.hasOwnProperty.call(message, "storage"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.storage);
                    if (message.section != null && Object.hasOwnProperty.call(message, "section"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.section);
                    if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.offset);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
                    return writer;
                };
    
                /**
                 * Decodes a WriteSectionDataRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WriteSectionDataRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WriteSectionDataRequest} WriteSectionDataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WriteSectionDataRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WriteSectionDataRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.storage = reader.uint32();
                            break;
                        case 2:
                            message.section = reader.uint32();
                            break;
                        case 3:
                            message.offset = reader.uint32();
                            break;
                        case 4:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WriteSectionDataRequest;
            })();
    
            ctrl.WriteSectionDataReply = (function() {
    
                /**
                 * Properties of a WriteSectionDataReply.
                 * @memberof particle.ctrl
                 * @interface IWriteSectionDataReply
                 */
    
                /**
                 * Constructs a new WriteSectionDataReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WriteSectionDataReply.
                 * @implements IWriteSectionDataReply
                 * @constructor
                 * @param {particle.ctrl.IWriteSectionDataReply=} [properties] Properties to set
                 */
                function WriteSectionDataReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WriteSectionDataReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WriteSectionDataReply
                 * @static
                 * @param {particle.ctrl.IWriteSectionDataReply=} [properties] Properties to set
                 * @returns {particle.ctrl.WriteSectionDataReply} WriteSectionDataReply instance
                 */
                WriteSectionDataReply.create = function create(properties) {
                    return new WriteSectionDataReply(properties);
                };
    
                /**
                 * Encodes the specified WriteSectionDataReply message. Does not implicitly {@link particle.ctrl.WriteSectionDataReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WriteSectionDataReply
                 * @static
                 * @param {particle.ctrl.IWriteSectionDataReply} message WriteSectionDataReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WriteSectionDataReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WriteSectionDataReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WriteSectionDataReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WriteSectionDataReply} WriteSectionDataReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WriteSectionDataReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WriteSectionDataReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WriteSectionDataReply;
            })();
    
            ctrl.ClearSectionDataRequest = (function() {
    
                /**
                 * Properties of a ClearSectionDataRequest.
                 * @memberof particle.ctrl
                 * @interface IClearSectionDataRequest
                 * @property {number|null} [storage] ClearSectionDataRequest storage
                 * @property {number|null} [section] ClearSectionDataRequest section
                 */
    
                /**
                 * Constructs a new ClearSectionDataRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a ClearSectionDataRequest.
                 * @implements IClearSectionDataRequest
                 * @constructor
                 * @param {particle.ctrl.IClearSectionDataRequest=} [properties] Properties to set
                 */
                function ClearSectionDataRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ClearSectionDataRequest storage.
                 * @member {number} storage
                 * @memberof particle.ctrl.ClearSectionDataRequest
                 * @instance
                 */
                ClearSectionDataRequest.prototype.storage = 0;
    
                /**
                 * ClearSectionDataRequest section.
                 * @member {number} section
                 * @memberof particle.ctrl.ClearSectionDataRequest
                 * @instance
                 */
                ClearSectionDataRequest.prototype.section = 0;
    
                /**
                 * Creates a new ClearSectionDataRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.ClearSectionDataRequest
                 * @static
                 * @param {particle.ctrl.IClearSectionDataRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.ClearSectionDataRequest} ClearSectionDataRequest instance
                 */
                ClearSectionDataRequest.create = function create(properties) {
                    return new ClearSectionDataRequest(properties);
                };
    
                /**
                 * Encodes the specified ClearSectionDataRequest message. Does not implicitly {@link particle.ctrl.ClearSectionDataRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.ClearSectionDataRequest
                 * @static
                 * @param {particle.ctrl.IClearSectionDataRequest} message ClearSectionDataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClearSectionDataRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.storage != null && Object.hasOwnProperty.call(message, "storage"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.storage);
                    if (message.section != null && Object.hasOwnProperty.call(message, "section"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.section);
                    return writer;
                };
    
                /**
                 * Decodes a ClearSectionDataRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.ClearSectionDataRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.ClearSectionDataRequest} ClearSectionDataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClearSectionDataRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.ClearSectionDataRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.storage = reader.uint32();
                            break;
                        case 2:
                            message.section = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return ClearSectionDataRequest;
            })();
    
            ctrl.ClearSectionDataReply = (function() {
    
                /**
                 * Properties of a ClearSectionDataReply.
                 * @memberof particle.ctrl
                 * @interface IClearSectionDataReply
                 */
    
                /**
                 * Constructs a new ClearSectionDataReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a ClearSectionDataReply.
                 * @implements IClearSectionDataReply
                 * @constructor
                 * @param {particle.ctrl.IClearSectionDataReply=} [properties] Properties to set
                 */
                function ClearSectionDataReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ClearSectionDataReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.ClearSectionDataReply
                 * @static
                 * @param {particle.ctrl.IClearSectionDataReply=} [properties] Properties to set
                 * @returns {particle.ctrl.ClearSectionDataReply} ClearSectionDataReply instance
                 */
                ClearSectionDataReply.create = function create(properties) {
                    return new ClearSectionDataReply(properties);
                };
    
                /**
                 * Encodes the specified ClearSectionDataReply message. Does not implicitly {@link particle.ctrl.ClearSectionDataReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.ClearSectionDataReply
                 * @static
                 * @param {particle.ctrl.IClearSectionDataReply} message ClearSectionDataReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClearSectionDataReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a ClearSectionDataReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.ClearSectionDataReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.ClearSectionDataReply} ClearSectionDataReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClearSectionDataReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.ClearSectionDataReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return ClearSectionDataReply;
            })();
    
            ctrl.GetSectionDataSizeRequest = (function() {
    
                /**
                 * Properties of a GetSectionDataSizeRequest.
                 * @memberof particle.ctrl
                 * @interface IGetSectionDataSizeRequest
                 * @property {number|null} [storage] GetSectionDataSizeRequest storage
                 * @property {number|null} [section] GetSectionDataSizeRequest section
                 */
    
                /**
                 * Constructs a new GetSectionDataSizeRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetSectionDataSizeRequest.
                 * @implements IGetSectionDataSizeRequest
                 * @constructor
                 * @param {particle.ctrl.IGetSectionDataSizeRequest=} [properties] Properties to set
                 */
                function GetSectionDataSizeRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetSectionDataSizeRequest storage.
                 * @member {number} storage
                 * @memberof particle.ctrl.GetSectionDataSizeRequest
                 * @instance
                 */
                GetSectionDataSizeRequest.prototype.storage = 0;
    
                /**
                 * GetSectionDataSizeRequest section.
                 * @member {number} section
                 * @memberof particle.ctrl.GetSectionDataSizeRequest
                 * @instance
                 */
                GetSectionDataSizeRequest.prototype.section = 0;
    
                /**
                 * Creates a new GetSectionDataSizeRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetSectionDataSizeRequest
                 * @static
                 * @param {particle.ctrl.IGetSectionDataSizeRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetSectionDataSizeRequest} GetSectionDataSizeRequest instance
                 */
                GetSectionDataSizeRequest.create = function create(properties) {
                    return new GetSectionDataSizeRequest(properties);
                };
    
                /**
                 * Encodes the specified GetSectionDataSizeRequest message. Does not implicitly {@link particle.ctrl.GetSectionDataSizeRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetSectionDataSizeRequest
                 * @static
                 * @param {particle.ctrl.IGetSectionDataSizeRequest} message GetSectionDataSizeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetSectionDataSizeRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.storage != null && Object.hasOwnProperty.call(message, "storage"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.storage);
                    if (message.section != null && Object.hasOwnProperty.call(message, "section"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.section);
                    return writer;
                };
    
                /**
                 * Decodes a GetSectionDataSizeRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetSectionDataSizeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetSectionDataSizeRequest} GetSectionDataSizeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetSectionDataSizeRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSectionDataSizeRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.storage = reader.uint32();
                            break;
                        case 2:
                            message.section = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetSectionDataSizeRequest;
            })();
    
            ctrl.GetSectionDataSizeReply = (function() {
    
                /**
                 * Properties of a GetSectionDataSizeReply.
                 * @memberof particle.ctrl
                 * @interface IGetSectionDataSizeReply
                 * @property {number|null} [size] GetSectionDataSizeReply size
                 */
    
                /**
                 * Constructs a new GetSectionDataSizeReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetSectionDataSizeReply.
                 * @implements IGetSectionDataSizeReply
                 * @constructor
                 * @param {particle.ctrl.IGetSectionDataSizeReply=} [properties] Properties to set
                 */
                function GetSectionDataSizeReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetSectionDataSizeReply size.
                 * @member {number} size
                 * @memberof particle.ctrl.GetSectionDataSizeReply
                 * @instance
                 */
                GetSectionDataSizeReply.prototype.size = 0;
    
                /**
                 * Creates a new GetSectionDataSizeReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetSectionDataSizeReply
                 * @static
                 * @param {particle.ctrl.IGetSectionDataSizeReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetSectionDataSizeReply} GetSectionDataSizeReply instance
                 */
                GetSectionDataSizeReply.create = function create(properties) {
                    return new GetSectionDataSizeReply(properties);
                };
    
                /**
                 * Encodes the specified GetSectionDataSizeReply message. Does not implicitly {@link particle.ctrl.GetSectionDataSizeReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetSectionDataSizeReply
                 * @static
                 * @param {particle.ctrl.IGetSectionDataSizeReply} message GetSectionDataSizeReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetSectionDataSizeReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.size);
                    return writer;
                };
    
                /**
                 * Decodes a GetSectionDataSizeReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetSectionDataSizeReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetSectionDataSizeReply} GetSectionDataSizeReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetSectionDataSizeReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSectionDataSizeReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.size = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetSectionDataSizeReply;
            })();
    
            ctrl.GetModuleInfoRequest = (function() {
    
                /**
                 * Properties of a GetModuleInfoRequest.
                 * @memberof particle.ctrl
                 * @interface IGetModuleInfoRequest
                 */
    
                /**
                 * Constructs a new GetModuleInfoRequest.
                 * @memberof particle.ctrl
                 * @classdesc Get firmware module info.
                 * @implements IGetModuleInfoRequest
                 * @constructor
                 * @param {particle.ctrl.IGetModuleInfoRequest=} [properties] Properties to set
                 */
                function GetModuleInfoRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new GetModuleInfoRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetModuleInfoRequest
                 * @static
                 * @param {particle.ctrl.IGetModuleInfoRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.GetModuleInfoRequest} GetModuleInfoRequest instance
                 */
                GetModuleInfoRequest.create = function create(properties) {
                    return new GetModuleInfoRequest(properties);
                };
    
                /**
                 * Encodes the specified GetModuleInfoRequest message. Does not implicitly {@link particle.ctrl.GetModuleInfoRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetModuleInfoRequest
                 * @static
                 * @param {particle.ctrl.IGetModuleInfoRequest} message GetModuleInfoRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetModuleInfoRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a GetModuleInfoRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetModuleInfoRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetModuleInfoRequest} GetModuleInfoRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetModuleInfoRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetModuleInfoRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return GetModuleInfoRequest;
            })();
    
            ctrl.GetModuleInfoReply = (function() {
    
                /**
                 * Properties of a GetModuleInfoReply.
                 * @memberof particle.ctrl
                 * @interface IGetModuleInfoReply
                 * @property {Array.<particle.ctrl.GetModuleInfoReply.IModule>|null} [modules] GetModuleInfoReply modules
                 */
    
                /**
                 * Constructs a new GetModuleInfoReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a GetModuleInfoReply.
                 * @implements IGetModuleInfoReply
                 * @constructor
                 * @param {particle.ctrl.IGetModuleInfoReply=} [properties] Properties to set
                 */
                function GetModuleInfoReply(properties) {
                    this.modules = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GetModuleInfoReply modules.
                 * @member {Array.<particle.ctrl.GetModuleInfoReply.IModule>} modules
                 * @memberof particle.ctrl.GetModuleInfoReply
                 * @instance
                 */
                GetModuleInfoReply.prototype.modules = $util.emptyArray;
    
                /**
                 * Creates a new GetModuleInfoReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.GetModuleInfoReply
                 * @static
                 * @param {particle.ctrl.IGetModuleInfoReply=} [properties] Properties to set
                 * @returns {particle.ctrl.GetModuleInfoReply} GetModuleInfoReply instance
                 */
                GetModuleInfoReply.create = function create(properties) {
                    return new GetModuleInfoReply(properties);
                };
    
                /**
                 * Encodes the specified GetModuleInfoReply message. Does not implicitly {@link particle.ctrl.GetModuleInfoReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.GetModuleInfoReply
                 * @static
                 * @param {particle.ctrl.IGetModuleInfoReply} message GetModuleInfoReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetModuleInfoReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.modules != null && message.modules.length)
                        for (var i = 0; i < message.modules.length; ++i)
                            $root.particle.ctrl.GetModuleInfoReply.Module.encode(message.modules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a GetModuleInfoReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.GetModuleInfoReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.GetModuleInfoReply} GetModuleInfoReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetModuleInfoReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetModuleInfoReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.modules && message.modules.length))
                                message.modules = [];
                            message.modules.push($root.particle.ctrl.GetModuleInfoReply.Module.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                GetModuleInfoReply.Dependency = (function() {
    
                    /**
                     * Properties of a Dependency.
                     * @memberof particle.ctrl.GetModuleInfoReply
                     * @interface IDependency
                     * @property {particle.ctrl.FirmwareModuleType|null} [type] Dependency type
                     * @property {number|null} [index] Dependency index
                     * @property {number|null} [version] Dependency version
                     */
    
                    /**
                     * Constructs a new Dependency.
                     * @memberof particle.ctrl.GetModuleInfoReply
                     * @classdesc Represents a Dependency.
                     * @implements IDependency
                     * @constructor
                     * @param {particle.ctrl.GetModuleInfoReply.IDependency=} [properties] Properties to set
                     */
                    function Dependency(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Dependency type.
                     * @member {particle.ctrl.FirmwareModuleType} type
                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency
                     * @instance
                     */
                    Dependency.prototype.type = 0;
    
                    /**
                     * Dependency index.
                     * @member {number} index
                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency
                     * @instance
                     */
                    Dependency.prototype.index = 0;
    
                    /**
                     * Dependency version.
                     * @member {number} version
                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency
                     * @instance
                     */
                    Dependency.prototype.version = 0;
    
                    /**
                     * Creates a new Dependency instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency
                     * @static
                     * @param {particle.ctrl.GetModuleInfoReply.IDependency=} [properties] Properties to set
                     * @returns {particle.ctrl.GetModuleInfoReply.Dependency} Dependency instance
                     */
                    Dependency.create = function create(properties) {
                        return new Dependency(properties);
                    };
    
                    /**
                     * Encodes the specified Dependency message. Does not implicitly {@link particle.ctrl.GetModuleInfoReply.Dependency.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency
                     * @static
                     * @param {particle.ctrl.GetModuleInfoReply.IDependency} message Dependency message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Dependency.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                        if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);
                        return writer;
                    };
    
                    /**
                     * Decodes a Dependency message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.GetModuleInfoReply.Dependency} Dependency
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Dependency.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetModuleInfoReply.Dependency();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.type = reader.int32();
                                break;
                            case 2:
                                message.index = reader.uint32();
                                break;
                            case 3:
                                message.version = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return Dependency;
                })();
    
                GetModuleInfoReply.Module = (function() {
    
                    /**
                     * Properties of a Module.
                     * @memberof particle.ctrl.GetModuleInfoReply
                     * @interface IModule
                     * @property {particle.ctrl.FirmwareModuleType|null} [type] Module type
                     * @property {number|null} [index] Module index
                     * @property {number|null} [version] Module version
                     * @property {number|null} [size] Module size
                     * @property {number|null} [validity] Module validity
                     * @property {Array.<particle.ctrl.GetModuleInfoReply.IDependency>|null} [dependencies] Module dependencies
                     */
    
                    /**
                     * Constructs a new Module.
                     * @memberof particle.ctrl.GetModuleInfoReply
                     * @classdesc Represents a Module.
                     * @implements IModule
                     * @constructor
                     * @param {particle.ctrl.GetModuleInfoReply.IModule=} [properties] Properties to set
                     */
                    function Module(properties) {
                        this.dependencies = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Module type.
                     * @member {particle.ctrl.FirmwareModuleType} type
                     * @memberof particle.ctrl.GetModuleInfoReply.Module
                     * @instance
                     */
                    Module.prototype.type = 0;
    
                    /**
                     * Module index.
                     * @member {number} index
                     * @memberof particle.ctrl.GetModuleInfoReply.Module
                     * @instance
                     */
                    Module.prototype.index = 0;
    
                    /**
                     * Module version.
                     * @member {number} version
                     * @memberof particle.ctrl.GetModuleInfoReply.Module
                     * @instance
                     */
                    Module.prototype.version = 0;
    
                    /**
                     * Module size.
                     * @member {number} size
                     * @memberof particle.ctrl.GetModuleInfoReply.Module
                     * @instance
                     */
                    Module.prototype.size = 0;
    
                    /**
                     * Module validity.
                     * @member {number} validity
                     * @memberof particle.ctrl.GetModuleInfoReply.Module
                     * @instance
                     */
                    Module.prototype.validity = 0;
    
                    /**
                     * Module dependencies.
                     * @member {Array.<particle.ctrl.GetModuleInfoReply.IDependency>} dependencies
                     * @memberof particle.ctrl.GetModuleInfoReply.Module
                     * @instance
                     */
                    Module.prototype.dependencies = $util.emptyArray;
    
                    /**
                     * Creates a new Module instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.GetModuleInfoReply.Module
                     * @static
                     * @param {particle.ctrl.GetModuleInfoReply.IModule=} [properties] Properties to set
                     * @returns {particle.ctrl.GetModuleInfoReply.Module} Module instance
                     */
                    Module.create = function create(properties) {
                        return new Module(properties);
                    };
    
                    /**
                     * Encodes the specified Module message. Does not implicitly {@link particle.ctrl.GetModuleInfoReply.Module.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.GetModuleInfoReply.Module
                     * @static
                     * @param {particle.ctrl.GetModuleInfoReply.IModule} message Module message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Module.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                        if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);
                        if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.size);
                        if (message.validity != null && Object.hasOwnProperty.call(message, "validity"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.validity);
                        if (message.dependencies != null && message.dependencies.length)
                            for (var i = 0; i < message.dependencies.length; ++i)
                                $root.particle.ctrl.GetModuleInfoReply.Dependency.encode(message.dependencies[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a Module message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.GetModuleInfoReply.Module
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.GetModuleInfoReply.Module} Module
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Module.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetModuleInfoReply.Module();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.type = reader.int32();
                                break;
                            case 2:
                                message.index = reader.uint32();
                                break;
                            case 3:
                                message.version = reader.uint32();
                                break;
                            case 4:
                                message.size = reader.uint32();
                                break;
                            case 5:
                                message.validity = reader.uint32();
                                break;
                            case 6:
                                if (!(message.dependencies && message.dependencies.length))
                                    message.dependencies = [];
                                message.dependencies.push($root.particle.ctrl.GetModuleInfoReply.Dependency.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return Module;
                })();
    
                return GetModuleInfoReply;
            })();
    
            ctrl.wifi = (function() {
    
                /**
                 * Namespace wifi.
                 * @memberof particle.ctrl
                 * @namespace
                 */
                var wifi = {};
    
                /**
                 * WiFi security types.
                 * 
                 * Note: The values of this enum should match the values defined by the `WifiSecurity` enum in
                 * the firmware.
                 * @name particle.ctrl.wifi.Security
                 * @enum {number}
                 * @property {number} NO_SECURITY=0 NO_SECURITY value
                 * @property {number} WEP=1 WEP value
                 * @property {number} WPA_PSK=2 WPA_PSK value
                 * @property {number} WPA2_PSK=3 WPA2_PSK value
                 * @property {number} WPA_WPA2_PSK=4 WPA_WPA2_PSK value
                 */
                wifi.Security = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NO_SECURITY"] = 0;
                    values[valuesById[1] = "WEP"] = 1;
                    values[valuesById[2] = "WPA_PSK"] = 2;
                    values[valuesById[3] = "WPA2_PSK"] = 3;
                    values[valuesById[4] = "WPA_WPA2_PSK"] = 4;
                    return values;
                })();
    
                /**
                 * Network credential types.
                 * 
                 * Note: The values of this enum should match the values defined by the `WiFiCredentials::Type` enum
                 * in the firmware.
                 * @name particle.ctrl.wifi.CredentialsType
                 * @enum {number}
                 * @property {number} NO_CREDENTIALS=0 NO_CREDENTIALS value
                 * @property {number} PASSWORD=1 PASSWORD value
                 */
                wifi.CredentialsType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NO_CREDENTIALS"] = 0;
                    values[valuesById[1] = "PASSWORD"] = 1;
                    return values;
                })();
    
                wifi.Credentials = (function() {
    
                    /**
                     * Properties of a Credentials.
                     * @memberof particle.ctrl.wifi
                     * @interface ICredentials
                     * @property {particle.ctrl.wifi.CredentialsType|null} [type] Credentials type
                     * @property {string|null} [password] Credentials password
                     */
    
                    /**
                     * Constructs a new Credentials.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Network credentials.
                     * @implements ICredentials
                     * @constructor
                     * @param {particle.ctrl.wifi.ICredentials=} [properties] Properties to set
                     */
                    function Credentials(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Credentials type.
                     * @member {particle.ctrl.wifi.CredentialsType} type
                     * @memberof particle.ctrl.wifi.Credentials
                     * @instance
                     */
                    Credentials.prototype.type = 0;
    
                    /**
                     * Credentials password.
                     * @member {string} password
                     * @memberof particle.ctrl.wifi.Credentials
                     * @instance
                     */
                    Credentials.prototype.password = "";
    
                    /**
                     * Creates a new Credentials instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.Credentials
                     * @static
                     * @param {particle.ctrl.wifi.ICredentials=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.Credentials} Credentials instance
                     */
                    Credentials.create = function create(properties) {
                        return new Credentials(properties);
                    };
    
                    /**
                     * Encodes the specified Credentials message. Does not implicitly {@link particle.ctrl.wifi.Credentials.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.Credentials
                     * @static
                     * @param {particle.ctrl.wifi.ICredentials} message Credentials message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Credentials.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                        if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
                        return writer;
                    };
    
                    /**
                     * Decodes a Credentials message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.Credentials
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.Credentials} Credentials
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Credentials.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.Credentials();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.type = reader.int32();
                                break;
                            case 2:
                                message.password = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return Credentials;
                })();
    
                wifi.JoinNewNetworkRequest = (function() {
    
                    /**
                     * Properties of a JoinNewNetworkRequest.
                     * @memberof particle.ctrl.wifi
                     * @interface IJoinNewNetworkRequest
                     * @property {string|null} [ssid] JoinNewNetworkRequest ssid
                     * @property {Uint8Array|null} [bssid] JoinNewNetworkRequest bssid
                     * @property {particle.ctrl.wifi.Security|null} [security] JoinNewNetworkRequest security
                     * @property {particle.ctrl.wifi.ICredentials|null} [credentials] JoinNewNetworkRequest credentials
                     * @property {particle.ctrl.IInterface|null} [interfaceConfig] JoinNewNetworkRequest interfaceConfig
                     */
    
                    /**
                     * Constructs a new JoinNewNetworkRequest.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Join a new network.
                     * 
                     * On success, the network credentials get saved to a persistent storage.
                     * @implements IJoinNewNetworkRequest
                     * @constructor
                     * @param {particle.ctrl.wifi.IJoinNewNetworkRequest=} [properties] Properties to set
                     */
                    function JoinNewNetworkRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * JoinNewNetworkRequest ssid.
                     * @member {string} ssid
                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest
                     * @instance
                     */
                    JoinNewNetworkRequest.prototype.ssid = "";
    
                    /**
                     * JoinNewNetworkRequest bssid.
                     * @member {Uint8Array} bssid
                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest
                     * @instance
                     */
                    JoinNewNetworkRequest.prototype.bssid = $util.newBuffer([]);
    
                    /**
                     * JoinNewNetworkRequest security.
                     * @member {particle.ctrl.wifi.Security} security
                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest
                     * @instance
                     */
                    JoinNewNetworkRequest.prototype.security = 0;
    
                    /**
                     * JoinNewNetworkRequest credentials.
                     * @member {particle.ctrl.wifi.ICredentials|null|undefined} credentials
                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest
                     * @instance
                     */
                    JoinNewNetworkRequest.prototype.credentials = null;
    
                    /**
                     * JoinNewNetworkRequest interfaceConfig.
                     * @member {particle.ctrl.IInterface|null|undefined} interfaceConfig
                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest
                     * @instance
                     */
                    JoinNewNetworkRequest.prototype.interfaceConfig = null;
    
                    /**
                     * Creates a new JoinNewNetworkRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest
                     * @static
                     * @param {particle.ctrl.wifi.IJoinNewNetworkRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.JoinNewNetworkRequest} JoinNewNetworkRequest instance
                     */
                    JoinNewNetworkRequest.create = function create(properties) {
                        return new JoinNewNetworkRequest(properties);
                    };
    
                    /**
                     * Encodes the specified JoinNewNetworkRequest message. Does not implicitly {@link particle.ctrl.wifi.JoinNewNetworkRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest
                     * @static
                     * @param {particle.ctrl.wifi.IJoinNewNetworkRequest} message JoinNewNetworkRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JoinNewNetworkRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ssid != null && Object.hasOwnProperty.call(message, "ssid"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);
                        if (message.bssid != null && Object.hasOwnProperty.call(message, "bssid"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);
                        if (message.security != null && Object.hasOwnProperty.call(message, "security"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.security);
                        if (message.credentials != null && Object.hasOwnProperty.call(message, "credentials"))
                            $root.particle.ctrl.wifi.Credentials.encode(message.credentials, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.interfaceConfig != null && Object.hasOwnProperty.call(message, "interfaceConfig"))
                            $root.particle.ctrl.Interface.encode(message.interfaceConfig, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a JoinNewNetworkRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.JoinNewNetworkRequest} JoinNewNetworkRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JoinNewNetworkRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.JoinNewNetworkRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ssid = reader.string();
                                break;
                            case 2:
                                message.bssid = reader.bytes();
                                break;
                            case 3:
                                message.security = reader.int32();
                                break;
                            case 4:
                                message.credentials = $root.particle.ctrl.wifi.Credentials.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.interfaceConfig = $root.particle.ctrl.Interface.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return JoinNewNetworkRequest;
                })();
    
                wifi.JoinNewNetworkReply = (function() {
    
                    /**
                     * Properties of a JoinNewNetworkReply.
                     * @memberof particle.ctrl.wifi
                     * @interface IJoinNewNetworkReply
                     */
    
                    /**
                     * Constructs a new JoinNewNetworkReply.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Represents a JoinNewNetworkReply.
                     * @implements IJoinNewNetworkReply
                     * @constructor
                     * @param {particle.ctrl.wifi.IJoinNewNetworkReply=} [properties] Properties to set
                     */
                    function JoinNewNetworkReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new JoinNewNetworkReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.JoinNewNetworkReply
                     * @static
                     * @param {particle.ctrl.wifi.IJoinNewNetworkReply=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.JoinNewNetworkReply} JoinNewNetworkReply instance
                     */
                    JoinNewNetworkReply.create = function create(properties) {
                        return new JoinNewNetworkReply(properties);
                    };
    
                    /**
                     * Encodes the specified JoinNewNetworkReply message. Does not implicitly {@link particle.ctrl.wifi.JoinNewNetworkReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.JoinNewNetworkReply
                     * @static
                     * @param {particle.ctrl.wifi.IJoinNewNetworkReply} message JoinNewNetworkReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JoinNewNetworkReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a JoinNewNetworkReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.JoinNewNetworkReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.JoinNewNetworkReply} JoinNewNetworkReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JoinNewNetworkReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.JoinNewNetworkReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return JoinNewNetworkReply;
                })();
    
                wifi.JoinKnownNetworkRequest = (function() {
    
                    /**
                     * Properties of a JoinKnownNetworkRequest.
                     * @memberof particle.ctrl.wifi
                     * @interface IJoinKnownNetworkRequest
                     * @property {string|null} [ssid] JoinKnownNetworkRequest ssid
                     */
    
                    /**
                     * Constructs a new JoinKnownNetworkRequest.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Join a known network.
                     * @implements IJoinKnownNetworkRequest
                     * @constructor
                     * @param {particle.ctrl.wifi.IJoinKnownNetworkRequest=} [properties] Properties to set
                     */
                    function JoinKnownNetworkRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * JoinKnownNetworkRequest ssid.
                     * @member {string} ssid
                     * @memberof particle.ctrl.wifi.JoinKnownNetworkRequest
                     * @instance
                     */
                    JoinKnownNetworkRequest.prototype.ssid = "";
    
                    /**
                     * Creates a new JoinKnownNetworkRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.JoinKnownNetworkRequest
                     * @static
                     * @param {particle.ctrl.wifi.IJoinKnownNetworkRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.JoinKnownNetworkRequest} JoinKnownNetworkRequest instance
                     */
                    JoinKnownNetworkRequest.create = function create(properties) {
                        return new JoinKnownNetworkRequest(properties);
                    };
    
                    /**
                     * Encodes the specified JoinKnownNetworkRequest message. Does not implicitly {@link particle.ctrl.wifi.JoinKnownNetworkRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.JoinKnownNetworkRequest
                     * @static
                     * @param {particle.ctrl.wifi.IJoinKnownNetworkRequest} message JoinKnownNetworkRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JoinKnownNetworkRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ssid != null && Object.hasOwnProperty.call(message, "ssid"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);
                        return writer;
                    };
    
                    /**
                     * Decodes a JoinKnownNetworkRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.JoinKnownNetworkRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.JoinKnownNetworkRequest} JoinKnownNetworkRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JoinKnownNetworkRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.JoinKnownNetworkRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ssid = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return JoinKnownNetworkRequest;
                })();
    
                wifi.JoinKnownNetworkReply = (function() {
    
                    /**
                     * Properties of a JoinKnownNetworkReply.
                     * @memberof particle.ctrl.wifi
                     * @interface IJoinKnownNetworkReply
                     */
    
                    /**
                     * Constructs a new JoinKnownNetworkReply.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Represents a JoinKnownNetworkReply.
                     * @implements IJoinKnownNetworkReply
                     * @constructor
                     * @param {particle.ctrl.wifi.IJoinKnownNetworkReply=} [properties] Properties to set
                     */
                    function JoinKnownNetworkReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new JoinKnownNetworkReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.JoinKnownNetworkReply
                     * @static
                     * @param {particle.ctrl.wifi.IJoinKnownNetworkReply=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.JoinKnownNetworkReply} JoinKnownNetworkReply instance
                     */
                    JoinKnownNetworkReply.create = function create(properties) {
                        return new JoinKnownNetworkReply(properties);
                    };
    
                    /**
                     * Encodes the specified JoinKnownNetworkReply message. Does not implicitly {@link particle.ctrl.wifi.JoinKnownNetworkReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.JoinKnownNetworkReply
                     * @static
                     * @param {particle.ctrl.wifi.IJoinKnownNetworkReply} message JoinKnownNetworkReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JoinKnownNetworkReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a JoinKnownNetworkReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.JoinKnownNetworkReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.JoinKnownNetworkReply} JoinKnownNetworkReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JoinKnownNetworkReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.JoinKnownNetworkReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return JoinKnownNetworkReply;
                })();
    
                wifi.GetKnownNetworksRequest = (function() {
    
                    /**
                     * Properties of a GetKnownNetworksRequest.
                     * @memberof particle.ctrl.wifi
                     * @interface IGetKnownNetworksRequest
                     */
    
                    /**
                     * Constructs a new GetKnownNetworksRequest.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Get the list of known networks.
                     * @implements IGetKnownNetworksRequest
                     * @constructor
                     * @param {particle.ctrl.wifi.IGetKnownNetworksRequest=} [properties] Properties to set
                     */
                    function GetKnownNetworksRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new GetKnownNetworksRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.GetKnownNetworksRequest
                     * @static
                     * @param {particle.ctrl.wifi.IGetKnownNetworksRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.GetKnownNetworksRequest} GetKnownNetworksRequest instance
                     */
                    GetKnownNetworksRequest.create = function create(properties) {
                        return new GetKnownNetworksRequest(properties);
                    };
    
                    /**
                     * Encodes the specified GetKnownNetworksRequest message. Does not implicitly {@link particle.ctrl.wifi.GetKnownNetworksRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.GetKnownNetworksRequest
                     * @static
                     * @param {particle.ctrl.wifi.IGetKnownNetworksRequest} message GetKnownNetworksRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetKnownNetworksRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a GetKnownNetworksRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.GetKnownNetworksRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.GetKnownNetworksRequest} GetKnownNetworksRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetKnownNetworksRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetKnownNetworksRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetKnownNetworksRequest;
                })();
    
                wifi.GetKnownNetworksReply = (function() {
    
                    /**
                     * Properties of a GetKnownNetworksReply.
                     * @memberof particle.ctrl.wifi
                     * @interface IGetKnownNetworksReply
                     * @property {Array.<particle.ctrl.wifi.GetKnownNetworksReply.INetwork>|null} [networks] GetKnownNetworksReply networks
                     */
    
                    /**
                     * Constructs a new GetKnownNetworksReply.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Represents a GetKnownNetworksReply.
                     * @implements IGetKnownNetworksReply
                     * @constructor
                     * @param {particle.ctrl.wifi.IGetKnownNetworksReply=} [properties] Properties to set
                     */
                    function GetKnownNetworksReply(properties) {
                        this.networks = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * GetKnownNetworksReply networks.
                     * @member {Array.<particle.ctrl.wifi.GetKnownNetworksReply.INetwork>} networks
                     * @memberof particle.ctrl.wifi.GetKnownNetworksReply
                     * @instance
                     */
                    GetKnownNetworksReply.prototype.networks = $util.emptyArray;
    
                    /**
                     * Creates a new GetKnownNetworksReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.GetKnownNetworksReply
                     * @static
                     * @param {particle.ctrl.wifi.IGetKnownNetworksReply=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.GetKnownNetworksReply} GetKnownNetworksReply instance
                     */
                    GetKnownNetworksReply.create = function create(properties) {
                        return new GetKnownNetworksReply(properties);
                    };
    
                    /**
                     * Encodes the specified GetKnownNetworksReply message. Does not implicitly {@link particle.ctrl.wifi.GetKnownNetworksReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.GetKnownNetworksReply
                     * @static
                     * @param {particle.ctrl.wifi.IGetKnownNetworksReply} message GetKnownNetworksReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetKnownNetworksReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.networks != null && message.networks.length)
                            for (var i = 0; i < message.networks.length; ++i)
                                $root.particle.ctrl.wifi.GetKnownNetworksReply.Network.encode(message.networks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a GetKnownNetworksReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.GetKnownNetworksReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.GetKnownNetworksReply} GetKnownNetworksReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetKnownNetworksReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetKnownNetworksReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.networks && message.networks.length))
                                    message.networks = [];
                                message.networks.push($root.particle.ctrl.wifi.GetKnownNetworksReply.Network.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    GetKnownNetworksReply.Network = (function() {
    
                        /**
                         * Properties of a Network.
                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply
                         * @interface INetwork
                         * @property {string|null} [ssid] Network ssid
                         * @property {particle.ctrl.wifi.Security|null} [security] Network security
                         * @property {particle.ctrl.wifi.CredentialsType|null} [credentialsType] Network credentialsType
                         */
    
                        /**
                         * Constructs a new Network.
                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply
                         * @classdesc Represents a Network.
                         * @implements INetwork
                         * @constructor
                         * @param {particle.ctrl.wifi.GetKnownNetworksReply.INetwork=} [properties] Properties to set
                         */
                        function Network(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Network ssid.
                         * @member {string} ssid
                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network
                         * @instance
                         */
                        Network.prototype.ssid = "";
    
                        /**
                         * Network security.
                         * @member {particle.ctrl.wifi.Security} security
                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network
                         * @instance
                         */
                        Network.prototype.security = 0;
    
                        /**
                         * Network credentialsType.
                         * @member {particle.ctrl.wifi.CredentialsType} credentialsType
                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network
                         * @instance
                         */
                        Network.prototype.credentialsType = 0;
    
                        /**
                         * Creates a new Network instance using the specified properties.
                         * @function create
                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network
                         * @static
                         * @param {particle.ctrl.wifi.GetKnownNetworksReply.INetwork=} [properties] Properties to set
                         * @returns {particle.ctrl.wifi.GetKnownNetworksReply.Network} Network instance
                         */
                        Network.create = function create(properties) {
                            return new Network(properties);
                        };
    
                        /**
                         * Encodes the specified Network message. Does not implicitly {@link particle.ctrl.wifi.GetKnownNetworksReply.Network.verify|verify} messages.
                         * @function encode
                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network
                         * @static
                         * @param {particle.ctrl.wifi.GetKnownNetworksReply.INetwork} message Network message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Network.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.ssid != null && Object.hasOwnProperty.call(message, "ssid"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);
                            if (message.security != null && Object.hasOwnProperty.call(message, "security"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.security);
                            if (message.credentialsType != null && Object.hasOwnProperty.call(message, "credentialsType"))
                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.credentialsType);
                            return writer;
                        };
    
                        /**
                         * Decodes a Network message from the specified reader or buffer.
                         * @function decode
                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {particle.ctrl.wifi.GetKnownNetworksReply.Network} Network
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Network.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetKnownNetworksReply.Network();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.ssid = reader.string();
                                    break;
                                case 2:
                                    message.security = reader.int32();
                                    break;
                                case 3:
                                    message.credentialsType = reader.int32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        return Network;
                    })();
    
                    return GetKnownNetworksReply;
                })();
    
                wifi.RemoveKnownNetworkRequest = (function() {
    
                    /**
                     * Properties of a RemoveKnownNetworkRequest.
                     * @memberof particle.ctrl.wifi
                     * @interface IRemoveKnownNetworkRequest
                     * @property {string|null} [ssid] RemoveKnownNetworkRequest ssid
                     */
    
                    /**
                     * Constructs a new RemoveKnownNetworkRequest.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Remove the network from the list of known networks.
                     * @implements IRemoveKnownNetworkRequest
                     * @constructor
                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkRequest=} [properties] Properties to set
                     */
                    function RemoveKnownNetworkRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * RemoveKnownNetworkRequest ssid.
                     * @member {string} ssid
                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkRequest
                     * @instance
                     */
                    RemoveKnownNetworkRequest.prototype.ssid = "";
    
                    /**
                     * Creates a new RemoveKnownNetworkRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkRequest
                     * @static
                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.RemoveKnownNetworkRequest} RemoveKnownNetworkRequest instance
                     */
                    RemoveKnownNetworkRequest.create = function create(properties) {
                        return new RemoveKnownNetworkRequest(properties);
                    };
    
                    /**
                     * Encodes the specified RemoveKnownNetworkRequest message. Does not implicitly {@link particle.ctrl.wifi.RemoveKnownNetworkRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkRequest
                     * @static
                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkRequest} message RemoveKnownNetworkRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RemoveKnownNetworkRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ssid != null && Object.hasOwnProperty.call(message, "ssid"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);
                        return writer;
                    };
    
                    /**
                     * Decodes a RemoveKnownNetworkRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.RemoveKnownNetworkRequest} RemoveKnownNetworkRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RemoveKnownNetworkRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.RemoveKnownNetworkRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ssid = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return RemoveKnownNetworkRequest;
                })();
    
                wifi.RemoveKnownNetworkReply = (function() {
    
                    /**
                     * Properties of a RemoveKnownNetworkReply.
                     * @memberof particle.ctrl.wifi
                     * @interface IRemoveKnownNetworkReply
                     */
    
                    /**
                     * Constructs a new RemoveKnownNetworkReply.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Represents a RemoveKnownNetworkReply.
                     * @implements IRemoveKnownNetworkReply
                     * @constructor
                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkReply=} [properties] Properties to set
                     */
                    function RemoveKnownNetworkReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new RemoveKnownNetworkReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkReply
                     * @static
                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkReply=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.RemoveKnownNetworkReply} RemoveKnownNetworkReply instance
                     */
                    RemoveKnownNetworkReply.create = function create(properties) {
                        return new RemoveKnownNetworkReply(properties);
                    };
    
                    /**
                     * Encodes the specified RemoveKnownNetworkReply message. Does not implicitly {@link particle.ctrl.wifi.RemoveKnownNetworkReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkReply
                     * @static
                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkReply} message RemoveKnownNetworkReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RemoveKnownNetworkReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a RemoveKnownNetworkReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.RemoveKnownNetworkReply} RemoveKnownNetworkReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RemoveKnownNetworkReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.RemoveKnownNetworkReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return RemoveKnownNetworkReply;
                })();
    
                wifi.ClearKnownNetworksRequest = (function() {
    
                    /**
                     * Properties of a ClearKnownNetworksRequest.
                     * @memberof particle.ctrl.wifi
                     * @interface IClearKnownNetworksRequest
                     */
    
                    /**
                     * Constructs a new ClearKnownNetworksRequest.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Remove all known networks.
                     * @implements IClearKnownNetworksRequest
                     * @constructor
                     * @param {particle.ctrl.wifi.IClearKnownNetworksRequest=} [properties] Properties to set
                     */
                    function ClearKnownNetworksRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new ClearKnownNetworksRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.ClearKnownNetworksRequest
                     * @static
                     * @param {particle.ctrl.wifi.IClearKnownNetworksRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.ClearKnownNetworksRequest} ClearKnownNetworksRequest instance
                     */
                    ClearKnownNetworksRequest.create = function create(properties) {
                        return new ClearKnownNetworksRequest(properties);
                    };
    
                    /**
                     * Encodes the specified ClearKnownNetworksRequest message. Does not implicitly {@link particle.ctrl.wifi.ClearKnownNetworksRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.ClearKnownNetworksRequest
                     * @static
                     * @param {particle.ctrl.wifi.IClearKnownNetworksRequest} message ClearKnownNetworksRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClearKnownNetworksRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a ClearKnownNetworksRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.ClearKnownNetworksRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.ClearKnownNetworksRequest} ClearKnownNetworksRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClearKnownNetworksRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ClearKnownNetworksRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return ClearKnownNetworksRequest;
                })();
    
                wifi.ClearKnownNetworksReply = (function() {
    
                    /**
                     * Properties of a ClearKnownNetworksReply.
                     * @memberof particle.ctrl.wifi
                     * @interface IClearKnownNetworksReply
                     */
    
                    /**
                     * Constructs a new ClearKnownNetworksReply.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Represents a ClearKnownNetworksReply.
                     * @implements IClearKnownNetworksReply
                     * @constructor
                     * @param {particle.ctrl.wifi.IClearKnownNetworksReply=} [properties] Properties to set
                     */
                    function ClearKnownNetworksReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new ClearKnownNetworksReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.ClearKnownNetworksReply
                     * @static
                     * @param {particle.ctrl.wifi.IClearKnownNetworksReply=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.ClearKnownNetworksReply} ClearKnownNetworksReply instance
                     */
                    ClearKnownNetworksReply.create = function create(properties) {
                        return new ClearKnownNetworksReply(properties);
                    };
    
                    /**
                     * Encodes the specified ClearKnownNetworksReply message. Does not implicitly {@link particle.ctrl.wifi.ClearKnownNetworksReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.ClearKnownNetworksReply
                     * @static
                     * @param {particle.ctrl.wifi.IClearKnownNetworksReply} message ClearKnownNetworksReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClearKnownNetworksReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a ClearKnownNetworksReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.ClearKnownNetworksReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.ClearKnownNetworksReply} ClearKnownNetworksReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClearKnownNetworksReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ClearKnownNetworksReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return ClearKnownNetworksReply;
                })();
    
                wifi.GetCurrentNetworkRequest = (function() {
    
                    /**
                     * Properties of a GetCurrentNetworkRequest.
                     * @memberof particle.ctrl.wifi
                     * @interface IGetCurrentNetworkRequest
                     */
    
                    /**
                     * Constructs a new GetCurrentNetworkRequest.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Get the current network.
                     * 
                     * This request gets the network which the device is currently connected to.
                     * @implements IGetCurrentNetworkRequest
                     * @constructor
                     * @param {particle.ctrl.wifi.IGetCurrentNetworkRequest=} [properties] Properties to set
                     */
                    function GetCurrentNetworkRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new GetCurrentNetworkRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.GetCurrentNetworkRequest
                     * @static
                     * @param {particle.ctrl.wifi.IGetCurrentNetworkRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.GetCurrentNetworkRequest} GetCurrentNetworkRequest instance
                     */
                    GetCurrentNetworkRequest.create = function create(properties) {
                        return new GetCurrentNetworkRequest(properties);
                    };
    
                    /**
                     * Encodes the specified GetCurrentNetworkRequest message. Does not implicitly {@link particle.ctrl.wifi.GetCurrentNetworkRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.GetCurrentNetworkRequest
                     * @static
                     * @param {particle.ctrl.wifi.IGetCurrentNetworkRequest} message GetCurrentNetworkRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetCurrentNetworkRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a GetCurrentNetworkRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.GetCurrentNetworkRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.GetCurrentNetworkRequest} GetCurrentNetworkRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetCurrentNetworkRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetCurrentNetworkRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetCurrentNetworkRequest;
                })();
    
                wifi.GetCurrentNetworkReply = (function() {
    
                    /**
                     * Properties of a GetCurrentNetworkReply.
                     * @memberof particle.ctrl.wifi
                     * @interface IGetCurrentNetworkReply
                     * @property {string|null} [ssid] GetCurrentNetworkReply ssid
                     * @property {Uint8Array|null} [bssid] GetCurrentNetworkReply bssid
                     * @property {number|null} [channel] GetCurrentNetworkReply channel
                     * @property {number|null} [rssi] GetCurrentNetworkReply rssi
                     */
    
                    /**
                     * Constructs a new GetCurrentNetworkReply.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Represents a GetCurrentNetworkReply.
                     * @implements IGetCurrentNetworkReply
                     * @constructor
                     * @param {particle.ctrl.wifi.IGetCurrentNetworkReply=} [properties] Properties to set
                     */
                    function GetCurrentNetworkReply(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * GetCurrentNetworkReply ssid.
                     * @member {string} ssid
                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply
                     * @instance
                     */
                    GetCurrentNetworkReply.prototype.ssid = "";
    
                    /**
                     * GetCurrentNetworkReply bssid.
                     * @member {Uint8Array} bssid
                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply
                     * @instance
                     */
                    GetCurrentNetworkReply.prototype.bssid = $util.newBuffer([]);
    
                    /**
                     * GetCurrentNetworkReply channel.
                     * @member {number} channel
                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply
                     * @instance
                     */
                    GetCurrentNetworkReply.prototype.channel = 0;
    
                    /**
                     * GetCurrentNetworkReply rssi.
                     * @member {number} rssi
                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply
                     * @instance
                     */
                    GetCurrentNetworkReply.prototype.rssi = 0;
    
                    /**
                     * Creates a new GetCurrentNetworkReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply
                     * @static
                     * @param {particle.ctrl.wifi.IGetCurrentNetworkReply=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.GetCurrentNetworkReply} GetCurrentNetworkReply instance
                     */
                    GetCurrentNetworkReply.create = function create(properties) {
                        return new GetCurrentNetworkReply(properties);
                    };
    
                    /**
                     * Encodes the specified GetCurrentNetworkReply message. Does not implicitly {@link particle.ctrl.wifi.GetCurrentNetworkReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply
                     * @static
                     * @param {particle.ctrl.wifi.IGetCurrentNetworkReply} message GetCurrentNetworkReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GetCurrentNetworkReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ssid != null && Object.hasOwnProperty.call(message, "ssid"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);
                        if (message.bssid != null && Object.hasOwnProperty.call(message, "bssid"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);
                        if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.channel);
                        if (message.rssi != null && Object.hasOwnProperty.call(message, "rssi"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.rssi);
                        return writer;
                    };
    
                    /**
                     * Decodes a GetCurrentNetworkReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.GetCurrentNetworkReply} GetCurrentNetworkReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GetCurrentNetworkReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetCurrentNetworkReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ssid = reader.string();
                                break;
                            case 2:
                                message.bssid = reader.bytes();
                                break;
                            case 3:
                                message.channel = reader.int32();
                                break;
                            case 4:
                                message.rssi = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return GetCurrentNetworkReply;
                })();
    
                wifi.ScanNetworksRequest = (function() {
    
                    /**
                     * Properties of a ScanNetworksRequest.
                     * @memberof particle.ctrl.wifi
                     * @interface IScanNetworksRequest
                     */
    
                    /**
                     * Constructs a new ScanNetworksRequest.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Scan for networks.
                     * @implements IScanNetworksRequest
                     * @constructor
                     * @param {particle.ctrl.wifi.IScanNetworksRequest=} [properties] Properties to set
                     */
                    function ScanNetworksRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new ScanNetworksRequest instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.ScanNetworksRequest
                     * @static
                     * @param {particle.ctrl.wifi.IScanNetworksRequest=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.ScanNetworksRequest} ScanNetworksRequest instance
                     */
                    ScanNetworksRequest.create = function create(properties) {
                        return new ScanNetworksRequest(properties);
                    };
    
                    /**
                     * Encodes the specified ScanNetworksRequest message. Does not implicitly {@link particle.ctrl.wifi.ScanNetworksRequest.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.ScanNetworksRequest
                     * @static
                     * @param {particle.ctrl.wifi.IScanNetworksRequest} message ScanNetworksRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ScanNetworksRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Decodes a ScanNetworksRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.ScanNetworksRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.ScanNetworksRequest} ScanNetworksRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ScanNetworksRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ScanNetworksRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return ScanNetworksRequest;
                })();
    
                wifi.ScanNetworksReply = (function() {
    
                    /**
                     * Properties of a ScanNetworksReply.
                     * @memberof particle.ctrl.wifi
                     * @interface IScanNetworksReply
                     * @property {Array.<particle.ctrl.wifi.ScanNetworksReply.INetwork>|null} [networks] ScanNetworksReply networks
                     */
    
                    /**
                     * Constructs a new ScanNetworksReply.
                     * @memberof particle.ctrl.wifi
                     * @classdesc Represents a ScanNetworksReply.
                     * @implements IScanNetworksReply
                     * @constructor
                     * @param {particle.ctrl.wifi.IScanNetworksReply=} [properties] Properties to set
                     */
                    function ScanNetworksReply(properties) {
                        this.networks = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ScanNetworksReply networks.
                     * @member {Array.<particle.ctrl.wifi.ScanNetworksReply.INetwork>} networks
                     * @memberof particle.ctrl.wifi.ScanNetworksReply
                     * @instance
                     */
                    ScanNetworksReply.prototype.networks = $util.emptyArray;
    
                    /**
                     * Creates a new ScanNetworksReply instance using the specified properties.
                     * @function create
                     * @memberof particle.ctrl.wifi.ScanNetworksReply
                     * @static
                     * @param {particle.ctrl.wifi.IScanNetworksReply=} [properties] Properties to set
                     * @returns {particle.ctrl.wifi.ScanNetworksReply} ScanNetworksReply instance
                     */
                    ScanNetworksReply.create = function create(properties) {
                        return new ScanNetworksReply(properties);
                    };
    
                    /**
                     * Encodes the specified ScanNetworksReply message. Does not implicitly {@link particle.ctrl.wifi.ScanNetworksReply.verify|verify} messages.
                     * @function encode
                     * @memberof particle.ctrl.wifi.ScanNetworksReply
                     * @static
                     * @param {particle.ctrl.wifi.IScanNetworksReply} message ScanNetworksReply message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ScanNetworksReply.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.networks != null && message.networks.length)
                            for (var i = 0; i < message.networks.length; ++i)
                                $root.particle.ctrl.wifi.ScanNetworksReply.Network.encode(message.networks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Decodes a ScanNetworksReply message from the specified reader or buffer.
                     * @function decode
                     * @memberof particle.ctrl.wifi.ScanNetworksReply
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {particle.ctrl.wifi.ScanNetworksReply} ScanNetworksReply
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ScanNetworksReply.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ScanNetworksReply();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.networks && message.networks.length))
                                    message.networks = [];
                                message.networks.push($root.particle.ctrl.wifi.ScanNetworksReply.Network.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    ScanNetworksReply.Network = (function() {
    
                        /**
                         * Properties of a Network.
                         * @memberof particle.ctrl.wifi.ScanNetworksReply
                         * @interface INetwork
                         * @property {string|null} [ssid] Network ssid
                         * @property {Uint8Array|null} [bssid] Network bssid
                         * @property {particle.ctrl.wifi.Security|null} [security] Network security
                         * @property {number|null} [channel] Network channel
                         * @property {number|null} [rssi] Network rssi
                         */
    
                        /**
                         * Constructs a new Network.
                         * @memberof particle.ctrl.wifi.ScanNetworksReply
                         * @classdesc Represents a Network.
                         * @implements INetwork
                         * @constructor
                         * @param {particle.ctrl.wifi.ScanNetworksReply.INetwork=} [properties] Properties to set
                         */
                        function Network(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Network ssid.
                         * @member {string} ssid
                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network
                         * @instance
                         */
                        Network.prototype.ssid = "";
    
                        /**
                         * Network bssid.
                         * @member {Uint8Array} bssid
                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network
                         * @instance
                         */
                        Network.prototype.bssid = $util.newBuffer([]);
    
                        /**
                         * Network security.
                         * @member {particle.ctrl.wifi.Security} security
                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network
                         * @instance
                         */
                        Network.prototype.security = 0;
    
                        /**
                         * Network channel.
                         * @member {number} channel
                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network
                         * @instance
                         */
                        Network.prototype.channel = 0;
    
                        /**
                         * Network rssi.
                         * @member {number} rssi
                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network
                         * @instance
                         */
                        Network.prototype.rssi = 0;
    
                        /**
                         * Creates a new Network instance using the specified properties.
                         * @function create
                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network
                         * @static
                         * @param {particle.ctrl.wifi.ScanNetworksReply.INetwork=} [properties] Properties to set
                         * @returns {particle.ctrl.wifi.ScanNetworksReply.Network} Network instance
                         */
                        Network.create = function create(properties) {
                            return new Network(properties);
                        };
    
                        /**
                         * Encodes the specified Network message. Does not implicitly {@link particle.ctrl.wifi.ScanNetworksReply.Network.verify|verify} messages.
                         * @function encode
                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network
                         * @static
                         * @param {particle.ctrl.wifi.ScanNetworksReply.INetwork} message Network message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Network.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.ssid != null && Object.hasOwnProperty.call(message, "ssid"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);
                            if (message.bssid != null && Object.hasOwnProperty.call(message, "bssid"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);
                            if (message.security != null && Object.hasOwnProperty.call(message, "security"))
                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.security);
                            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.channel);
                            if (message.rssi != null && Object.hasOwnProperty.call(message, "rssi"))
                                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.rssi);
                            return writer;
                        };
    
                        /**
                         * Decodes a Network message from the specified reader or buffer.
                         * @function decode
                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {particle.ctrl.wifi.ScanNetworksReply.Network} Network
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Network.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ScanNetworksReply.Network();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.ssid = reader.string();
                                    break;
                                case 2:
                                    message.bssid = reader.bytes();
                                    break;
                                case 3:
                                    message.security = reader.int32();
                                    break;
                                case 4:
                                    message.channel = reader.int32();
                                    break;
                                case 5:
                                    message.rssi = reader.int32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        return Network;
                    })();
    
                    return ScanNetworksReply;
                })();
    
                return wifi;
            })();
    
            ctrl.WiFiGetAntennaRequest = (function() {
    
                /**
                 * Properties of a WiFiGetAntennaRequest.
                 * @memberof particle.ctrl
                 * @interface IWiFiGetAntennaRequest
                 */
    
                /**
                 * Constructs a new WiFiGetAntennaRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiGetAntennaRequest.
                 * @implements IWiFiGetAntennaRequest
                 * @constructor
                 * @param {particle.ctrl.IWiFiGetAntennaRequest=} [properties] Properties to set
                 */
                function WiFiGetAntennaRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WiFiGetAntennaRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiGetAntennaRequest
                 * @static
                 * @param {particle.ctrl.IWiFiGetAntennaRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiGetAntennaRequest} WiFiGetAntennaRequest instance
                 */
                WiFiGetAntennaRequest.create = function create(properties) {
                    return new WiFiGetAntennaRequest(properties);
                };
    
                /**
                 * Encodes the specified WiFiGetAntennaRequest message. Does not implicitly {@link particle.ctrl.WiFiGetAntennaRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiGetAntennaRequest
                 * @static
                 * @param {particle.ctrl.IWiFiGetAntennaRequest} message WiFiGetAntennaRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiGetAntennaRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WiFiGetAntennaRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiGetAntennaRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiGetAntennaRequest} WiFiGetAntennaRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiGetAntennaRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiGetAntennaRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiGetAntennaRequest;
            })();
    
            ctrl.WiFiGetAntennaReply = (function() {
    
                /**
                 * Properties of a WiFiGetAntennaReply.
                 * @memberof particle.ctrl
                 * @interface IWiFiGetAntennaReply
                 * @property {particle.ctrl.WiFiAntenna|null} [antenna] WiFiGetAntennaReply antenna
                 */
    
                /**
                 * Constructs a new WiFiGetAntennaReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiGetAntennaReply.
                 * @implements IWiFiGetAntennaReply
                 * @constructor
                 * @param {particle.ctrl.IWiFiGetAntennaReply=} [properties] Properties to set
                 */
                function WiFiGetAntennaReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WiFiGetAntennaReply antenna.
                 * @member {particle.ctrl.WiFiAntenna} antenna
                 * @memberof particle.ctrl.WiFiGetAntennaReply
                 * @instance
                 */
                WiFiGetAntennaReply.prototype.antenna = 0;
    
                /**
                 * Creates a new WiFiGetAntennaReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiGetAntennaReply
                 * @static
                 * @param {particle.ctrl.IWiFiGetAntennaReply=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiGetAntennaReply} WiFiGetAntennaReply instance
                 */
                WiFiGetAntennaReply.create = function create(properties) {
                    return new WiFiGetAntennaReply(properties);
                };
    
                /**
                 * Encodes the specified WiFiGetAntennaReply message. Does not implicitly {@link particle.ctrl.WiFiGetAntennaReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiGetAntennaReply
                 * @static
                 * @param {particle.ctrl.IWiFiGetAntennaReply} message WiFiGetAntennaReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiGetAntennaReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.antenna != null && Object.hasOwnProperty.call(message, "antenna"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.antenna);
                    return writer;
                };
    
                /**
                 * Decodes a WiFiGetAntennaReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiGetAntennaReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiGetAntennaReply} WiFiGetAntennaReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiGetAntennaReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiGetAntennaReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.antenna = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiGetAntennaReply;
            })();
    
            ctrl.WiFiSetAntennaRequest = (function() {
    
                /**
                 * Properties of a WiFiSetAntennaRequest.
                 * @memberof particle.ctrl
                 * @interface IWiFiSetAntennaRequest
                 * @property {particle.ctrl.WiFiAntenna|null} [antenna] WiFiSetAntennaRequest antenna
                 */
    
                /**
                 * Constructs a new WiFiSetAntennaRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiSetAntennaRequest.
                 * @implements IWiFiSetAntennaRequest
                 * @constructor
                 * @param {particle.ctrl.IWiFiSetAntennaRequest=} [properties] Properties to set
                 */
                function WiFiSetAntennaRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WiFiSetAntennaRequest antenna.
                 * @member {particle.ctrl.WiFiAntenna} antenna
                 * @memberof particle.ctrl.WiFiSetAntennaRequest
                 * @instance
                 */
                WiFiSetAntennaRequest.prototype.antenna = 0;
    
                /**
                 * Creates a new WiFiSetAntennaRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiSetAntennaRequest
                 * @static
                 * @param {particle.ctrl.IWiFiSetAntennaRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiSetAntennaRequest} WiFiSetAntennaRequest instance
                 */
                WiFiSetAntennaRequest.create = function create(properties) {
                    return new WiFiSetAntennaRequest(properties);
                };
    
                /**
                 * Encodes the specified WiFiSetAntennaRequest message. Does not implicitly {@link particle.ctrl.WiFiSetAntennaRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiSetAntennaRequest
                 * @static
                 * @param {particle.ctrl.IWiFiSetAntennaRequest} message WiFiSetAntennaRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiSetAntennaRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.antenna != null && Object.hasOwnProperty.call(message, "antenna"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.antenna);
                    return writer;
                };
    
                /**
                 * Decodes a WiFiSetAntennaRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiSetAntennaRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiSetAntennaRequest} WiFiSetAntennaRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiSetAntennaRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiSetAntennaRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.antenna = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiSetAntennaRequest;
            })();
    
            ctrl.WiFiSetAntennaReply = (function() {
    
                /**
                 * Properties of a WiFiSetAntennaReply.
                 * @memberof particle.ctrl
                 * @interface IWiFiSetAntennaReply
                 */
    
                /**
                 * Constructs a new WiFiSetAntennaReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiSetAntennaReply.
                 * @implements IWiFiSetAntennaReply
                 * @constructor
                 * @param {particle.ctrl.IWiFiSetAntennaReply=} [properties] Properties to set
                 */
                function WiFiSetAntennaReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WiFiSetAntennaReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiSetAntennaReply
                 * @static
                 * @param {particle.ctrl.IWiFiSetAntennaReply=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiSetAntennaReply} WiFiSetAntennaReply instance
                 */
                WiFiSetAntennaReply.create = function create(properties) {
                    return new WiFiSetAntennaReply(properties);
                };
    
                /**
                 * Encodes the specified WiFiSetAntennaReply message. Does not implicitly {@link particle.ctrl.WiFiSetAntennaReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiSetAntennaReply
                 * @static
                 * @param {particle.ctrl.IWiFiSetAntennaReply} message WiFiSetAntennaReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiSetAntennaReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WiFiSetAntennaReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiSetAntennaReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiSetAntennaReply} WiFiSetAntennaReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiSetAntennaReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiSetAntennaReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiSetAntennaReply;
            })();
    
            ctrl.WiFiScanRequest = (function() {
    
                /**
                 * Properties of a WiFiScanRequest.
                 * @memberof particle.ctrl
                 * @interface IWiFiScanRequest
                 */
    
                /**
                 * Constructs a new WiFiScanRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiScanRequest.
                 * @implements IWiFiScanRequest
                 * @constructor
                 * @param {particle.ctrl.IWiFiScanRequest=} [properties] Properties to set
                 */
                function WiFiScanRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WiFiScanRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiScanRequest
                 * @static
                 * @param {particle.ctrl.IWiFiScanRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiScanRequest} WiFiScanRequest instance
                 */
                WiFiScanRequest.create = function create(properties) {
                    return new WiFiScanRequest(properties);
                };
    
                /**
                 * Encodes the specified WiFiScanRequest message. Does not implicitly {@link particle.ctrl.WiFiScanRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiScanRequest
                 * @static
                 * @param {particle.ctrl.IWiFiScanRequest} message WiFiScanRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiScanRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WiFiScanRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiScanRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiScanRequest} WiFiScanRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiScanRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiScanRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiScanRequest;
            })();
    
            ctrl.WiFiScanReply = (function() {
    
                /**
                 * Properties of a WiFiScanReply.
                 * @memberof particle.ctrl
                 * @interface IWiFiScanReply
                 * @property {particle.ctrl.IWiFiAccessPointList|null} [list] WiFiScanReply list
                 */
    
                /**
                 * Constructs a new WiFiScanReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiScanReply.
                 * @implements IWiFiScanReply
                 * @constructor
                 * @param {particle.ctrl.IWiFiScanReply=} [properties] Properties to set
                 */
                function WiFiScanReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WiFiScanReply list.
                 * @member {particle.ctrl.IWiFiAccessPointList|null|undefined} list
                 * @memberof particle.ctrl.WiFiScanReply
                 * @instance
                 */
                WiFiScanReply.prototype.list = null;
    
                /**
                 * Creates a new WiFiScanReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiScanReply
                 * @static
                 * @param {particle.ctrl.IWiFiScanReply=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiScanReply} WiFiScanReply instance
                 */
                WiFiScanReply.create = function create(properties) {
                    return new WiFiScanReply(properties);
                };
    
                /**
                 * Encodes the specified WiFiScanReply message. Does not implicitly {@link particle.ctrl.WiFiScanReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiScanReply
                 * @static
                 * @param {particle.ctrl.IWiFiScanReply} message WiFiScanReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiScanReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.list != null && Object.hasOwnProperty.call(message, "list"))
                        $root.particle.ctrl.WiFiAccessPointList.encode(message.list, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WiFiScanReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiScanReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiScanReply} WiFiScanReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiScanReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiScanReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.list = $root.particle.ctrl.WiFiAccessPointList.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiScanReply;
            })();
    
            ctrl.WiFiGetCredentialsRequest = (function() {
    
                /**
                 * Properties of a WiFiGetCredentialsRequest.
                 * @memberof particle.ctrl
                 * @interface IWiFiGetCredentialsRequest
                 */
    
                /**
                 * Constructs a new WiFiGetCredentialsRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiGetCredentialsRequest.
                 * @implements IWiFiGetCredentialsRequest
                 * @constructor
                 * @param {particle.ctrl.IWiFiGetCredentialsRequest=} [properties] Properties to set
                 */
                function WiFiGetCredentialsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WiFiGetCredentialsRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiGetCredentialsRequest
                 * @static
                 * @param {particle.ctrl.IWiFiGetCredentialsRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiGetCredentialsRequest} WiFiGetCredentialsRequest instance
                 */
                WiFiGetCredentialsRequest.create = function create(properties) {
                    return new WiFiGetCredentialsRequest(properties);
                };
    
                /**
                 * Encodes the specified WiFiGetCredentialsRequest message. Does not implicitly {@link particle.ctrl.WiFiGetCredentialsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiGetCredentialsRequest
                 * @static
                 * @param {particle.ctrl.IWiFiGetCredentialsRequest} message WiFiGetCredentialsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiGetCredentialsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WiFiGetCredentialsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiGetCredentialsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiGetCredentialsRequest} WiFiGetCredentialsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiGetCredentialsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiGetCredentialsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiGetCredentialsRequest;
            })();
    
            ctrl.WiFiGetCredentialsReply = (function() {
    
                /**
                 * Properties of a WiFiGetCredentialsReply.
                 * @memberof particle.ctrl
                 * @interface IWiFiGetCredentialsReply
                 * @property {particle.ctrl.IWiFiAccessPointList|null} [list] WiFiGetCredentialsReply list
                 */
    
                /**
                 * Constructs a new WiFiGetCredentialsReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiGetCredentialsReply.
                 * @implements IWiFiGetCredentialsReply
                 * @constructor
                 * @param {particle.ctrl.IWiFiGetCredentialsReply=} [properties] Properties to set
                 */
                function WiFiGetCredentialsReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WiFiGetCredentialsReply list.
                 * @member {particle.ctrl.IWiFiAccessPointList|null|undefined} list
                 * @memberof particle.ctrl.WiFiGetCredentialsReply
                 * @instance
                 */
                WiFiGetCredentialsReply.prototype.list = null;
    
                /**
                 * Creates a new WiFiGetCredentialsReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiGetCredentialsReply
                 * @static
                 * @param {particle.ctrl.IWiFiGetCredentialsReply=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiGetCredentialsReply} WiFiGetCredentialsReply instance
                 */
                WiFiGetCredentialsReply.create = function create(properties) {
                    return new WiFiGetCredentialsReply(properties);
                };
    
                /**
                 * Encodes the specified WiFiGetCredentialsReply message. Does not implicitly {@link particle.ctrl.WiFiGetCredentialsReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiGetCredentialsReply
                 * @static
                 * @param {particle.ctrl.IWiFiGetCredentialsReply} message WiFiGetCredentialsReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiGetCredentialsReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.list != null && Object.hasOwnProperty.call(message, "list"))
                        $root.particle.ctrl.WiFiAccessPointList.encode(message.list, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WiFiGetCredentialsReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiGetCredentialsReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiGetCredentialsReply} WiFiGetCredentialsReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiGetCredentialsReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiGetCredentialsReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.list = $root.particle.ctrl.WiFiAccessPointList.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiGetCredentialsReply;
            })();
    
            ctrl.WiFiSetCredentialsRequest = (function() {
    
                /**
                 * Properties of a WiFiSetCredentialsRequest.
                 * @memberof particle.ctrl
                 * @interface IWiFiSetCredentialsRequest
                 * @property {particle.ctrl.IWiFiAccessPoint|null} [ap] WiFiSetCredentialsRequest ap
                 */
    
                /**
                 * Constructs a new WiFiSetCredentialsRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiSetCredentialsRequest.
                 * @implements IWiFiSetCredentialsRequest
                 * @constructor
                 * @param {particle.ctrl.IWiFiSetCredentialsRequest=} [properties] Properties to set
                 */
                function WiFiSetCredentialsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WiFiSetCredentialsRequest ap.
                 * @member {particle.ctrl.IWiFiAccessPoint|null|undefined} ap
                 * @memberof particle.ctrl.WiFiSetCredentialsRequest
                 * @instance
                 */
                WiFiSetCredentialsRequest.prototype.ap = null;
    
                /**
                 * Creates a new WiFiSetCredentialsRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiSetCredentialsRequest
                 * @static
                 * @param {particle.ctrl.IWiFiSetCredentialsRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiSetCredentialsRequest} WiFiSetCredentialsRequest instance
                 */
                WiFiSetCredentialsRequest.create = function create(properties) {
                    return new WiFiSetCredentialsRequest(properties);
                };
    
                /**
                 * Encodes the specified WiFiSetCredentialsRequest message. Does not implicitly {@link particle.ctrl.WiFiSetCredentialsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiSetCredentialsRequest
                 * @static
                 * @param {particle.ctrl.IWiFiSetCredentialsRequest} message WiFiSetCredentialsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiSetCredentialsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ap != null && Object.hasOwnProperty.call(message, "ap"))
                        $root.particle.ctrl.WiFiAccessPoint.encode(message.ap, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WiFiSetCredentialsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiSetCredentialsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiSetCredentialsRequest} WiFiSetCredentialsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiSetCredentialsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiSetCredentialsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ap = $root.particle.ctrl.WiFiAccessPoint.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiSetCredentialsRequest;
            })();
    
            ctrl.WiFiSetCredentialsReply = (function() {
    
                /**
                 * Properties of a WiFiSetCredentialsReply.
                 * @memberof particle.ctrl
                 * @interface IWiFiSetCredentialsReply
                 */
    
                /**
                 * Constructs a new WiFiSetCredentialsReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiSetCredentialsReply.
                 * @implements IWiFiSetCredentialsReply
                 * @constructor
                 * @param {particle.ctrl.IWiFiSetCredentialsReply=} [properties] Properties to set
                 */
                function WiFiSetCredentialsReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WiFiSetCredentialsReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiSetCredentialsReply
                 * @static
                 * @param {particle.ctrl.IWiFiSetCredentialsReply=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiSetCredentialsReply} WiFiSetCredentialsReply instance
                 */
                WiFiSetCredentialsReply.create = function create(properties) {
                    return new WiFiSetCredentialsReply(properties);
                };
    
                /**
                 * Encodes the specified WiFiSetCredentialsReply message. Does not implicitly {@link particle.ctrl.WiFiSetCredentialsReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiSetCredentialsReply
                 * @static
                 * @param {particle.ctrl.IWiFiSetCredentialsReply} message WiFiSetCredentialsReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiSetCredentialsReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WiFiSetCredentialsReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiSetCredentialsReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiSetCredentialsReply} WiFiSetCredentialsReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiSetCredentialsReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiSetCredentialsReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiSetCredentialsReply;
            })();
    
            ctrl.WiFiClearCredentialsRequest = (function() {
    
                /**
                 * Properties of a WiFiClearCredentialsRequest.
                 * @memberof particle.ctrl
                 * @interface IWiFiClearCredentialsRequest
                 */
    
                /**
                 * Constructs a new WiFiClearCredentialsRequest.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiClearCredentialsRequest.
                 * @implements IWiFiClearCredentialsRequest
                 * @constructor
                 * @param {particle.ctrl.IWiFiClearCredentialsRequest=} [properties] Properties to set
                 */
                function WiFiClearCredentialsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WiFiClearCredentialsRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiClearCredentialsRequest
                 * @static
                 * @param {particle.ctrl.IWiFiClearCredentialsRequest=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiClearCredentialsRequest} WiFiClearCredentialsRequest instance
                 */
                WiFiClearCredentialsRequest.create = function create(properties) {
                    return new WiFiClearCredentialsRequest(properties);
                };
    
                /**
                 * Encodes the specified WiFiClearCredentialsRequest message. Does not implicitly {@link particle.ctrl.WiFiClearCredentialsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiClearCredentialsRequest
                 * @static
                 * @param {particle.ctrl.IWiFiClearCredentialsRequest} message WiFiClearCredentialsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiClearCredentialsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WiFiClearCredentialsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiClearCredentialsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiClearCredentialsRequest} WiFiClearCredentialsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiClearCredentialsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiClearCredentialsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiClearCredentialsRequest;
            })();
    
            ctrl.WiFiClearCredentialsReply = (function() {
    
                /**
                 * Properties of a WiFiClearCredentialsReply.
                 * @memberof particle.ctrl
                 * @interface IWiFiClearCredentialsReply
                 */
    
                /**
                 * Constructs a new WiFiClearCredentialsReply.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiClearCredentialsReply.
                 * @implements IWiFiClearCredentialsReply
                 * @constructor
                 * @param {particle.ctrl.IWiFiClearCredentialsReply=} [properties] Properties to set
                 */
                function WiFiClearCredentialsReply(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new WiFiClearCredentialsReply instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiClearCredentialsReply
                 * @static
                 * @param {particle.ctrl.IWiFiClearCredentialsReply=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiClearCredentialsReply} WiFiClearCredentialsReply instance
                 */
                WiFiClearCredentialsReply.create = function create(properties) {
                    return new WiFiClearCredentialsReply(properties);
                };
    
                /**
                 * Encodes the specified WiFiClearCredentialsReply message. Does not implicitly {@link particle.ctrl.WiFiClearCredentialsReply.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiClearCredentialsReply
                 * @static
                 * @param {particle.ctrl.IWiFiClearCredentialsReply} message WiFiClearCredentialsReply message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiClearCredentialsReply.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a WiFiClearCredentialsReply message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiClearCredentialsReply
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiClearCredentialsReply} WiFiClearCredentialsReply
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiClearCredentialsReply.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiClearCredentialsReply();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiClearCredentialsReply;
            })();
    
            /**
             * WiFiAntenna enum.
             * @name particle.ctrl.WiFiAntenna
             * @enum {number}
             * @property {number} ANTENNA_NONE=0 ANTENNA_NONE value
             * @property {number} INTERNAL=1 INTERNAL value
             * @property {number} EXTERNAL=2 EXTERNAL value
             * @property {number} AUTO=3 AUTO value
             */
            ctrl.WiFiAntenna = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ANTENNA_NONE"] = 0;
                values[valuesById[1] = "INTERNAL"] = 1;
                values[valuesById[2] = "EXTERNAL"] = 2;
                values[valuesById[3] = "AUTO"] = 3;
                return values;
            })();
    
            /**
             * WiFiSecurityType enum.
             * @name particle.ctrl.WiFiSecurityType
             * @enum {number}
             * @property {number} UNSEC=0 UNSEC value
             * @property {number} WEP=1 WEP value
             * @property {number} WPA=2 WPA value
             * @property {number} WPA2=3 WPA2 value
             * @property {number} WPA_ENTERPRISE=4 WPA_ENTERPRISE value
             * @property {number} WPA2_ENTERPRISE=5 WPA2_ENTERPRISE value
             * @property {number} UNKNOWN=255 UNKNOWN value
             */
            ctrl.WiFiSecurityType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSEC"] = 0;
                values[valuesById[1] = "WEP"] = 1;
                values[valuesById[2] = "WPA"] = 2;
                values[valuesById[3] = "WPA2"] = 3;
                values[valuesById[4] = "WPA_ENTERPRISE"] = 4;
                values[valuesById[5] = "WPA2_ENTERPRISE"] = 5;
                values[valuesById[255] = "UNKNOWN"] = 255;
                return values;
            })();
    
            /**
             * WiFiSecurityCipher enum.
             * @name particle.ctrl.WiFiSecurityCipher
             * @enum {number}
             * @property {number} CIPHER_NONE=0 CIPHER_NONE value
             * @property {number} AES=1 AES value
             * @property {number} TKIP=2 TKIP value
             * @property {number} AES_TKIP=3 AES_TKIP value
             */
            ctrl.WiFiSecurityCipher = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CIPHER_NONE"] = 0;
                values[valuesById[1] = "AES"] = 1;
                values[valuesById[2] = "TKIP"] = 2;
                values[valuesById[3] = "AES_TKIP"] = 3;
                return values;
            })();
    
            /**
             * EapType enum.
             * @name particle.ctrl.EapType
             * @enum {number}
             * @property {number} EAP_TYPE_NONE=0 EAP_TYPE_NONE value
             * @property {number} TLS=13 TLS value
             * @property {number} PEAP=25 PEAP value
             */
            ctrl.EapType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "EAP_TYPE_NONE"] = 0;
                values[valuesById[13] = "TLS"] = 13;
                values[valuesById[25] = "PEAP"] = 25;
                return values;
            })();
    
            ctrl.WiFiAccessPoint = (function() {
    
                /**
                 * Properties of a WiFiAccessPoint.
                 * @memberof particle.ctrl
                 * @interface IWiFiAccessPoint
                 * @property {string|null} [ssid] WiFiAccessPoint ssid
                 * @property {Uint8Array|null} [bssid] WiFiAccessPoint bssid
                 * @property {particle.ctrl.WiFiSecurityType|null} [security] WiFiAccessPoint security
                 * @property {particle.ctrl.WiFiSecurityCipher|null} [cipher] WiFiAccessPoint cipher
                 * @property {number|null} [channel] WiFiAccessPoint channel
                 * @property {number|null} [maxDataRate] WiFiAccessPoint maxDataRate
                 * @property {number|null} [rssi] WiFiAccessPoint rssi
                 * @property {string|null} [password] WiFiAccessPoint password
                 * @property {particle.ctrl.EapType|null} [eapType] WiFiAccessPoint eapType
                 * @property {string|null} [innerIdentity] WiFiAccessPoint innerIdentity
                 * @property {string|null} [outerIdentity] WiFiAccessPoint outerIdentity
                 * @property {Uint8Array|null} [privateKey] WiFiAccessPoint privateKey
                 * @property {Uint8Array|null} [clientCertificate] WiFiAccessPoint clientCertificate
                 * @property {Uint8Array|null} [caCertificate] WiFiAccessPoint caCertificate
                 */
    
                /**
                 * Constructs a new WiFiAccessPoint.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiAccessPoint.
                 * @implements IWiFiAccessPoint
                 * @constructor
                 * @param {particle.ctrl.IWiFiAccessPoint=} [properties] Properties to set
                 */
                function WiFiAccessPoint(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WiFiAccessPoint ssid.
                 * @member {string} ssid
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.ssid = "";
    
                /**
                 * WiFiAccessPoint bssid.
                 * @member {Uint8Array} bssid
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.bssid = $util.newBuffer([]);
    
                /**
                 * WiFiAccessPoint security.
                 * @member {particle.ctrl.WiFiSecurityType} security
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.security = 0;
    
                /**
                 * WiFiAccessPoint cipher.
                 * @member {particle.ctrl.WiFiSecurityCipher} cipher
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.cipher = 0;
    
                /**
                 * WiFiAccessPoint channel.
                 * @member {number} channel
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.channel = 0;
    
                /**
                 * WiFiAccessPoint maxDataRate.
                 * @member {number} maxDataRate
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.maxDataRate = 0;
    
                /**
                 * WiFiAccessPoint rssi.
                 * @member {number} rssi
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.rssi = 0;
    
                /**
                 * WiFiAccessPoint password.
                 * @member {string} password
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.password = "";
    
                /**
                 * WiFiAccessPoint eapType.
                 * @member {particle.ctrl.EapType} eapType
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.eapType = 0;
    
                /**
                 * WiFiAccessPoint innerIdentity.
                 * @member {string} innerIdentity
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.innerIdentity = "";
    
                /**
                 * WiFiAccessPoint outerIdentity.
                 * @member {string} outerIdentity
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.outerIdentity = "";
    
                /**
                 * WiFiAccessPoint privateKey.
                 * @member {Uint8Array} privateKey
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.privateKey = $util.newBuffer([]);
    
                /**
                 * WiFiAccessPoint clientCertificate.
                 * @member {Uint8Array} clientCertificate
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.clientCertificate = $util.newBuffer([]);
    
                /**
                 * WiFiAccessPoint caCertificate.
                 * @member {Uint8Array} caCertificate
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @instance
                 */
                WiFiAccessPoint.prototype.caCertificate = $util.newBuffer([]);
    
                /**
                 * Creates a new WiFiAccessPoint instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @static
                 * @param {particle.ctrl.IWiFiAccessPoint=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiAccessPoint} WiFiAccessPoint instance
                 */
                WiFiAccessPoint.create = function create(properties) {
                    return new WiFiAccessPoint(properties);
                };
    
                /**
                 * Encodes the specified WiFiAccessPoint message. Does not implicitly {@link particle.ctrl.WiFiAccessPoint.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @static
                 * @param {particle.ctrl.IWiFiAccessPoint} message WiFiAccessPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiAccessPoint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ssid != null && Object.hasOwnProperty.call(message, "ssid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);
                    if (message.bssid != null && Object.hasOwnProperty.call(message, "bssid"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);
                    if (message.security != null && Object.hasOwnProperty.call(message, "security"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.security);
                    if (message.cipher != null && Object.hasOwnProperty.call(message, "cipher"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cipher);
                    if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.channel);
                    if (message.maxDataRate != null && Object.hasOwnProperty.call(message, "maxDataRate"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxDataRate);
                    if (message.rssi != null && Object.hasOwnProperty.call(message, "rssi"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.rssi);
                    if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.password);
                    if (message.eapType != null && Object.hasOwnProperty.call(message, "eapType"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.eapType);
                    if (message.innerIdentity != null && Object.hasOwnProperty.call(message, "innerIdentity"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.innerIdentity);
                    if (message.outerIdentity != null && Object.hasOwnProperty.call(message, "outerIdentity"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.outerIdentity);
                    if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                        writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.privateKey);
                    if (message.clientCertificate != null && Object.hasOwnProperty.call(message, "clientCertificate"))
                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.clientCertificate);
                    if (message.caCertificate != null && Object.hasOwnProperty.call(message, "caCertificate"))
                        writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.caCertificate);
                    return writer;
                };
    
                /**
                 * Decodes a WiFiAccessPoint message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiAccessPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiAccessPoint} WiFiAccessPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiAccessPoint.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiAccessPoint();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ssid = reader.string();
                            break;
                        case 2:
                            message.bssid = reader.bytes();
                            break;
                        case 3:
                            message.security = reader.int32();
                            break;
                        case 4:
                            message.cipher = reader.int32();
                            break;
                        case 5:
                            message.channel = reader.uint32();
                            break;
                        case 6:
                            message.maxDataRate = reader.int32();
                            break;
                        case 7:
                            message.rssi = reader.int32();
                            break;
                        case 8:
                            message.password = reader.string();
                            break;
                        case 9:
                            message.eapType = reader.int32();
                            break;
                        case 10:
                            message.innerIdentity = reader.string();
                            break;
                        case 11:
                            message.outerIdentity = reader.string();
                            break;
                        case 12:
                            message.privateKey = reader.bytes();
                            break;
                        case 13:
                            message.clientCertificate = reader.bytes();
                            break;
                        case 14:
                            message.caCertificate = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiAccessPoint;
            })();
    
            ctrl.WiFiAccessPointList = (function() {
    
                /**
                 * Properties of a WiFiAccessPointList.
                 * @memberof particle.ctrl
                 * @interface IWiFiAccessPointList
                 * @property {Array.<particle.ctrl.IWiFiAccessPoint>|null} [aps] WiFiAccessPointList aps
                 */
    
                /**
                 * Constructs a new WiFiAccessPointList.
                 * @memberof particle.ctrl
                 * @classdesc Represents a WiFiAccessPointList.
                 * @implements IWiFiAccessPointList
                 * @constructor
                 * @param {particle.ctrl.IWiFiAccessPointList=} [properties] Properties to set
                 */
                function WiFiAccessPointList(properties) {
                    this.aps = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * WiFiAccessPointList aps.
                 * @member {Array.<particle.ctrl.IWiFiAccessPoint>} aps
                 * @memberof particle.ctrl.WiFiAccessPointList
                 * @instance
                 */
                WiFiAccessPointList.prototype.aps = $util.emptyArray;
    
                /**
                 * Creates a new WiFiAccessPointList instance using the specified properties.
                 * @function create
                 * @memberof particle.ctrl.WiFiAccessPointList
                 * @static
                 * @param {particle.ctrl.IWiFiAccessPointList=} [properties] Properties to set
                 * @returns {particle.ctrl.WiFiAccessPointList} WiFiAccessPointList instance
                 */
                WiFiAccessPointList.create = function create(properties) {
                    return new WiFiAccessPointList(properties);
                };
    
                /**
                 * Encodes the specified WiFiAccessPointList message. Does not implicitly {@link particle.ctrl.WiFiAccessPointList.verify|verify} messages.
                 * @function encode
                 * @memberof particle.ctrl.WiFiAccessPointList
                 * @static
                 * @param {particle.ctrl.IWiFiAccessPointList} message WiFiAccessPointList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WiFiAccessPointList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.aps != null && message.aps.length)
                        for (var i = 0; i < message.aps.length; ++i)
                            $root.particle.ctrl.WiFiAccessPoint.encode(message.aps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a WiFiAccessPointList message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.ctrl.WiFiAccessPointList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.ctrl.WiFiAccessPointList} WiFiAccessPointList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WiFiAccessPointList.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiAccessPointList();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.aps && message.aps.length))
                                message.aps = [];
                            message.aps.push($root.particle.ctrl.WiFiAccessPoint.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return WiFiAccessPointList;
            })();
    
            return ctrl;
        })();
    
        particle.cloud = (function() {
    
            /**
             * Namespace cloud.
             * @memberof particle
             * @namespace
             */
            var cloud = {};
    
            cloud.ServerMovedPermanentlyRequest = (function() {
    
                /**
                 * Properties of a ServerMovedPermanentlyRequest.
                 * @memberof particle.cloud
                 * @interface IServerMovedPermanentlyRequest
                 * @property {string|null} [serverAddr] The address of the new server.
                 * 
                 * The address can be a domain name or IP address. A domain name may contain placeholder arguments
                 * such as `$id`.
                 * @property {number|null} [serverPort] The port number of the new server. The default value is 5684.
                 * @property {Uint8Array|null} [serverPubKey] The public key of the new server in DER format.
                 * @property {Uint8Array|null} [sign] The signature of the server details.
                 */
    
                /**
                 * Constructs a new ServerMovedPermanentlyRequest.
                 * @memberof particle.cloud
                 * @classdesc A request sent to the device to notify it that it must disconnect from the current server and
                 * use another server for further connections to the Cloud.
                 * @implements IServerMovedPermanentlyRequest
                 * @constructor
                 * @param {particle.cloud.IServerMovedPermanentlyRequest=} [properties] Properties to set
                 */
                function ServerMovedPermanentlyRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * The address of the new server.
                 * 
                 * The address can be a domain name or IP address. A domain name may contain placeholder arguments
                 * such as `$id`.
                 * @member {string} serverAddr
                 * @memberof particle.cloud.ServerMovedPermanentlyRequest
                 * @instance
                 */
                ServerMovedPermanentlyRequest.prototype.serverAddr = "";
    
                /**
                 * The port number of the new server. The default value is 5684.
                 * @member {number} serverPort
                 * @memberof particle.cloud.ServerMovedPermanentlyRequest
                 * @instance
                 */
                ServerMovedPermanentlyRequest.prototype.serverPort = 0;
    
                /**
                 * The public key of the new server in DER format.
                 * @member {Uint8Array} serverPubKey
                 * @memberof particle.cloud.ServerMovedPermanentlyRequest
                 * @instance
                 */
                ServerMovedPermanentlyRequest.prototype.serverPubKey = $util.newBuffer([]);
    
                /**
                 * The signature of the server details.
                 * @member {Uint8Array} sign
                 * @memberof particle.cloud.ServerMovedPermanentlyRequest
                 * @instance
                 */
                ServerMovedPermanentlyRequest.prototype.sign = $util.newBuffer([]);
    
                /**
                 * Creates a new ServerMovedPermanentlyRequest instance using the specified properties.
                 * @function create
                 * @memberof particle.cloud.ServerMovedPermanentlyRequest
                 * @static
                 * @param {particle.cloud.IServerMovedPermanentlyRequest=} [properties] Properties to set
                 * @returns {particle.cloud.ServerMovedPermanentlyRequest} ServerMovedPermanentlyRequest instance
                 */
                ServerMovedPermanentlyRequest.create = function create(properties) {
                    return new ServerMovedPermanentlyRequest(properties);
                };
    
                /**
                 * Encodes the specified ServerMovedPermanentlyRequest message. Does not implicitly {@link particle.cloud.ServerMovedPermanentlyRequest.verify|verify} messages.
                 * @function encode
                 * @memberof particle.cloud.ServerMovedPermanentlyRequest
                 * @static
                 * @param {particle.cloud.IServerMovedPermanentlyRequest} message ServerMovedPermanentlyRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServerMovedPermanentlyRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.serverAddr != null && Object.hasOwnProperty.call(message, "serverAddr"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverAddr);
                    if (message.serverPort != null && Object.hasOwnProperty.call(message, "serverPort"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.serverPort);
                    if (message.serverPubKey != null && Object.hasOwnProperty.call(message, "serverPubKey"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.serverPubKey);
                    if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.sign);
                    return writer;
                };
    
                /**
                 * Decodes a ServerMovedPermanentlyRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.cloud.ServerMovedPermanentlyRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.cloud.ServerMovedPermanentlyRequest} ServerMovedPermanentlyRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServerMovedPermanentlyRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ServerMovedPermanentlyRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.serverAddr = reader.string();
                            break;
                        case 2:
                            message.serverPort = reader.uint32();
                            break;
                        case 3:
                            message.serverPubKey = reader.bytes();
                            break;
                        case 4:
                            message.sign = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return ServerMovedPermanentlyRequest;
            })();
    
            cloud.ServerMovedPermanentlyResponse = (function() {
    
                /**
                 * Properties of a ServerMovedPermanentlyResponse.
                 * @memberof particle.cloud
                 * @interface IServerMovedPermanentlyResponse
                 */
    
                /**
                 * Constructs a new ServerMovedPermanentlyResponse.
                 * @memberof particle.cloud
                 * @classdesc A response for a ServerMovedPermanentlyRequest.
                 * @implements IServerMovedPermanentlyResponse
                 * @constructor
                 * @param {particle.cloud.IServerMovedPermanentlyResponse=} [properties] Properties to set
                 */
                function ServerMovedPermanentlyResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ServerMovedPermanentlyResponse instance using the specified properties.
                 * @function create
                 * @memberof particle.cloud.ServerMovedPermanentlyResponse
                 * @static
                 * @param {particle.cloud.IServerMovedPermanentlyResponse=} [properties] Properties to set
                 * @returns {particle.cloud.ServerMovedPermanentlyResponse} ServerMovedPermanentlyResponse instance
                 */
                ServerMovedPermanentlyResponse.create = function create(properties) {
                    return new ServerMovedPermanentlyResponse(properties);
                };
    
                /**
                 * Encodes the specified ServerMovedPermanentlyResponse message. Does not implicitly {@link particle.cloud.ServerMovedPermanentlyResponse.verify|verify} messages.
                 * @function encode
                 * @memberof particle.cloud.ServerMovedPermanentlyResponse
                 * @static
                 * @param {particle.cloud.IServerMovedPermanentlyResponse} message ServerMovedPermanentlyResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServerMovedPermanentlyResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Decodes a ServerMovedPermanentlyResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.cloud.ServerMovedPermanentlyResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.cloud.ServerMovedPermanentlyResponse} ServerMovedPermanentlyResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServerMovedPermanentlyResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ServerMovedPermanentlyResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return ServerMovedPermanentlyResponse;
            })();
    
            /**
             * Firmware module types.
             * @name particle.cloud.FirmwareModuleType
             * @enum {number}
             * @property {number} INVALID_MODULE=0 < Invalid
             * @property {number} RESOURCE_MODULE=1 < Resource module
             * @property {number} BOOTLOADER_MODULE=2 < Bootloader module
             * @property {number} MONO_FIRMWARE_MODULE=3 < Monolithic firmware module
             * @property {number} SYSTEM_PART_MODULE=4 < System part module
             * @property {number} USER_PART_MODULE=5 < User part module
             * @property {number} SETTINGS_MODULE=6 < Settings module
             * @property {number} NCP_FIRMWARE_MODULE=7 < NCP firmware module
             * @property {number} RADIO_STACK_MODULE=8 < Radio stack module
             * @property {number} ASSET_MODULE=9 < Asset module
             */
            cloud.FirmwareModuleType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INVALID_MODULE"] = 0;
                values[valuesById[1] = "RESOURCE_MODULE"] = 1;
                values[valuesById[2] = "BOOTLOADER_MODULE"] = 2;
                values[valuesById[3] = "MONO_FIRMWARE_MODULE"] = 3;
                values[valuesById[4] = "SYSTEM_PART_MODULE"] = 4;
                values[valuesById[5] = "USER_PART_MODULE"] = 5;
                values[valuesById[6] = "SETTINGS_MODULE"] = 6;
                values[valuesById[7] = "NCP_FIRMWARE_MODULE"] = 7;
                values[valuesById[8] = "RADIO_STACK_MODULE"] = 8;
                values[valuesById[9] = "ASSET_MODULE"] = 9;
                return values;
            })();
    
            /**
             * Firmware module store.
             * @name particle.cloud.FirmwareModuleStore
             * @enum {number}
             * @property {number} MAIN_MODULE_STORE=0 < Main store
             * @property {number} FACTORY_MODULE_STORE=1 < Factory store
             * @property {number} BACKUP_MODULE_STORE=2 < Backup store
             * @property {number} SCRATCHPAD_MODULE_STORE=3 < Scratchpad store
             */
            cloud.FirmwareModuleStore = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MAIN_MODULE_STORE"] = 0;
                values[valuesById[1] = "FACTORY_MODULE_STORE"] = 1;
                values[valuesById[2] = "BACKUP_MODULE_STORE"] = 2;
                values[valuesById[3] = "SCRATCHPAD_MODULE_STORE"] = 3;
                return values;
            })();
    
            /**
             * Firmware module validation flags.
             * @name particle.cloud.FirmwareModuleValidityFlag
             * @enum {number}
             * @property {number} MODULE_NO_VALID_FLAGS=0 MODULE_NO_VALID_FLAGS value
             * @property {number} MODULE_INTEGRITY_VALID_FLAG=2 < Module integrity
             * @property {number} MODULE_DEPENDENCIES_VALID_FLAG=4 < Module dependencies
             * @property {number} MODULE_RANGE_VALID_FLAG=8 < Module address and size
             * @property {number} MODULE_PLATFORM_VALID_FLAG=16 < Module platform
             */
            cloud.FirmwareModuleValidityFlag = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MODULE_NO_VALID_FLAGS"] = 0;
                values[valuesById[2] = "MODULE_INTEGRITY_VALID_FLAG"] = 2;
                values[valuesById[4] = "MODULE_DEPENDENCIES_VALID_FLAG"] = 4;
                values[valuesById[8] = "MODULE_RANGE_VALID_FLAG"] = 8;
                values[valuesById[16] = "MODULE_PLATFORM_VALID_FLAG"] = 16;
                return values;
            })();
    
            cloud.FirmwareModuleDependency = (function() {
    
                /**
                 * Properties of a FirmwareModuleDependency.
                 * @memberof particle.cloud
                 * @interface IFirmwareModuleDependency
                 * @property {particle.cloud.FirmwareModuleType|null} [type] < Module type
                 * @property {number|null} [index] < Module index
                 * @property {number|null} [version] < Module version
                 */
    
                /**
                 * Constructs a new FirmwareModuleDependency.
                 * @memberof particle.cloud
                 * @classdesc Firmware module dependency.
                 * @implements IFirmwareModuleDependency
                 * @constructor
                 * @param {particle.cloud.IFirmwareModuleDependency=} [properties] Properties to set
                 */
                function FirmwareModuleDependency(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * < Module type
                 * @member {particle.cloud.FirmwareModuleType} type
                 * @memberof particle.cloud.FirmwareModuleDependency
                 * @instance
                 */
                FirmwareModuleDependency.prototype.type = 0;
    
                /**
                 * < Module index
                 * @member {number} index
                 * @memberof particle.cloud.FirmwareModuleDependency
                 * @instance
                 */
                FirmwareModuleDependency.prototype.index = 0;
    
                /**
                 * < Module version
                 * @member {number} version
                 * @memberof particle.cloud.FirmwareModuleDependency
                 * @instance
                 */
                FirmwareModuleDependency.prototype.version = 0;
    
                /**
                 * Creates a new FirmwareModuleDependency instance using the specified properties.
                 * @function create
                 * @memberof particle.cloud.FirmwareModuleDependency
                 * @static
                 * @param {particle.cloud.IFirmwareModuleDependency=} [properties] Properties to set
                 * @returns {particle.cloud.FirmwareModuleDependency} FirmwareModuleDependency instance
                 */
                FirmwareModuleDependency.create = function create(properties) {
                    return new FirmwareModuleDependency(properties);
                };
    
                /**
                 * Encodes the specified FirmwareModuleDependency message. Does not implicitly {@link particle.cloud.FirmwareModuleDependency.verify|verify} messages.
                 * @function encode
                 * @memberof particle.cloud.FirmwareModuleDependency
                 * @static
                 * @param {particle.cloud.IFirmwareModuleDependency} message FirmwareModuleDependency message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FirmwareModuleDependency.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
                    if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);
                    return writer;
                };
    
                /**
                 * Decodes a FirmwareModuleDependency message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.cloud.FirmwareModuleDependency
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.cloud.FirmwareModuleDependency} FirmwareModuleDependency
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FirmwareModuleDependency.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.FirmwareModuleDependency();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.index = reader.uint32();
                            break;
                        case 3:
                            message.version = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return FirmwareModuleDependency;
            })();
    
            cloud.FirmwareModuleAsset = (function() {
    
                /**
                 * Properties of a FirmwareModuleAsset.
                 * @memberof particle.cloud
                 * @interface IFirmwareModuleAsset
                 * @property {Uint8Array|null} [hash] < SHA-256 hash
                 * @property {string|null} [name] < Asset name
                 */
    
                /**
                 * Constructs a new FirmwareModuleAsset.
                 * @memberof particle.cloud
                 * @classdesc Represents a FirmwareModuleAsset.
                 * @implements IFirmwareModuleAsset
                 * @constructor
                 * @param {particle.cloud.IFirmwareModuleAsset=} [properties] Properties to set
                 */
                function FirmwareModuleAsset(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * < SHA-256 hash
                 * @member {Uint8Array} hash
                 * @memberof particle.cloud.FirmwareModuleAsset
                 * @instance
                 */
                FirmwareModuleAsset.prototype.hash = $util.newBuffer([]);
    
                /**
                 * < Asset name
                 * @member {string} name
                 * @memberof particle.cloud.FirmwareModuleAsset
                 * @instance
                 */
                FirmwareModuleAsset.prototype.name = "";
    
                /**
                 * Creates a new FirmwareModuleAsset instance using the specified properties.
                 * @function create
                 * @memberof particle.cloud.FirmwareModuleAsset
                 * @static
                 * @param {particle.cloud.IFirmwareModuleAsset=} [properties] Properties to set
                 * @returns {particle.cloud.FirmwareModuleAsset} FirmwareModuleAsset instance
                 */
                FirmwareModuleAsset.create = function create(properties) {
                    return new FirmwareModuleAsset(properties);
                };
    
                /**
                 * Encodes the specified FirmwareModuleAsset message. Does not implicitly {@link particle.cloud.FirmwareModuleAsset.verify|verify} messages.
                 * @function encode
                 * @memberof particle.cloud.FirmwareModuleAsset
                 * @static
                 * @param {particle.cloud.IFirmwareModuleAsset} message FirmwareModuleAsset message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FirmwareModuleAsset.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    return writer;
                };
    
                /**
                 * Decodes a FirmwareModuleAsset message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.cloud.FirmwareModuleAsset
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.cloud.FirmwareModuleAsset} FirmwareModuleAsset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FirmwareModuleAsset.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.FirmwareModuleAsset();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.hash = reader.bytes();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return FirmwareModuleAsset;
            })();
    
            cloud.FirmwareModule = (function() {
    
                /**
                 * Properties of a FirmwareModule.
                 * @memberof particle.cloud
                 * @interface IFirmwareModule
                 * @property {particle.cloud.FirmwareModuleType|null} [type] < Module type
                 * @property {number|null} [index] < Module index
                 * @property {number|null} [version] < Module version
                 * @property {particle.cloud.FirmwareModuleStore|null} [store] < Module store
                 * @property {number|null} [maxSize] < Maximum module size
                 * @property {number|null} [checkedFlags] < Performed validation checks (see FirmwareModuleValidityFlag)
                 * @property {number|null} [passedFlags] < Passed validation checks (see FirmwareModuleValidityFlag)
                 * @property {Uint8Array|null} [hash] < SHA-256 hash
                 * @property {Array.<particle.cloud.IFirmwareModuleDependency>|null} [dependencies] < Module dependencies
                 * @property {Array.<particle.cloud.IFirmwareModuleAsset>|null} [assetDependencies] < Asset dependencies
                 */
    
                /**
                 * Constructs a new FirmwareModule.
                 * @memberof particle.cloud
                 * @classdesc Firmware module info.
                 * @implements IFirmwareModule
                 * @constructor
                 * @param {particle.cloud.IFirmwareModule=} [properties] Properties to set
                 */
                function FirmwareModule(properties) {
                    this.dependencies = [];
                    this.assetDependencies = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * < Module type
                 * @member {particle.cloud.FirmwareModuleType} type
                 * @memberof particle.cloud.FirmwareModule
                 * @instance
                 */
                FirmwareModule.prototype.type = 0;
    
                /**
                 * < Module index
                 * @member {number} index
                 * @memberof particle.cloud.FirmwareModule
                 * @instance
                 */
                FirmwareModule.prototype.index = 0;
    
                /**
                 * < Module version
                 * @member {number} version
                 * @memberof particle.cloud.FirmwareModule
                 * @instance
                 */
                FirmwareModule.prototype.version = 0;
    
                /**
                 * < Module store
                 * @member {particle.cloud.FirmwareModuleStore} store
                 * @memberof particle.cloud.FirmwareModule
                 * @instance
                 */
                FirmwareModule.prototype.store = 0;
    
                /**
                 * < Maximum module size
                 * @member {number} maxSize
                 * @memberof particle.cloud.FirmwareModule
                 * @instance
                 */
                FirmwareModule.prototype.maxSize = 0;
    
                /**
                 * < Performed validation checks (see FirmwareModuleValidityFlag)
                 * @member {number} checkedFlags
                 * @memberof particle.cloud.FirmwareModule
                 * @instance
                 */
                FirmwareModule.prototype.checkedFlags = 0;
    
                /**
                 * < Passed validation checks (see FirmwareModuleValidityFlag)
                 * @member {number} passedFlags
                 * @memberof particle.cloud.FirmwareModule
                 * @instance
                 */
                FirmwareModule.prototype.passedFlags = 0;
    
                /**
                 * < SHA-256 hash
                 * @member {Uint8Array|null|undefined} hash
                 * @memberof particle.cloud.FirmwareModule
                 * @instance
                 */
                FirmwareModule.prototype.hash = null;
    
                /**
                 * < Module dependencies
                 * @member {Array.<particle.cloud.IFirmwareModuleDependency>} dependencies
                 * @memberof particle.cloud.FirmwareModule
                 * @instance
                 */
                FirmwareModule.prototype.dependencies = $util.emptyArray;
    
                /**
                 * < Asset dependencies
                 * @member {Array.<particle.cloud.IFirmwareModuleAsset>} assetDependencies
                 * @memberof particle.cloud.FirmwareModule
                 * @instance
                 */
                FirmwareModule.prototype.assetDependencies = $util.emptyArray;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * FirmwareModule _hash.
                 * @member {"hash"|undefined} _hash
                 * @memberof particle.cloud.FirmwareModule
                 * @instance
                 */
                Object.defineProperty(FirmwareModule.prototype, "_hash", {
                    get: $util.oneOfGetter($oneOfFields = ["hash"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new FirmwareModule instance using the specified properties.
                 * @function create
                 * @memberof particle.cloud.FirmwareModule
                 * @static
                 * @param {particle.cloud.IFirmwareModule=} [properties] Properties to set
                 * @returns {particle.cloud.FirmwareModule} FirmwareModule instance
                 */
                FirmwareModule.create = function create(properties) {
                    return new FirmwareModule(properties);
                };
    
                /**
                 * Encodes the specified FirmwareModule message. Does not implicitly {@link particle.cloud.FirmwareModule.verify|verify} messages.
                 * @function encode
                 * @memberof particle.cloud.FirmwareModule
                 * @static
                 * @param {particle.cloud.IFirmwareModule} message FirmwareModule message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FirmwareModule.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
                    if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);
                    if (message.store != null && Object.hasOwnProperty.call(message, "store"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.store);
                    if (message.maxSize != null && Object.hasOwnProperty.call(message, "maxSize"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.maxSize);
                    if (message.checkedFlags != null && Object.hasOwnProperty.call(message, "checkedFlags"))
                        writer.uint32(/* id 6, wireType 5 =*/53).fixed32(message.checkedFlags);
                    if (message.passedFlags != null && Object.hasOwnProperty.call(message, "passedFlags"))
                        writer.uint32(/* id 7, wireType 5 =*/61).fixed32(message.passedFlags);
                    if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.hash);
                    if (message.dependencies != null && message.dependencies.length)
                        for (var i = 0; i < message.dependencies.length; ++i)
                            $root.particle.cloud.FirmwareModuleDependency.encode(message.dependencies[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.assetDependencies != null && message.assetDependencies.length)
                        for (var i = 0; i < message.assetDependencies.length; ++i)
                            $root.particle.cloud.FirmwareModuleAsset.encode(message.assetDependencies[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a FirmwareModule message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.cloud.FirmwareModule
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.cloud.FirmwareModule} FirmwareModule
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FirmwareModule.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.FirmwareModule();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.index = reader.uint32();
                            break;
                        case 3:
                            message.version = reader.uint32();
                            break;
                        case 4:
                            message.store = reader.int32();
                            break;
                        case 5:
                            message.maxSize = reader.uint32();
                            break;
                        case 6:
                            message.checkedFlags = reader.fixed32();
                            break;
                        case 7:
                            message.passedFlags = reader.fixed32();
                            break;
                        case 8:
                            message.hash = reader.bytes();
                            break;
                        case 9:
                            if (!(message.dependencies && message.dependencies.length))
                                message.dependencies = [];
                            message.dependencies.push($root.particle.cloud.FirmwareModuleDependency.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            if (!(message.assetDependencies && message.assetDependencies.length))
                                message.assetDependencies = [];
                            message.assetDependencies.push($root.particle.cloud.FirmwareModuleAsset.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return FirmwareModule;
            })();
    
            cloud.SystemDescribe = (function() {
    
                /**
                 * Properties of a SystemDescribe.
                 * @memberof particle.cloud
                 * @interface ISystemDescribe
                 * @property {Array.<particle.cloud.IFirmwareModule>|null} [firmwareModules] < Firmware modules
                 * @property {string|null} [imei] < IMEI (cellular platforms only)
                 * @property {string|null} [iccid] < ICCID (cellular platforms only)
                 * @property {string|null} [modemFirmwareVersion] < Modem firmware version (cellular platforms only)
                 * @property {Array.<particle.cloud.IFirmwareModuleAsset>|null} [assets] < List of valid assets currently present in device storage
                 */
    
                /**
                 * Constructs a new SystemDescribe.
                 * @memberof particle.cloud
                 * @classdesc System describe.
                 * @implements ISystemDescribe
                 * @constructor
                 * @param {particle.cloud.ISystemDescribe=} [properties] Properties to set
                 */
                function SystemDescribe(properties) {
                    this.firmwareModules = [];
                    this.assets = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * < Firmware modules
                 * @member {Array.<particle.cloud.IFirmwareModule>} firmwareModules
                 * @memberof particle.cloud.SystemDescribe
                 * @instance
                 */
                SystemDescribe.prototype.firmwareModules = $util.emptyArray;
    
                /**
                 * < IMEI (cellular platforms only)
                 * @member {string|null|undefined} imei
                 * @memberof particle.cloud.SystemDescribe
                 * @instance
                 */
                SystemDescribe.prototype.imei = null;
    
                /**
                 * < ICCID (cellular platforms only)
                 * @member {string|null|undefined} iccid
                 * @memberof particle.cloud.SystemDescribe
                 * @instance
                 */
                SystemDescribe.prototype.iccid = null;
    
                /**
                 * < Modem firmware version (cellular platforms only)
                 * @member {string|null|undefined} modemFirmwareVersion
                 * @memberof particle.cloud.SystemDescribe
                 * @instance
                 */
                SystemDescribe.prototype.modemFirmwareVersion = null;
    
                /**
                 * < List of valid assets currently present in device storage
                 * @member {Array.<particle.cloud.IFirmwareModuleAsset>} assets
                 * @memberof particle.cloud.SystemDescribe
                 * @instance
                 */
                SystemDescribe.prototype.assets = $util.emptyArray;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * SystemDescribe _imei.
                 * @member {"imei"|undefined} _imei
                 * @memberof particle.cloud.SystemDescribe
                 * @instance
                 */
                Object.defineProperty(SystemDescribe.prototype, "_imei", {
                    get: $util.oneOfGetter($oneOfFields = ["imei"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * SystemDescribe _iccid.
                 * @member {"iccid"|undefined} _iccid
                 * @memberof particle.cloud.SystemDescribe
                 * @instance
                 */
                Object.defineProperty(SystemDescribe.prototype, "_iccid", {
                    get: $util.oneOfGetter($oneOfFields = ["iccid"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * SystemDescribe _modemFirmwareVersion.
                 * @member {"modemFirmwareVersion"|undefined} _modemFirmwareVersion
                 * @memberof particle.cloud.SystemDescribe
                 * @instance
                 */
                Object.defineProperty(SystemDescribe.prototype, "_modemFirmwareVersion", {
                    get: $util.oneOfGetter($oneOfFields = ["modemFirmwareVersion"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new SystemDescribe instance using the specified properties.
                 * @function create
                 * @memberof particle.cloud.SystemDescribe
                 * @static
                 * @param {particle.cloud.ISystemDescribe=} [properties] Properties to set
                 * @returns {particle.cloud.SystemDescribe} SystemDescribe instance
                 */
                SystemDescribe.create = function create(properties) {
                    return new SystemDescribe(properties);
                };
    
                /**
                 * Encodes the specified SystemDescribe message. Does not implicitly {@link particle.cloud.SystemDescribe.verify|verify} messages.
                 * @function encode
                 * @memberof particle.cloud.SystemDescribe
                 * @static
                 * @param {particle.cloud.ISystemDescribe} message SystemDescribe message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SystemDescribe.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.firmwareModules != null && message.firmwareModules.length)
                        for (var i = 0; i < message.firmwareModules.length; ++i)
                            $root.particle.cloud.FirmwareModule.encode(message.firmwareModules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.imei != null && Object.hasOwnProperty.call(message, "imei"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.imei);
                    if (message.iccid != null && Object.hasOwnProperty.call(message, "iccid"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.iccid);
                    if (message.modemFirmwareVersion != null && Object.hasOwnProperty.call(message, "modemFirmwareVersion"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.modemFirmwareVersion);
                    if (message.assets != null && message.assets.length)
                        for (var i = 0; i < message.assets.length; ++i)
                            $root.particle.cloud.FirmwareModuleAsset.encode(message.assets[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a SystemDescribe message from the specified reader or buffer.
                 * @function decode
                 * @memberof particle.cloud.SystemDescribe
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {particle.cloud.SystemDescribe} SystemDescribe
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SystemDescribe.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.SystemDescribe();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.firmwareModules && message.firmwareModules.length))
                                message.firmwareModules = [];
                            message.firmwareModules.push($root.particle.cloud.FirmwareModule.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.imei = reader.string();
                            break;
                        case 3:
                            message.iccid = reader.string();
                            break;
                        case 4:
                            message.modemFirmwareVersion = reader.string();
                            break;
                        case 5:
                            if (!(message.assets && message.assets.length))
                                message.assets = [];
                            message.assets.push($root.particle.cloud.FirmwareModuleAsset.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return SystemDescribe;
            })();
    
            return cloud;
        })();
    
        return particle;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.FileDescriptorSet = (function() {
    
                /**
                 * Properties of a FileDescriptorSet.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorSet
                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
                 */
    
                /**
                 * Constructs a new FileDescriptorSet.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorSet.
                 * @implements IFileDescriptorSet
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 */
                function FileDescriptorSet(properties) {
                    this.file = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorSet file.
                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 */
                FileDescriptorSet.prototype.file = $util.emptyArray;
    
                /**
                 * Creates a new FileDescriptorSet instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
                 */
                FileDescriptorSet.create = function create(properties) {
                    return new FileDescriptorSet(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.file != null && message.file.length)
                        for (var i = 0; i < message.file.length; ++i)
                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return FileDescriptorSet;
            })();
    
            protobuf.FileDescriptorProto = (function() {
    
                /**
                 * Properties of a FileDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorProto
                 * @property {string|null} [name] FileDescriptorProto name
                 * @property {string|null} ["package"] FileDescriptorProto package
                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
                 * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
                 * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
                 * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
                 * @property {string|null} [syntax] FileDescriptorProto syntax
                 */
    
                /**
                 * Constructs a new FileDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorProto.
                 * @implements IFileDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 */
                function FileDescriptorProto(properties) {
                    this.dependency = [];
                    this.publicDependency = [];
                    this.weakDependency = [];
                    this.messageType = [];
                    this.enumType = [];
                    this.service = [];
                    this.extension = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.name = "";
    
                /**
                 * FileDescriptorProto package.
                 * @member {string} package
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype["package"] = "";
    
                /**
                 * FileDescriptorProto dependency.
                 * @member {Array.<string>} dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto publicDependency.
                 * @member {Array.<number>} publicDependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.publicDependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto weakDependency.
                 * @member {Array.<number>} weakDependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.weakDependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto messageType.
                 * @member {Array.<google.protobuf.IDescriptorProto>} messageType
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.messageType = $util.emptyArray;
    
                /**
                 * FileDescriptorProto enumType.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.enumType = $util.emptyArray;
    
                /**
                 * FileDescriptorProto service.
                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.service = $util.emptyArray;
    
                /**
                 * FileDescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * FileDescriptorProto options.
                 * @member {google.protobuf.IFileOptions|null|undefined} options
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.options = null;
    
                /**
                 * FileDescriptorProto sourceCodeInfo.
                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.sourceCodeInfo = null;
    
                /**
                 * FileDescriptorProto syntax.
                 * @member {string} syntax
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.syntax = "";
    
                /**
                 * Creates a new FileDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
                 */
                FileDescriptorProto.create = function create(properties) {
                    return new FileDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                    if (message.dependency != null && message.dependency.length)
                        for (var i = 0; i < message.dependency.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                    if (message.messageType != null && message.messageType.length)
                        for (var i = 0; i < message.messageType.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.enumType != null && message.enumType.length)
                        for (var i = 0; i < message.enumType.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.service != null && message.service.length)
                        for (var i = 0; i < message.service.length; ++i)
                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, "sourceCodeInfo"))
                        $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.publicDependency != null && message.publicDependency.length)
                        for (var i = 0; i < message.publicDependency.length; ++i)
                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                    if (message.weakDependency != null && message.weakDependency.length)
                        for (var i = 0; i < message.weakDependency.length; ++i)
                            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                    if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                    return writer;
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message["package"] = reader.string();
                            break;
                        case 3:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        case 10:
                            if (!(message.publicDependency && message.publicDependency.length))
                                message.publicDependency = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.publicDependency.push(reader.int32());
                            } else
                                message.publicDependency.push(reader.int32());
                            break;
                        case 11:
                            if (!(message.weakDependency && message.weakDependency.length))
                                message.weakDependency = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.weakDependency.push(reader.int32());
                            } else
                                message.weakDependency.push(reader.int32());
                            break;
                        case 4:
                            if (!(message.messageType && message.messageType.length))
                                message.messageType = [];
                            message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.enumType && message.enumType.length))
                                message.enumType = [];
                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.syntax = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return FileDescriptorProto;
            })();
    
            protobuf.DescriptorProto = (function() {
    
                /**
                 * Properties of a DescriptorProto.
                 * @memberof google.protobuf
                 * @interface IDescriptorProto
                 * @property {string|null} [name] DescriptorProto name
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
                 * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
                 * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
                 * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
                 */
    
                /**
                 * Constructs a new DescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a DescriptorProto.
                 * @implements IDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 */
                function DescriptorProto(properties) {
                    this.field = [];
                    this.extension = [];
                    this.nestedType = [];
                    this.enumType = [];
                    this.extensionRange = [];
                    this.oneofDecl = [];
                    this.reservedRange = [];
                    this.reservedName = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.name = "";
    
                /**
                 * DescriptorProto field.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.field = $util.emptyArray;
    
                /**
                 * DescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * DescriptorProto nestedType.
                 * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.nestedType = $util.emptyArray;
    
                /**
                 * DescriptorProto enumType.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.enumType = $util.emptyArray;
    
                /**
                 * DescriptorProto extensionRange.
                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extensionRange = $util.emptyArray;
    
                /**
                 * DescriptorProto oneofDecl.
                 * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.oneofDecl = $util.emptyArray;
    
                /**
                 * DescriptorProto options.
                 * @member {google.protobuf.IMessageOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.options = null;
    
                /**
                 * DescriptorProto reservedRange.
                 * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.reservedRange = $util.emptyArray;
    
                /**
                 * DescriptorProto reservedName.
                 * @member {Array.<string>} reservedName
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.reservedName = $util.emptyArray;
    
                /**
                 * Creates a new DescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
                 */
                DescriptorProto.create = function create(properties) {
                    return new DescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.field != null && message.field.length)
                        for (var i = 0; i < message.field.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nestedType != null && message.nestedType.length)
                        for (var i = 0; i < message.nestedType.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enumType != null && message.enumType.length)
                        for (var i = 0; i < message.enumType.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.extensionRange != null && message.extensionRange.length)
                        for (var i = 0; i < message.extensionRange.length; ++i)
                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.oneofDecl != null && message.oneofDecl.length)
                        for (var i = 0; i < message.oneofDecl.length; ++i)
                            $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.reservedRange != null && message.reservedRange.length)
                        for (var i = 0; i < message.reservedRange.length; ++i)
                            $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.reservedName != null && message.reservedName.length)
                        for (var i = 0; i < message.reservedName.length; ++i)
                            writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                    return writer;
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nestedType && message.nestedType.length))
                                message.nestedType = [];
                            message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.enumType && message.enumType.length))
                                message.enumType = [];
                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.extensionRange && message.extensionRange.length))
                                message.extensionRange = [];
                            message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            if (!(message.oneofDecl && message.oneofDecl.length))
                                message.oneofDecl = [];
                            message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            if (!(message.reservedRange && message.reservedRange.length))
                                message.reservedRange = [];
                            message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            if (!(message.reservedName && message.reservedName.length))
                                message.reservedName = [];
                            message.reservedName.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                DescriptorProto.ExtensionRange = (function() {
    
                    /**
                     * Properties of an ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IExtensionRange
                     * @property {number|null} [start] ExtensionRange start
                     * @property {number|null} [end] ExtensionRange end
                     */
    
                    /**
                     * Constructs a new ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents an ExtensionRange.
                     * @implements IExtensionRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     */
                    function ExtensionRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ExtensionRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.start = 0;
    
                    /**
                     * ExtensionRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.end = 0;
    
                    /**
                     * Creates a new ExtensionRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                     */
                    ExtensionRange.create = function create(properties) {
                        return new ExtensionRange(properties);
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return ExtensionRange;
                })();
    
                DescriptorProto.ReservedRange = (function() {
    
                    /**
                     * Properties of a ReservedRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IReservedRange
                     * @property {number|null} [start] ReservedRange start
                     * @property {number|null} [end] ReservedRange end
                     */
    
                    /**
                     * Constructs a new ReservedRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents a ReservedRange.
                     * @implements IReservedRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                     */
                    function ReservedRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ReservedRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     */
                    ReservedRange.prototype.start = 0;
    
                    /**
                     * ReservedRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     */
                    ReservedRange.prototype.end = 0;
    
                    /**
                     * Creates a new ReservedRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                     */
                    ReservedRange.create = function create(properties) {
                        return new ReservedRange(properties);
                    };
    
                    /**
                     * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ReservedRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Decodes a ReservedRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ReservedRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return ReservedRange;
                })();
    
                return DescriptorProto;
            })();
    
            protobuf.FieldDescriptorProto = (function() {
    
                /**
                 * Properties of a FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFieldDescriptorProto
                 * @property {string|null} [name] FieldDescriptorProto name
                 * @property {number|null} [number] FieldDescriptorProto number
                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
                 * @property {string|null} [typeName] FieldDescriptorProto typeName
                 * @property {string|null} [extendee] FieldDescriptorProto extendee
                 * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
                 * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
                 * @property {string|null} [jsonName] FieldDescriptorProto jsonName
                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
                 */
    
                /**
                 * Constructs a new FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldDescriptorProto.
                 * @implements IFieldDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 */
                function FieldDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.name = "";
    
                /**
                 * FieldDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.number = 0;
    
                /**
                 * FieldDescriptorProto label.
                 * @member {google.protobuf.FieldDescriptorProto.Label} label
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.label = 1;
    
                /**
                 * FieldDescriptorProto type.
                 * @member {google.protobuf.FieldDescriptorProto.Type} type
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type = 1;
    
                /**
                 * FieldDescriptorProto typeName.
                 * @member {string} typeName
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.typeName = "";
    
                /**
                 * FieldDescriptorProto extendee.
                 * @member {string} extendee
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.extendee = "";
    
                /**
                 * FieldDescriptorProto defaultValue.
                 * @member {string} defaultValue
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.defaultValue = "";
    
                /**
                 * FieldDescriptorProto oneofIndex.
                 * @member {number} oneofIndex
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.oneofIndex = 0;
    
                /**
                 * FieldDescriptorProto jsonName.
                 * @member {string} jsonName
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.jsonName = "";
    
                /**
                 * FieldDescriptorProto options.
                 * @member {google.protobuf.IFieldOptions|null|undefined} options
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new FieldDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
                 */
                FieldDescriptorProto.create = function create(properties) {
                    return new FieldDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                    if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                    if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.oneofIndex != null && Object.hasOwnProperty.call(message, "oneofIndex"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                    if (message.jsonName != null && Object.hasOwnProperty.call(message, "jsonName"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                    return writer;
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.number = reader.int32();
                            break;
                        case 4:
                            message.label = reader.int32();
                            break;
                        case 5:
                            message.type = reader.int32();
                            break;
                        case 6:
                            message.typeName = reader.string();
                            break;
                        case 2:
                            message.extendee = reader.string();
                            break;
                        case 7:
                            message.defaultValue = reader.string();
                            break;
                        case 9:
                            message.oneofIndex = reader.int32();
                            break;
                        case 10:
                            message.jsonName = reader.string();
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Type enum.
                 * @name google.protobuf.FieldDescriptorProto.Type
                 * @enum {number}
                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
                 * @property {number} TYPE_INT64=3 TYPE_INT64 value
                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
                 * @property {number} TYPE_INT32=5 TYPE_INT32 value
                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value
                 * @property {number} TYPE_STRING=9 TYPE_STRING value
                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value
                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value
                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value
                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
                 */
                FieldDescriptorProto.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                    values[valuesById[2] = "TYPE_FLOAT"] = 2;
                    values[valuesById[3] = "TYPE_INT64"] = 3;
                    values[valuesById[4] = "TYPE_UINT64"] = 4;
                    values[valuesById[5] = "TYPE_INT32"] = 5;
                    values[valuesById[6] = "TYPE_FIXED64"] = 6;
                    values[valuesById[7] = "TYPE_FIXED32"] = 7;
                    values[valuesById[8] = "TYPE_BOOL"] = 8;
                    values[valuesById[9] = "TYPE_STRING"] = 9;
                    values[valuesById[10] = "TYPE_GROUP"] = 10;
                    values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                    values[valuesById[12] = "TYPE_BYTES"] = 12;
                    values[valuesById[13] = "TYPE_UINT32"] = 13;
                    values[valuesById[14] = "TYPE_ENUM"] = 14;
                    values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                    values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                    values[valuesById[17] = "TYPE_SINT32"] = 17;
                    values[valuesById[18] = "TYPE_SINT64"] = 18;
                    return values;
                })();
    
                /**
                 * Label enum.
                 * @name google.protobuf.FieldDescriptorProto.Label
                 * @enum {number}
                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
                 */
                FieldDescriptorProto.Label = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                    values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                    values[valuesById[3] = "LABEL_REPEATED"] = 3;
                    return values;
                })();
    
                return FieldDescriptorProto;
            })();
    
            protobuf.OneofDescriptorProto = (function() {
    
                /**
                 * Properties of an OneofDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IOneofDescriptorProto
                 * @property {string|null} [name] OneofDescriptorProto name
                 * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
                 */
    
                /**
                 * Constructs a new OneofDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an OneofDescriptorProto.
                 * @implements IOneofDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
                 */
                function OneofDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneofDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 */
                OneofDescriptorProto.prototype.name = "";
    
                /**
                 * OneofDescriptorProto options.
                 * @member {google.protobuf.IOneofOptions|null|undefined} options
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 */
                OneofDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new OneofDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
                 */
                OneofDescriptorProto.create = function create(properties) {
                    return new OneofDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an OneofDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return OneofDescriptorProto;
            })();
    
            protobuf.EnumDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumDescriptorProto
                 * @property {string|null} [name] EnumDescriptorProto name
                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumDescriptorProto.
                 * @implements IEnumDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 */
                function EnumDescriptorProto(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.name = "";
    
                /**
                 * EnumDescriptorProto value.
                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.value = $util.emptyArray;
    
                /**
                 * EnumDescriptorProto options.
                 * @member {google.protobuf.IEnumOptions|null|undefined} options
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
                 */
                EnumDescriptorProto.create = function create(properties) {
                    return new EnumDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return EnumDescriptorProto;
            })();
    
            protobuf.EnumValueDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumValueDescriptorProto
                 * @property {string|null} [name] EnumValueDescriptorProto name
                 * @property {number|null} [number] EnumValueDescriptorProto number
                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueDescriptorProto.
                 * @implements IEnumValueDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 */
                function EnumValueDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.name = "";
    
                /**
                 * EnumValueDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.number = 0;
    
                /**
                 * EnumValueDescriptorProto options.
                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumValueDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
                 */
                EnumValueDescriptorProto.create = function create(properties) {
                    return new EnumValueDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return EnumValueDescriptorProto;
            })();
    
            protobuf.ServiceDescriptorProto = (function() {
    
                /**
                 * Properties of a ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IServiceDescriptorProto
                 * @property {string|null} [name] ServiceDescriptorProto name
                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
                 */
    
                /**
                 * Constructs a new ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceDescriptorProto.
                 * @implements IServiceDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 */
                function ServiceDescriptorProto(properties) {
                    this.method = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.name = "";
    
                /**
                 * ServiceDescriptorProto method.
                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.method = $util.emptyArray;
    
                /**
                 * ServiceDescriptorProto options.
                 * @member {google.protobuf.IServiceOptions|null|undefined} options
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new ServiceDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
                 */
                ServiceDescriptorProto.create = function create(properties) {
                    return new ServiceDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.method != null && message.method.length)
                        for (var i = 0; i < message.method.length; ++i)
                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return ServiceDescriptorProto;
            })();
    
            protobuf.MethodDescriptorProto = (function() {
    
                /**
                 * Properties of a MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IMethodDescriptorProto
                 * @property {string|null} [name] MethodDescriptorProto name
                 * @property {string|null} [inputType] MethodDescriptorProto inputType
                 * @property {string|null} [outputType] MethodDescriptorProto outputType
                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
                 * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
                 * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
                 */
    
                /**
                 * Constructs a new MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodDescriptorProto.
                 * @implements IMethodDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 */
                function MethodDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.name = "";
    
                /**
                 * MethodDescriptorProto inputType.
                 * @member {string} inputType
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.inputType = "";
    
                /**
                 * MethodDescriptorProto outputType.
                 * @member {string} outputType
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.outputType = "";
    
                /**
                 * MethodDescriptorProto options.
                 * @member {google.protobuf.IMethodOptions|null|undefined} options
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.options = null;
    
                /**
                 * MethodDescriptorProto clientStreaming.
                 * @member {boolean} clientStreaming
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.clientStreaming = false;
    
                /**
                 * MethodDescriptorProto serverStreaming.
                 * @member {boolean} serverStreaming
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.serverStreaming = false;
    
                /**
                 * Creates a new MethodDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
                 */
                MethodDescriptorProto.create = function create(properties) {
                    return new MethodDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                    if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.clientStreaming != null && Object.hasOwnProperty.call(message, "clientStreaming"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                    if (message.serverStreaming != null && Object.hasOwnProperty.call(message, "serverStreaming"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                    return writer;
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.inputType = reader.string();
                            break;
                        case 3:
                            message.outputType = reader.string();
                            break;
                        case 4:
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.clientStreaming = reader.bool();
                            break;
                        case 6:
                            message.serverStreaming = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return MethodDescriptorProto;
            })();
    
            protobuf.FileOptions = (function() {
    
                /**
                 * Properties of a FileOptions.
                 * @memberof google.protobuf
                 * @interface IFileOptions
                 * @property {string|null} [javaPackage] FileOptions javaPackage
                 * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
                 * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
                 * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
                 * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
                 * @property {string|null} [goPackage] FileOptions goPackage
                 * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
                 * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
                 * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
                 * @property {boolean|null} [deprecated] FileOptions deprecated
                 * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
                 * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
                 * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
                 * @property {INanoPBOptions|null} [".nanopbFileopt"] FileOptions .nanopbFileopt
                 */
    
                /**
                 * Constructs a new FileOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileOptions.
                 * @implements IFileOptions
                 * @constructor
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 */
                function FileOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileOptions javaPackage.
                 * @member {string} javaPackage
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaPackage = "";
    
                /**
                 * FileOptions javaOuterClassname.
                 * @member {string} javaOuterClassname
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaOuterClassname = "";
    
                /**
                 * FileOptions javaMultipleFiles.
                 * @member {boolean} javaMultipleFiles
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaMultipleFiles = false;
    
                /**
                 * FileOptions javaGenerateEqualsAndHash.
                 * @member {boolean} javaGenerateEqualsAndHash
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaGenerateEqualsAndHash = false;
    
                /**
                 * FileOptions javaStringCheckUtf8.
                 * @member {boolean} javaStringCheckUtf8
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaStringCheckUtf8 = false;
    
                /**
                 * FileOptions optimizeFor.
                 * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.optimizeFor = 1;
    
                /**
                 * FileOptions goPackage.
                 * @member {string} goPackage
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.goPackage = "";
    
                /**
                 * FileOptions ccGenericServices.
                 * @member {boolean} ccGenericServices
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.ccGenericServices = false;
    
                /**
                 * FileOptions javaGenericServices.
                 * @member {boolean} javaGenericServices
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaGenericServices = false;
    
                /**
                 * FileOptions pyGenericServices.
                 * @member {boolean} pyGenericServices
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.pyGenericServices = false;
    
                /**
                 * FileOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.deprecated = false;
    
                /**
                 * FileOptions ccEnableArenas.
                 * @member {boolean} ccEnableArenas
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.ccEnableArenas = false;
    
                /**
                 * FileOptions objcClassPrefix.
                 * @member {string} objcClassPrefix
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.objcClassPrefix = "";
    
                /**
                 * FileOptions csharpNamespace.
                 * @member {string} csharpNamespace
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.csharpNamespace = "";
    
                /**
                 * FileOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * FileOptions .nanopbFileopt.
                 * @member {INanoPBOptions|null|undefined} .nanopbFileopt
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype[".nanopbFileopt"] = null;
    
                /**
                 * Creates a new FileOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FileOptions} FileOptions instance
                 */
                FileOptions.create = function create(properties) {
                    return new FileOptions(properties);
                };
    
                /**
                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.javaPackage != null && Object.hasOwnProperty.call(message, "javaPackage"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                    if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, "javaOuterClassname"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                    if (message.optimizeFor != null && Object.hasOwnProperty.call(message, "optimizeFor"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                    if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, "javaMultipleFiles"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                    if (message.goPackage != null && Object.hasOwnProperty.call(message, "goPackage"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                    if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, "ccGenericServices"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                    if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, "javaGenericServices"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                    if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, "pyGenericServices"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                    if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, "javaGenerateEqualsAndHash"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                    if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, "javaStringCheckUtf8"))
                        writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                    if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, "ccEnableArenas"))
                        writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                    if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, "objcClassPrefix"))
                        writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                    if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, "csharpNamespace"))
                        writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".nanopbFileopt"] != null && Object.hasOwnProperty.call(message, ".nanopbFileopt"))
                        $root.NanoPBOptions.encode(message[".nanopbFileopt"], writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.javaPackage = reader.string();
                            break;
                        case 8:
                            message.javaOuterClassname = reader.string();
                            break;
                        case 10:
                            message.javaMultipleFiles = reader.bool();
                            break;
                        case 20:
                            message.javaGenerateEqualsAndHash = reader.bool();
                            break;
                        case 27:
                            message.javaStringCheckUtf8 = reader.bool();
                            break;
                        case 9:
                            message.optimizeFor = reader.int32();
                            break;
                        case 11:
                            message.goPackage = reader.string();
                            break;
                        case 16:
                            message.ccGenericServices = reader.bool();
                            break;
                        case 17:
                            message.javaGenericServices = reader.bool();
                            break;
                        case 18:
                            message.pyGenericServices = reader.bool();
                            break;
                        case 23:
                            message.deprecated = reader.bool();
                            break;
                        case 31:
                            message.ccEnableArenas = reader.bool();
                            break;
                        case 36:
                            message.objcClassPrefix = reader.string();
                            break;
                        case 37:
                            message.csharpNamespace = reader.string();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 1010:
                            message[".nanopbFileopt"] = $root.NanoPBOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * OptimizeMode enum.
                 * @name google.protobuf.FileOptions.OptimizeMode
                 * @enum {number}
                 * @property {number} SPEED=1 SPEED value
                 * @property {number} CODE_SIZE=2 CODE_SIZE value
                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
                 */
                FileOptions.OptimizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "SPEED"] = 1;
                    values[valuesById[2] = "CODE_SIZE"] = 2;
                    values[valuesById[3] = "LITE_RUNTIME"] = 3;
                    return values;
                })();
    
                return FileOptions;
            })();
    
            protobuf.MessageOptions = (function() {
    
                /**
                 * Properties of a MessageOptions.
                 * @memberof google.protobuf
                 * @interface IMessageOptions
                 * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
                 * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
                 * @property {boolean|null} [deprecated] MessageOptions deprecated
                 * @property {boolean|null} [mapEntry] MessageOptions mapEntry
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
                 * @property {number|null} [".typeId"] MessageOptions .typeId
                 * @property {INanoPBOptions|null} [".nanopbMsgopt"] MessageOptions .nanopbMsgopt
                 */
    
                /**
                 * Constructs a new MessageOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MessageOptions.
                 * @implements IMessageOptions
                 * @constructor
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 */
                function MessageOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MessageOptions messageSetWireFormat.
                 * @member {boolean} messageSetWireFormat
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.messageSetWireFormat = false;
    
                /**
                 * MessageOptions noStandardDescriptorAccessor.
                 * @member {boolean} noStandardDescriptorAccessor
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.noStandardDescriptorAccessor = false;
    
                /**
                 * MessageOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.deprecated = false;
    
                /**
                 * MessageOptions mapEntry.
                 * @member {boolean} mapEntry
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.mapEntry = false;
    
                /**
                 * MessageOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * MessageOptions .typeId.
                 * @member {number} .typeId
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype[".typeId"] = 0;
    
                /**
                 * MessageOptions .nanopbMsgopt.
                 * @member {INanoPBOptions|null|undefined} .nanopbMsgopt
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype[".nanopbMsgopt"] = null;
    
                /**
                 * Creates a new MessageOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MessageOptions} MessageOptions instance
                 */
                MessageOptions.create = function create(properties) {
                    return new MessageOptions(properties);
                };
    
                /**
                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, "messageSetWireFormat"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                    if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, "noStandardDescriptorAccessor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.mapEntry != null && Object.hasOwnProperty.call(message, "mapEntry"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".nanopbMsgopt"] != null && Object.hasOwnProperty.call(message, ".nanopbMsgopt"))
                        $root.NanoPBOptions.encode(message[".nanopbMsgopt"], writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();
                    if (message[".typeId"] != null && Object.hasOwnProperty.call(message, ".typeId"))
                        writer.uint32(/* id 50001, wireType 0 =*/400008).int32(message[".typeId"]);
                    return writer;
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.messageSetWireFormat = reader.bool();
                            break;
                        case 2:
                            message.noStandardDescriptorAccessor = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 7:
                            message.mapEntry = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 50001:
                            message[".typeId"] = reader.int32();
                            break;
                        case 1010:
                            message[".nanopbMsgopt"] = $root.NanoPBOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return MessageOptions;
            })();
    
            protobuf.FieldOptions = (function() {
    
                /**
                 * Properties of a FieldOptions.
                 * @memberof google.protobuf
                 * @interface IFieldOptions
                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
                 * @property {boolean|null} [packed] FieldOptions packed
                 * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
                 * @property {boolean|null} [lazy] FieldOptions lazy
                 * @property {boolean|null} [deprecated] FieldOptions deprecated
                 * @property {boolean|null} [weak] FieldOptions weak
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
                 * @property {INanoPBOptions|null} [".nanopb"] FieldOptions .nanopb
                 */
    
                /**
                 * Constructs a new FieldOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldOptions.
                 * @implements IFieldOptions
                 * @constructor
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 */
                function FieldOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldOptions ctype.
                 * @member {google.protobuf.FieldOptions.CType} ctype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.ctype = 0;
    
                /**
                 * FieldOptions packed.
                 * @member {boolean} packed
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.packed = false;
    
                /**
                 * FieldOptions jstype.
                 * @member {google.protobuf.FieldOptions.JSType} jstype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.jstype = 0;
    
                /**
                 * FieldOptions lazy.
                 * @member {boolean} lazy
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.lazy = false;
    
                /**
                 * FieldOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.deprecated = false;
    
                /**
                 * FieldOptions weak.
                 * @member {boolean} weak
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.weak = false;
    
                /**
                 * FieldOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * FieldOptions .nanopb.
                 * @member {INanoPBOptions|null|undefined} .nanopb
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype[".nanopb"] = null;
    
                /**
                 * Creates a new FieldOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions} FieldOptions instance
                 */
                FieldOptions.create = function create(properties) {
                    return new FieldOptions(properties);
                };
    
                /**
                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                    if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                    if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                    if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".nanopb"] != null && Object.hasOwnProperty.call(message, ".nanopb"))
                        $root.NanoPBOptions.encode(message[".nanopb"], writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ctype = reader.int32();
                            break;
                        case 2:
                            message.packed = reader.bool();
                            break;
                        case 6:
                            message.jstype = reader.int32();
                            break;
                        case 5:
                            message.lazy = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 10:
                            message.weak = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 1010:
                            message[".nanopb"] = $root.NanoPBOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * CType enum.
                 * @name google.protobuf.FieldOptions.CType
                 * @enum {number}
                 * @property {number} STRING=0 STRING value
                 * @property {number} CORD=1 CORD value
                 * @property {number} STRING_PIECE=2 STRING_PIECE value
                 */
                FieldOptions.CType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRING"] = 0;
                    values[valuesById[1] = "CORD"] = 1;
                    values[valuesById[2] = "STRING_PIECE"] = 2;
                    return values;
                })();
    
                /**
                 * JSType enum.
                 * @name google.protobuf.FieldOptions.JSType
                 * @enum {number}
                 * @property {number} JS_NORMAL=0 JS_NORMAL value
                 * @property {number} JS_STRING=1 JS_STRING value
                 * @property {number} JS_NUMBER=2 JS_NUMBER value
                 */
                FieldOptions.JSType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "JS_NORMAL"] = 0;
                    values[valuesById[1] = "JS_STRING"] = 1;
                    values[valuesById[2] = "JS_NUMBER"] = 2;
                    return values;
                })();
    
                return FieldOptions;
            })();
    
            protobuf.OneofOptions = (function() {
    
                /**
                 * Properties of an OneofOptions.
                 * @memberof google.protobuf
                 * @interface IOneofOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new OneofOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an OneofOptions.
                 * @implements IOneofOptions
                 * @constructor
                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
                 */
                function OneofOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneofOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.OneofOptions
                 * @instance
                 */
                OneofOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new OneofOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
                 * @returns {google.protobuf.OneofOptions} OneofOptions instance
                 */
                OneofOptions.create = function create(properties) {
                    return new OneofOptions(properties);
                };
    
                /**
                 * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an OneofOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return OneofOptions;
            })();
    
            protobuf.EnumOptions = (function() {
    
                /**
                 * Properties of an EnumOptions.
                 * @memberof google.protobuf
                 * @interface IEnumOptions
                 * @property {boolean|null} [allowAlias] EnumOptions allowAlias
                 * @property {boolean|null} [deprecated] EnumOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
                 * @property {INanoPBOptions|null} [".nanopbEnumopt"] EnumOptions .nanopbEnumopt
                 */
    
                /**
                 * Constructs a new EnumOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumOptions.
                 * @implements IEnumOptions
                 * @constructor
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 */
                function EnumOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumOptions allowAlias.
                 * @member {boolean} allowAlias
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.allowAlias = false;
    
                /**
                 * EnumOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.deprecated = false;
    
                /**
                 * EnumOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * EnumOptions .nanopbEnumopt.
                 * @member {INanoPBOptions|null|undefined} .nanopbEnumopt
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype[".nanopbEnumopt"] = null;
    
                /**
                 * Creates a new EnumOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumOptions} EnumOptions instance
                 */
                EnumOptions.create = function create(properties) {
                    return new EnumOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.allowAlias != null && Object.hasOwnProperty.call(message, "allowAlias"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".nanopbEnumopt"] != null && Object.hasOwnProperty.call(message, ".nanopbEnumopt"))
                        $root.NanoPBOptions.encode(message[".nanopbEnumopt"], writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.allowAlias = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 1010:
                            message[".nanopbEnumopt"] = $root.NanoPBOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return EnumOptions;
            })();
    
            protobuf.EnumValueOptions = (function() {
    
                /**
                 * Properties of an EnumValueOptions.
                 * @memberof google.protobuf
                 * @interface IEnumValueOptions
                 * @property {boolean|null} [deprecated] EnumValueOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
                 * @property {number|null} [".intValue"] EnumValueOptions .intValue
                 */
    
                /**
                 * Constructs a new EnumValueOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueOptions.
                 * @implements IEnumValueOptions
                 * @constructor
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 */
                function EnumValueOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.deprecated = false;
    
                /**
                 * EnumValueOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * EnumValueOptions .intValue.
                 * @member {number} .intValue
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype[".intValue"] = 0;
    
                /**
                 * Creates a new EnumValueOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
                 */
                EnumValueOptions.create = function create(properties) {
                    return new EnumValueOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".intValue"] != null && Object.hasOwnProperty.call(message, ".intValue"))
                        writer.uint32(/* id 50002, wireType 0 =*/400016).int32(message[".intValue"]);
                    return writer;
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 50002:
                            message[".intValue"] = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return EnumValueOptions;
            })();
    
            protobuf.ServiceOptions = (function() {
    
                /**
                 * Properties of a ServiceOptions.
                 * @memberof google.protobuf
                 * @interface IServiceOptions
                 * @property {boolean|null} [deprecated] ServiceOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new ServiceOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceOptions.
                 * @implements IServiceOptions
                 * @constructor
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 */
                function ServiceOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.deprecated = false;
    
                /**
                 * ServiceOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new ServiceOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
                 */
                ServiceOptions.create = function create(properties) {
                    return new ServiceOptions(properties);
                };
    
                /**
                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 33:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return ServiceOptions;
            })();
    
            protobuf.MethodOptions = (function() {
    
                /**
                 * Properties of a MethodOptions.
                 * @memberof google.protobuf
                 * @interface IMethodOptions
                 * @property {boolean|null} [deprecated] MethodOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new MethodOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodOptions.
                 * @implements IMethodOptions
                 * @constructor
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 */
                function MethodOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.deprecated = false;
    
                /**
                 * MethodOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new MethodOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MethodOptions} MethodOptions instance
                 */
                MethodOptions.create = function create(properties) {
                    return new MethodOptions(properties);
                };
    
                /**
                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 33:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                return MethodOptions;
            })();
    
            protobuf.UninterpretedOption = (function() {
    
                /**
                 * Properties of an UninterpretedOption.
                 * @memberof google.protobuf
                 * @interface IUninterpretedOption
                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
                 * @property {string|null} [identifierValue] UninterpretedOption identifierValue
                 * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
                 * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
                 * @property {number|null} [doubleValue] UninterpretedOption doubleValue
                 * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
                 * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
                 */
    
                /**
                 * Constructs a new UninterpretedOption.
                 * @memberof google.protobuf
                 * @classdesc Represents an UninterpretedOption.
                 * @implements IUninterpretedOption
                 * @constructor
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 */
                function UninterpretedOption(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UninterpretedOption name.
                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.name = $util.emptyArray;
    
                /**
                 * UninterpretedOption identifierValue.
                 * @member {string} identifierValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.identifierValue = "";
    
                /**
                 * UninterpretedOption positiveIntValue.
                 * @member {number|Long} positiveIntValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UninterpretedOption negativeIntValue.
                 * @member {number|Long} negativeIntValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * UninterpretedOption doubleValue.
                 * @member {number} doubleValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.doubleValue = 0;
    
                /**
                 * UninterpretedOption stringValue.
                 * @member {Uint8Array} stringValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.stringValue = $util.newBuffer([]);
    
                /**
                 * UninterpretedOption aggregateValue.
                 * @member {string} aggregateValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.aggregateValue = "";
    
                /**
                 * Creates a new UninterpretedOption instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
                 */
                UninterpretedOption.create = function create(properties) {
                    return new UninterpretedOption(properties);
                };
    
                /**
                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.identifierValue != null && Object.hasOwnProperty.call(message, "identifierValue"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                    if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, "positiveIntValue"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                    if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, "negativeIntValue"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                    if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                    if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                    if (message.aggregateValue != null && Object.hasOwnProperty.call(message, "aggregateValue"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                    return writer;
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.identifierValue = reader.string();
                            break;
                        case 4:
                            message.positiveIntValue = reader.uint64();
                            break;
                        case 5:
                            message.negativeIntValue = reader.int64();
                            break;
                        case 6:
                            message.doubleValue = reader.double();
                            break;
                        case 7:
                            message.stringValue = reader.bytes();
                            break;
                        case 8:
                            message.aggregateValue = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                UninterpretedOption.NamePart = (function() {
    
                    /**
                     * Properties of a NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @interface INamePart
                     * @property {string} namePart NamePart namePart
                     * @property {boolean} isExtension NamePart isExtension
                     */
    
                    /**
                     * Constructs a new NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @classdesc Represents a NamePart.
                     * @implements INamePart
                     * @constructor
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     */
                    function NamePart(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NamePart namePart.
                     * @member {string} namePart
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.namePart = "";
    
                    /**
                     * NamePart isExtension.
                     * @member {boolean} isExtension
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.isExtension = false;
    
                    /**
                     * Creates a new NamePart instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                     */
                    NamePart.create = function create(properties) {
                        return new NamePart(properties);
                    };
    
                    /**
                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                        return writer;
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.namePart = reader.string();
                                break;
                            case 2:
                                message.isExtension = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("namePart"))
                            throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                        if (!message.hasOwnProperty("isExtension"))
                            throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                        return message;
                    };
    
                    return NamePart;
                })();
    
                return UninterpretedOption;
            })();
    
            protobuf.SourceCodeInfo = (function() {
    
                /**
                 * Properties of a SourceCodeInfo.
                 * @memberof google.protobuf
                 * @interface ISourceCodeInfo
                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
                 */
    
                /**
                 * Constructs a new SourceCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a SourceCodeInfo.
                 * @implements ISourceCodeInfo
                 * @constructor
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 */
                function SourceCodeInfo(properties) {
                    this.location = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCodeInfo location.
                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 */
                SourceCodeInfo.prototype.location = $util.emptyArray;
    
                /**
                 * Creates a new SourceCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
                 */
                SourceCodeInfo.create = function create(properties) {
                    return new SourceCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.location.length)
                        for (var i = 0; i < message.location.length; ++i)
                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SourceCodeInfo.Location = (function() {
    
                    /**
                     * Properties of a Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @interface ILocation
                     * @property {Array.<number>|null} [path] Location path
                     * @property {Array.<number>|null} [span] Location span
                     * @property {string|null} [leadingComments] Location leadingComments
                     * @property {string|null} [trailingComments] Location trailingComments
                     * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                     */
    
                    /**
                     * Constructs a new Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @classdesc Represents a Location.
                     * @implements ILocation
                     * @constructor
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     */
                    function Location(properties) {
                        this.path = [];
                        this.span = [];
                        this.leadingDetachedComments = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Location path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.path = $util.emptyArray;
    
                    /**
                     * Location span.
                     * @member {Array.<number>} span
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.span = $util.emptyArray;
    
                    /**
                     * Location leadingComments.
                     * @member {string} leadingComments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.leadingComments = "";
    
                    /**
                     * Location trailingComments.
                     * @member {string} trailingComments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.trailingComments = "";
    
                    /**
                     * Location leadingDetachedComments.
                     * @member {Array.<string>} leadingDetachedComments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.leadingDetachedComments = $util.emptyArray;
    
                    /**
                     * Creates a new Location instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                     */
                    Location.create = function create(properties) {
                        return new Location(properties);
                    };
    
                    /**
                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.span != null && message.span.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.span.length; ++i)
                                writer.int32(message.span[i]);
                            writer.ldelim();
                        }
                        if (message.leadingComments != null && Object.hasOwnProperty.call(message, "leadingComments"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                        if (message.trailingComments != null && Object.hasOwnProperty.call(message, "trailingComments"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                        if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                            for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                        return writer;
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                } else
                                    message.span.push(reader.int32());
                                break;
                            case 3:
                                message.leadingComments = reader.string();
                                break;
                            case 4:
                                message.trailingComments = reader.string();
                                break;
                            case 6:
                                if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                    message.leadingDetachedComments = [];
                                message.leadingDetachedComments.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return Location;
                })();
    
                return SourceCodeInfo;
            })();
    
            protobuf.GeneratedCodeInfo = (function() {
    
                /**
                 * Properties of a GeneratedCodeInfo.
                 * @memberof google.protobuf
                 * @interface IGeneratedCodeInfo
                 * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
                 */
    
                /**
                 * Constructs a new GeneratedCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a GeneratedCodeInfo.
                 * @implements IGeneratedCodeInfo
                 * @constructor
                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
                 */
                function GeneratedCodeInfo(properties) {
                    this.annotation = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GeneratedCodeInfo annotation.
                 * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @instance
                 */
                GeneratedCodeInfo.prototype.annotation = $util.emptyArray;
    
                /**
                 * Creates a new GeneratedCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
                 */
                GeneratedCodeInfo.create = function create(properties) {
                    return new GeneratedCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneratedCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.annotation != null && message.annotation.length)
                        for (var i = 0; i < message.annotation.length; ++i)
                            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneratedCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.annotation && message.annotation.length))
                                message.annotation = [];
                            message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                GeneratedCodeInfo.Annotation = (function() {
    
                    /**
                     * Properties of an Annotation.
                     * @memberof google.protobuf.GeneratedCodeInfo
                     * @interface IAnnotation
                     * @property {Array.<number>|null} [path] Annotation path
                     * @property {string|null} [sourceFile] Annotation sourceFile
                     * @property {number|null} [begin] Annotation begin
                     * @property {number|null} [end] Annotation end
                     */
    
                    /**
                     * Constructs a new Annotation.
                     * @memberof google.protobuf.GeneratedCodeInfo
                     * @classdesc Represents an Annotation.
                     * @implements IAnnotation
                     * @constructor
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                     */
                    function Annotation(properties) {
                        this.path = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Annotation path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.path = $util.emptyArray;
    
                    /**
                     * Annotation sourceFile.
                     * @member {string} sourceFile
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.sourceFile = "";
    
                    /**
                     * Annotation begin.
                     * @member {number} begin
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.begin = 0;
    
                    /**
                     * Annotation end.
                     * @member {number} end
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.end = 0;
    
                    /**
                     * Creates a new Annotation instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                     */
                    Annotation.create = function create(properties) {
                        return new Annotation(properties);
                    };
    
                    /**
                     * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Annotation.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.sourceFile != null && Object.hasOwnProperty.call(message, "sourceFile"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                        if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Decodes an Annotation message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Annotation.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                message.sourceFile = reader.string();
                                break;
                            case 3:
                                message.begin = reader.int32();
                                break;
                            case 4:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    return Annotation;
                })();
    
                return GeneratedCodeInfo;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();
    
    $root.NanoPBOptions = (function() {
    
        /**
         * Properties of a NanoPBOptions.
         * @exports INanoPBOptions
         * @interface INanoPBOptions
         * @property {number|null} [maxSize] NanoPBOptions maxSize
         * @property {number|null} [maxLength] NanoPBOptions maxLength
         * @property {number|null} [maxCount] NanoPBOptions maxCount
         * @property {IntSize|null} [intSize] NanoPBOptions intSize
         * @property {FieldType|null} [type] NanoPBOptions type
         * @property {boolean|null} [longNames] NanoPBOptions longNames
         * @property {boolean|null} [packedStruct] NanoPBOptions packedStruct
         * @property {boolean|null} [packedEnum] NanoPBOptions packedEnum
         * @property {boolean|null} [skipMessage] NanoPBOptions skipMessage
         * @property {boolean|null} [noUnions] NanoPBOptions noUnions
         * @property {number|null} [msgid] NanoPBOptions msgid
         * @property {boolean|null} [anonymousOneof] NanoPBOptions anonymousOneof
         * @property {boolean|null} [proto3] NanoPBOptions proto3
         * @property {boolean|null} [proto3SingularMsgs] NanoPBOptions proto3SingularMsgs
         * @property {boolean|null} [enumToString] NanoPBOptions enumToString
         * @property {boolean|null} [fixedLength] NanoPBOptions fixedLength
         * @property {boolean|null} [fixedCount] NanoPBOptions fixedCount
         * @property {boolean|null} [submsgCallback] NanoPBOptions submsgCallback
         * @property {TypenameMangling|null} [mangleNames] NanoPBOptions mangleNames
         * @property {string|null} [callbackDatatype] NanoPBOptions callbackDatatype
         * @property {string|null} [callbackFunction] NanoPBOptions callbackFunction
         * @property {DescriptorSize|null} [descriptorsize] NanoPBOptions descriptorsize
         * @property {boolean|null} [defaultHas] NanoPBOptions defaultHas
         * @property {Array.<string>|null} [include] NanoPBOptions include
         * @property {Array.<string>|null} [exclude] NanoPBOptions exclude
         * @property {string|null} ["package"] NanoPBOptions package
         * @property {google.protobuf.FieldDescriptorProto.Type|null} [typeOverride] NanoPBOptions typeOverride
         * @property {boolean|null} [sortByTag] NanoPBOptions sortByTag
         */
    
        /**
         * Constructs a new NanoPBOptions.
         * @exports NanoPBOptions
         * @classdesc Represents a NanoPBOptions.
         * @implements INanoPBOptions
         * @constructor
         * @param {INanoPBOptions=} [properties] Properties to set
         */
        function NanoPBOptions(properties) {
            this.include = [];
            this.exclude = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * NanoPBOptions maxSize.
         * @member {number} maxSize
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.maxSize = 0;
    
        /**
         * NanoPBOptions maxLength.
         * @member {number} maxLength
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.maxLength = 0;
    
        /**
         * NanoPBOptions maxCount.
         * @member {number} maxCount
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.maxCount = 0;
    
        /**
         * NanoPBOptions intSize.
         * @member {IntSize} intSize
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.intSize = 0;
    
        /**
         * NanoPBOptions type.
         * @member {FieldType} type
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.type = 0;
    
        /**
         * NanoPBOptions longNames.
         * @member {boolean} longNames
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.longNames = true;
    
        /**
         * NanoPBOptions packedStruct.
         * @member {boolean} packedStruct
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.packedStruct = false;
    
        /**
         * NanoPBOptions packedEnum.
         * @member {boolean} packedEnum
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.packedEnum = false;
    
        /**
         * NanoPBOptions skipMessage.
         * @member {boolean} skipMessage
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.skipMessage = false;
    
        /**
         * NanoPBOptions noUnions.
         * @member {boolean} noUnions
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.noUnions = false;
    
        /**
         * NanoPBOptions msgid.
         * @member {number} msgid
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.msgid = 0;
    
        /**
         * NanoPBOptions anonymousOneof.
         * @member {boolean} anonymousOneof
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.anonymousOneof = false;
    
        /**
         * NanoPBOptions proto3.
         * @member {boolean} proto3
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.proto3 = false;
    
        /**
         * NanoPBOptions proto3SingularMsgs.
         * @member {boolean} proto3SingularMsgs
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.proto3SingularMsgs = true;
    
        /**
         * NanoPBOptions enumToString.
         * @member {boolean} enumToString
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.enumToString = false;
    
        /**
         * NanoPBOptions fixedLength.
         * @member {boolean} fixedLength
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.fixedLength = false;
    
        /**
         * NanoPBOptions fixedCount.
         * @member {boolean} fixedCount
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.fixedCount = false;
    
        /**
         * NanoPBOptions submsgCallback.
         * @member {boolean} submsgCallback
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.submsgCallback = false;
    
        /**
         * NanoPBOptions mangleNames.
         * @member {TypenameMangling} mangleNames
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.mangleNames = 0;
    
        /**
         * NanoPBOptions callbackDatatype.
         * @member {string} callbackDatatype
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.callbackDatatype = "pb_callback_t";
    
        /**
         * NanoPBOptions callbackFunction.
         * @member {string} callbackFunction
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.callbackFunction = "pb_default_field_callback";
    
        /**
         * NanoPBOptions descriptorsize.
         * @member {DescriptorSize} descriptorsize
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.descriptorsize = 0;
    
        /**
         * NanoPBOptions defaultHas.
         * @member {boolean} defaultHas
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.defaultHas = false;
    
        /**
         * NanoPBOptions include.
         * @member {Array.<string>} include
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.include = $util.emptyArray;
    
        /**
         * NanoPBOptions exclude.
         * @member {Array.<string>} exclude
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.exclude = $util.emptyArray;
    
        /**
         * NanoPBOptions package.
         * @member {string} package
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype["package"] = "";
    
        /**
         * NanoPBOptions typeOverride.
         * @member {google.protobuf.FieldDescriptorProto.Type} typeOverride
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.typeOverride = 1;
    
        /**
         * NanoPBOptions sortByTag.
         * @member {boolean} sortByTag
         * @memberof NanoPBOptions
         * @instance
         */
        NanoPBOptions.prototype.sortByTag = true;
    
        /**
         * Creates a new NanoPBOptions instance using the specified properties.
         * @function create
         * @memberof NanoPBOptions
         * @static
         * @param {INanoPBOptions=} [properties] Properties to set
         * @returns {NanoPBOptions} NanoPBOptions instance
         */
        NanoPBOptions.create = function create(properties) {
            return new NanoPBOptions(properties);
        };
    
        /**
         * Encodes the specified NanoPBOptions message. Does not implicitly {@link NanoPBOptions.verify|verify} messages.
         * @function encode
         * @memberof NanoPBOptions
         * @static
         * @param {INanoPBOptions} message NanoPBOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NanoPBOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.maxSize != null && Object.hasOwnProperty.call(message, "maxSize"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.maxSize);
            if (message.maxCount != null && Object.hasOwnProperty.call(message, "maxCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxCount);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.longNames != null && Object.hasOwnProperty.call(message, "longNames"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.longNames);
            if (message.packedStruct != null && Object.hasOwnProperty.call(message, "packedStruct"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.packedStruct);
            if (message.skipMessage != null && Object.hasOwnProperty.call(message, "skipMessage"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.skipMessage);
            if (message.intSize != null && Object.hasOwnProperty.call(message, "intSize"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.intSize);
            if (message.noUnions != null && Object.hasOwnProperty.call(message, "noUnions"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.noUnions);
            if (message.msgid != null && Object.hasOwnProperty.call(message, "msgid"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.msgid);
            if (message.packedEnum != null && Object.hasOwnProperty.call(message, "packedEnum"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.packedEnum);
            if (message.anonymousOneof != null && Object.hasOwnProperty.call(message, "anonymousOneof"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.anonymousOneof);
            if (message.proto3 != null && Object.hasOwnProperty.call(message, "proto3"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.proto3);
            if (message.enumToString != null && Object.hasOwnProperty.call(message, "enumToString"))
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.enumToString);
            if (message.maxLength != null && Object.hasOwnProperty.call(message, "maxLength"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.maxLength);
            if (message.fixedLength != null && Object.hasOwnProperty.call(message, "fixedLength"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.fixedLength);
            if (message.fixedCount != null && Object.hasOwnProperty.call(message, "fixedCount"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.fixedCount);
            if (message.mangleNames != null && Object.hasOwnProperty.call(message, "mangleNames"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.mangleNames);
            if (message.callbackDatatype != null && Object.hasOwnProperty.call(message, "callbackDatatype"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.callbackDatatype);
            if (message.callbackFunction != null && Object.hasOwnProperty.call(message, "callbackFunction"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.callbackFunction);
            if (message.descriptorsize != null && Object.hasOwnProperty.call(message, "descriptorsize"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.descriptorsize);
            if (message.proto3SingularMsgs != null && Object.hasOwnProperty.call(message, "proto3SingularMsgs"))
                writer.uint32(/* id 21, wireType 0 =*/168).bool(message.proto3SingularMsgs);
            if (message.submsgCallback != null && Object.hasOwnProperty.call(message, "submsgCallback"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.submsgCallback);
            if (message.defaultHas != null && Object.hasOwnProperty.call(message, "defaultHas"))
                writer.uint32(/* id 23, wireType 0 =*/184).bool(message.defaultHas);
            if (message.include != null && message.include.length)
                for (var i = 0; i < message.include.length; ++i)
                    writer.uint32(/* id 24, wireType 2 =*/194).string(message.include[i]);
            if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                writer.uint32(/* id 25, wireType 2 =*/202).string(message["package"]);
            if (message.exclude != null && message.exclude.length)
                for (var i = 0; i < message.exclude.length; ++i)
                    writer.uint32(/* id 26, wireType 2 =*/210).string(message.exclude[i]);
            if (message.typeOverride != null && Object.hasOwnProperty.call(message, "typeOverride"))
                writer.uint32(/* id 27, wireType 0 =*/216).int32(message.typeOverride);
            if (message.sortByTag != null && Object.hasOwnProperty.call(message, "sortByTag"))
                writer.uint32(/* id 28, wireType 0 =*/224).bool(message.sortByTag);
            return writer;
        };
    
        /**
         * Decodes a NanoPBOptions message from the specified reader or buffer.
         * @function decode
         * @memberof NanoPBOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NanoPBOptions} NanoPBOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NanoPBOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.NanoPBOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.maxSize = reader.int32();
                    break;
                case 14:
                    message.maxLength = reader.int32();
                    break;
                case 2:
                    message.maxCount = reader.int32();
                    break;
                case 7:
                    message.intSize = reader.int32();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.longNames = reader.bool();
                    break;
                case 5:
                    message.packedStruct = reader.bool();
                    break;
                case 10:
                    message.packedEnum = reader.bool();
                    break;
                case 6:
                    message.skipMessage = reader.bool();
                    break;
                case 8:
                    message.noUnions = reader.bool();
                    break;
                case 9:
                    message.msgid = reader.uint32();
                    break;
                case 11:
                    message.anonymousOneof = reader.bool();
                    break;
                case 12:
                    message.proto3 = reader.bool();
                    break;
                case 21:
                    message.proto3SingularMsgs = reader.bool();
                    break;
                case 13:
                    message.enumToString = reader.bool();
                    break;
                case 15:
                    message.fixedLength = reader.bool();
                    break;
                case 16:
                    message.fixedCount = reader.bool();
                    break;
                case 22:
                    message.submsgCallback = reader.bool();
                    break;
                case 17:
                    message.mangleNames = reader.int32();
                    break;
                case 18:
                    message.callbackDatatype = reader.string();
                    break;
                case 19:
                    message.callbackFunction = reader.string();
                    break;
                case 20:
                    message.descriptorsize = reader.int32();
                    break;
                case 23:
                    message.defaultHas = reader.bool();
                    break;
                case 24:
                    if (!(message.include && message.include.length))
                        message.include = [];
                    message.include.push(reader.string());
                    break;
                case 26:
                    if (!(message.exclude && message.exclude.length))
                        message.exclude = [];
                    message.exclude.push(reader.string());
                    break;
                case 25:
                    message["package"] = reader.string();
                    break;
                case 27:
                    message.typeOverride = reader.int32();
                    break;
                case 28:
                    message.sortByTag = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        return NanoPBOptions;
    })();
    
    /**
     * FieldType enum.
     * @exports FieldType
     * @enum {number}
     * @property {number} FT_DEFAULT=0 FT_DEFAULT value
     * @property {number} FT_CALLBACK=1 FT_CALLBACK value
     * @property {number} FT_POINTER=4 FT_POINTER value
     * @property {number} FT_STATIC=2 FT_STATIC value
     * @property {number} FT_IGNORE=3 FT_IGNORE value
     * @property {number} FT_INLINE=5 FT_INLINE value
     */
    $root.FieldType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FT_DEFAULT"] = 0;
        values[valuesById[1] = "FT_CALLBACK"] = 1;
        values[valuesById[4] = "FT_POINTER"] = 4;
        values[valuesById[2] = "FT_STATIC"] = 2;
        values[valuesById[3] = "FT_IGNORE"] = 3;
        values[valuesById[5] = "FT_INLINE"] = 5;
        return values;
    })();
    
    /**
     * IntSize enum.
     * @exports IntSize
     * @enum {number}
     * @property {number} IS_DEFAULT=0 IS_DEFAULT value
     * @property {number} IS_8=8 IS_8 value
     * @property {number} IS_16=16 IS_16 value
     * @property {number} IS_32=32 IS_32 value
     * @property {number} IS_64=64 IS_64 value
     */
    $root.IntSize = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "IS_DEFAULT"] = 0;
        values[valuesById[8] = "IS_8"] = 8;
        values[valuesById[16] = "IS_16"] = 16;
        values[valuesById[32] = "IS_32"] = 32;
        values[valuesById[64] = "IS_64"] = 64;
        return values;
    })();
    
    /**
     * TypenameMangling enum.
     * @exports TypenameMangling
     * @enum {number}
     * @property {number} M_NONE=0 M_NONE value
     * @property {number} M_STRIP_PACKAGE=1 M_STRIP_PACKAGE value
     * @property {number} M_FLATTEN=2 M_FLATTEN value
     * @property {number} M_PACKAGE_INITIALS=3 M_PACKAGE_INITIALS value
     */
    $root.TypenameMangling = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "M_NONE"] = 0;
        values[valuesById[1] = "M_STRIP_PACKAGE"] = 1;
        values[valuesById[2] = "M_FLATTEN"] = 2;
        values[valuesById[3] = "M_PACKAGE_INITIALS"] = 3;
        return values;
    })();
    
    /**
     * DescriptorSize enum.
     * @exports DescriptorSize
     * @enum {number}
     * @property {number} DS_AUTO=0 DS_AUTO value
     * @property {number} DS_1=1 DS_1 value
     * @property {number} DS_2=2 DS_2 value
     * @property {number} DS_4=4 DS_4 value
     * @property {number} DS_8=8 DS_8 value
     */
    $root.DescriptorSize = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DS_AUTO"] = 0;
        values[valuesById[1] = "DS_1"] = 1;
        values[valuesById[2] = "DS_2"] = 2;
        values[valuesById[4] = "DS_4"] = 4;
        values[valuesById[8] = "DS_8"] = 8;
        return values;
    })();

    return $root;
});
